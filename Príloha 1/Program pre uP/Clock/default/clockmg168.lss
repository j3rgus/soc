
clockmg168.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000002f2  00800100  000027f4  00002888  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000027f4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000060  008003f2  008003f2  00002b7a  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  00002b7a  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000577  00000000  00000000  00002b9a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002e6a  00000000  00000000  00003111  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000004a1  00000000  00000000  00005f7b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000296e  00000000  00000000  0000641c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000470  00000000  00000000  00008d8c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000613  00000000  00000000  000091fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000015ab  00000000  00000000  0000980f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000510  00000000  00000000  0000adba  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 4b 07 	jmp	0xe96	; 0xe96 <__vector_9>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 87 04 	jmp	0x90e	; 0x90e <__vector_16>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 35 05 	jmp	0xa6a	; 0xa6a <__vector_18>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d4 e0       	ldi	r29, 0x04	; 4
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	13 e0       	ldi	r17, 0x03	; 3
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e4 ef       	ldi	r30, 0xF4	; 244
      7c:	f7 e2       	ldi	r31, 0x27	; 39
      7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
      84:	a2 3f       	cpi	r26, 0xF2	; 242
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>

0000008a <__do_clear_bss>:
      8a:	14 e0       	ldi	r17, 0x04	; 4
      8c:	a2 ef       	ldi	r26, 0xF2	; 242
      8e:	b3 e0       	ldi	r27, 0x03	; 3
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a2 35       	cpi	r26, 0x52	; 82
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 79 10 	call	0x20f2	; 0x20f2 <main>
      9e:	0c 94 f8 13 	jmp	0x27f0	; 0x27f0 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <one_reset>:
#include <util/delay.h>

char one_reset(void)
{
  char r;
  asm("cli");
      a6:	f8 94       	cli
  DDR |= DQ;
      a8:	57 9a       	sbi	0x0a, 7	; 10
  PORT &= ~DQ;
      aa:	5f 98       	cbi	0x0b, 7	; 11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
      ac:	88 ee       	ldi	r24, 0xE8	; 232
      ae:	93 e0       	ldi	r25, 0x03	; 3
      b0:	01 97       	sbiw	r24, 0x01	; 1
      b2:	f1 f7       	brne	.-4      	; 0xb0 <one_reset+0xa>
  _delay_us(500);
  DDR &= ~DQ;
      b4:	57 98       	cbi	0x0a, 7	; 10
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
      b6:	8a e6       	ldi	r24, 0x6A	; 106
      b8:	8a 95       	dec	r24
      ba:	f1 f7       	brne	.-4      	; 0xb8 <one_reset+0x12>
  _delay_us(40);
  r = (DDR & DQ) ? 0 : 1;
      bc:	8a b1       	in	r24, 0x0a	; 10
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
      be:	e0 ee       	ldi	r30, 0xE0	; 224
      c0:	f1 e0       	ldi	r31, 0x01	; 1
      c2:	31 97       	sbiw	r30, 0x01	; 1
      c4:	f1 f7       	brne	.-4      	; 0xc2 <one_reset+0x1c>
  _delay_us(240);
  asm("sei");
      c6:	78 94       	sei
      c8:	80 95       	com	r24
  return r;
}
      ca:	88 1f       	adc	r24, r24
      cc:	88 27       	eor	r24, r24
      ce:	88 1f       	adc	r24, r24
      d0:	08 95       	ret

000000d2 <one_read_byte>:
*/

char one_read_byte(void)
{
  char i, data = 0;
  asm("cli");
      d2:	f8 94       	cli
      d4:	20 e0       	ldi	r18, 0x00	; 0
      d6:	90 e0       	ldi	r25, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
      d8:	3a e1       	ldi	r19, 0x1A	; 26
  for (i = 0; i < 8; i++) {
    data >>= 1;
    DDR |= DQ;
      da:	40 ea       	ldi	r20, 0xA0	; 160
      dc:	57 9a       	sbi	0x0a, 7	; 10
    PORT &= ~DQ;
      de:	5f 98       	cbi	0x0b, 7	; 11
      e0:	83 2f       	mov	r24, r19
      e2:	8a 95       	dec	r24
      e4:	f1 f7       	brne	.-4      	; 0xe2 <one_read_byte+0x10>
    _delay_us(10);
    DDR &= ~DQ;
      e6:	57 98       	cbi	0x0a, 7	; 10
      e8:	83 2f       	mov	r24, r19
      ea:	8a 95       	dec	r24
      ec:	f1 f7       	brne	.-4      	; 0xea <one_read_byte+0x18>
    _delay_us(10);
    data |= (PIN & DQ) ? 0b10000000 : 0;
      ee:	89 b1       	in	r24, 0x09	; 9
      f0:	96 95       	lsr	r25
      f2:	80 78       	andi	r24, 0x80	; 128
      f4:	98 2b       	or	r25, r24
      f6:	84 2f       	mov	r24, r20
      f8:	8a 95       	dec	r24
      fa:	f1 f7       	brne	.-4      	; 0xf8 <one_read_byte+0x26>

char one_read_byte(void)
{
  char i, data = 0;
  asm("cli");
  for (i = 0; i < 8; i++) {
      fc:	2f 5f       	subi	r18, 0xFF	; 255
      fe:	28 30       	cpi	r18, 0x08	; 8
     100:	69 f7       	brne	.-38     	; 0xdc <one_read_byte+0xa>
    DDR &= ~DQ;
    _delay_us(10);
    data |= (PIN & DQ) ? 0b10000000 : 0;
    _delay_us(60);
  }   
  asm("sei");
     102:	78 94       	sei
  return data;
}
     104:	89 2f       	mov	r24, r25
     106:	08 95       	ret

00000108 <one_write_byte>:
*/

void one_write_byte(char data)
{
  char i;
  asm("cli");
     108:	f8 94       	cli
     10a:	20 e0       	ldi	r18, 0x00	; 0
     10c:	4a e1       	ldi	r20, 0x1A	; 26
  for (i = 0; i < 8; i++) {
    DDR |= DQ;
     10e:	35 e8       	ldi	r19, 0x85	; 133
     110:	57 9a       	sbi	0x0a, 7	; 10
    PORT &= ~DQ;
     112:	5f 98       	cbi	0x0b, 7	; 11
    if ((data & 1) == 0) {
     114:	80 fd       	sbrc	r24, 0
     116:	06 c0       	rjmp	.+12     	; 0x124 <one_write_byte+0x1c>
     118:	93 2f       	mov	r25, r19
     11a:	9a 95       	dec	r25
     11c:	f1 f7       	brne	.-4      	; 0x11a <one_write_byte+0x12>
      _delay_us(50);
      DDR &= ~DQ;
     11e:	57 98       	cbi	0x0a, 7	; 10
     120:	94 2f       	mov	r25, r20
     122:	05 c0       	rjmp	.+10     	; 0x12e <one_write_byte+0x26>
     124:	94 2f       	mov	r25, r20
     126:	9a 95       	dec	r25
     128:	f1 f7       	brne	.-4      	; 0x126 <one_write_byte+0x1e>
      _delay_us(10);
    }
    else {
      _delay_us(10);
      DDR &= ~DQ;
     12a:	57 98       	cbi	0x0a, 7	; 10
     12c:	93 2f       	mov	r25, r19
     12e:	9a 95       	dec	r25
     130:	f1 f7       	brne	.-4      	; 0x12e <one_write_byte+0x26>

void one_write_byte(char data)
{
  char i;
  asm("cli");
  for (i = 0; i < 8; i++) {
     132:	2f 5f       	subi	r18, 0xFF	; 255
     134:	28 30       	cpi	r18, 0x08	; 8
     136:	11 f0       	breq	.+4      	; 0x13c <one_write_byte+0x34>
    else {
      _delay_us(10);
      DDR &= ~DQ;
      _delay_us(50);
    }
    data >>= 1;
     138:	86 95       	lsr	r24
     13a:	ea cf       	rjmp	.-44     	; 0x110 <one_write_byte+0x8>
  }
  asm("sei");
     13c:	78 94       	sei
}
     13e:	08 95       	ret

00000140 <send_convert>:
   Funkcia vysle prikaz pre konvertovanie
*/

void send_convert(void)
{
  one_write_byte(0xcc);
     140:	8c ec       	ldi	r24, 0xCC	; 204
     142:	0e 94 84 00 	call	0x108	; 0x108 <one_write_byte>
  one_write_byte(0x44);
     146:	84 e4       	ldi	r24, 0x44	; 68
     148:	0e 94 84 00 	call	0x108	; 0x108 <one_write_byte>
}
     14c:	08 95       	ret

0000014e <send_getTemp>:
   Pre DS1820 je nutne pockat min 400ms na skonvertovanie
*/

void send_getTemp(void)
{
  one_write_byte(0xcc);
     14e:	8c ec       	ldi	r24, 0xCC	; 204
     150:	0e 94 84 00 	call	0x108	; 0x108 <one_write_byte>
  one_write_byte(0xbe);
     154:	8e eb       	ldi	r24, 0xBE	; 190
     156:	0e 94 84 00 	call	0x108	; 0x108 <one_write_byte>
}
     15a:	08 95       	ret

0000015c <i2c_start>:
   Vrati 0 ak sa senzor nenachadza na zbernici.
*/

char i2c_start(void)
{
  asm("cli");
     15c:	f8 94       	cli
  i2c_DDR &= ~(1 << SCL);
     15e:	56 98       	cbi	0x0a, 6	; 10
  i2c_DDR &= ~(1 << SDA);
     160:	55 98       	cbi	0x0a, 5	; 10
  asm("nop");
     162:	00 00       	nop
  asm("nop");
     164:	00 00       	nop
  if (bit_is_clear(i2c_PIN, SDA))
     166:	4d 9b       	sbis	0x09, 5	; 9
     168:	0f c0       	rjmp	.+30     	; 0x188 <i2c_start+0x2c>
    return 0;
  if (bit_is_clear(i2c_PIN, SCL))
     16a:	4e 9b       	sbis	0x09, 6	; 9
     16c:	0d c0       	rjmp	.+26     	; 0x188 <i2c_start+0x2c>
     16e:	8d e0       	ldi	r24, 0x0D	; 13
     170:	98 2f       	mov	r25, r24
     172:	9a 95       	dec	r25
     174:	f1 f7       	brne	.-4      	; 0x172 <i2c_start+0x16>
    return 0;
  _delay_us(5);
  i2c_DDR |= (1 << SDA);
     176:	55 9a       	sbi	0x0a, 5	; 10
  i2c_PORT &= ~(1 << SDA);
     178:	5d 98       	cbi	0x0b, 5	; 11
     17a:	8a 95       	dec	r24
     17c:	f1 f7       	brne	.-4      	; 0x17a <i2c_start+0x1e>
  _delay_us(5);
  i2c_DDR |= (1 << SCL);
     17e:	56 9a       	sbi	0x0a, 6	; 10
  i2c_PORT &= ~(1 << SCL);
     180:	5e 98       	cbi	0x0b, 6	; 11
  asm("sei");
     182:	78 94       	sei
     184:	81 e0       	ldi	r24, 0x01	; 1
     186:	08 95       	ret
  return 1;
     188:	80 e0       	ldi	r24, 0x00	; 0
}
     18a:	08 95       	ret

0000018c <i2c_stop>:
   Nevrati ziadnu hodnotu a nepozaduje parametre
*/

void i2c_stop(void)
{
  asm("cli");
     18c:	f8 94       	cli
  i2c_DDR |= (1 << SDA);
     18e:	55 9a       	sbi	0x0a, 5	; 10
  i2c_PORT &= ~(1 << SDA);
     190:	5d 98       	cbi	0x0b, 5	; 11
  i2c_DDR |= (1 << SCL);
     192:	56 9a       	sbi	0x0a, 6	; 10
  i2c_PORT &= ~(1 << SCL);
     194:	5e 98       	cbi	0x0b, 6	; 11
     196:	8a e1       	ldi	r24, 0x1A	; 26
     198:	8a 95       	dec	r24
     19a:	f1 f7       	brne	.-4      	; 0x198 <i2c_stop+0xc>
  _delay_us(10);
  i2c_DDR &= ~(1 << SCL);
     19c:	56 98       	cbi	0x0a, 6	; 10
     19e:	8d e0       	ldi	r24, 0x0D	; 13
     1a0:	8a 95       	dec	r24
     1a2:	f1 f7       	brne	.-4      	; 0x1a0 <i2c_stop+0x14>
  _delay_us(5);
  i2c_DDR &= ~(1 << SDA);
     1a4:	55 98       	cbi	0x0a, 5	; 10
  asm("sei");
     1a6:	78 94       	sei
}
     1a8:	08 95       	ret

000001aa <i2c_write>:

char i2c_write(char data)
{
  char i, res = 1;
  
  asm("cli");
     1aa:	f8 94       	cli
     1ac:	20 e0       	ldi	r18, 0x00	; 0
     1ae:	4a e1       	ldi	r20, 0x1A	; 26
  for (i = 0; i < 8; i++) {
    if ((data & 0x80) == 0) {
     1b0:	3d e0       	ldi	r19, 0x0D	; 13
     1b2:	87 fd       	sbrc	r24, 7
     1b4:	03 c0       	rjmp	.+6      	; 0x1bc <i2c_write+0x12>
	  i2c_DDR |= (1 << SDA);
     1b6:	55 9a       	sbi	0x0a, 5	; 10
	  i2c_PORT &= ~(1 << SDA);
     1b8:	5d 98       	cbi	0x0b, 5	; 11
     1ba:	01 c0       	rjmp	.+2      	; 0x1be <i2c_write+0x14>
	}
	else
	  i2c_DDR &= ~(1 << SDA);
     1bc:	55 98       	cbi	0x0a, 5	; 10
     1be:	94 2f       	mov	r25, r20
     1c0:	9a 95       	dec	r25
     1c2:	f1 f7       	brne	.-4      	; 0x1c0 <i2c_write+0x16>
	
	_delay_us(10);
	i2c_DDR &= ~(1 << SCL);
     1c4:	56 98       	cbi	0x0a, 6	; 10
     1c6:	93 2f       	mov	r25, r19
     1c8:	9a 95       	dec	r25
     1ca:	f1 f7       	brne	.-4      	; 0x1c8 <i2c_write+0x1e>
	_delay_us(5);
	while (bit_is_clear(i2c_PIN, SCL))
     1cc:	4e 9b       	sbis	0x09, 6	; 9
     1ce:	fe cf       	rjmp	.-4      	; 0x1cc <i2c_write+0x22>
     1d0:	93 2f       	mov	r25, r19
     1d2:	9a 95       	dec	r25
     1d4:	f1 f7       	brne	.-4      	; 0x1d2 <i2c_write+0x28>
	  ;
	_delay_us(5);
	i2c_DDR |= (1 << SCL);
     1d6:	56 9a       	sbi	0x0a, 6	; 10
	i2c_PORT &= ~(1 << SCL);
     1d8:	5e 98       	cbi	0x0b, 6	; 11
char i2c_write(char data)
{
  char i, res = 1;
  
  asm("cli");
  for (i = 0; i < 8; i++) {
     1da:	2f 5f       	subi	r18, 0xFF	; 255
     1dc:	28 30       	cpi	r18, 0x08	; 8
     1de:	11 f0       	breq	.+4      	; 0x1e4 <i2c_write+0x3a>
	while (bit_is_clear(i2c_PIN, SCL))
	  ;
	_delay_us(5);
	i2c_DDR |= (1 << SCL);
	i2c_PORT &= ~(1 << SCL);
	data <<= 1;
     1e0:	88 0f       	add	r24, r24
     1e2:	e7 cf       	rjmp	.-50     	; 0x1b2 <i2c_write+0x8>
  }
  i2c_DDR &= ~(1 << SDA);
     1e4:	55 98       	cbi	0x0a, 5	; 10
     1e6:	8d e0       	ldi	r24, 0x0D	; 13
     1e8:	8a 95       	dec	r24
     1ea:	f1 f7       	brne	.-4      	; 0x1e8 <i2c_write+0x3e>
  _delay_us(5);
  i2c_DDR &= ~(1 << SCL);
     1ec:	56 98       	cbi	0x0a, 6	; 10
     1ee:	8a e1       	ldi	r24, 0x1A	; 26
     1f0:	8a 95       	dec	r24
     1f2:	f1 f7       	brne	.-4      	; 0x1f0 <i2c_write+0x46>
  _delay_us(10);
  if (bit_is_set(i2c_PIN, SDA))
     1f4:	89 b1       	in	r24, 0x09	; 9
    res = 0;
  i2c_DDR |= (1 << SCL);
     1f6:	56 9a       	sbi	0x0a, 6	; 10
  i2c_PORT &= ~(1 << SCL);
     1f8:	5e 98       	cbi	0x0b, 6	; 11
  asm("sei");
     1fa:	78 94       	sei
     1fc:	82 95       	swap	r24
     1fe:	86 95       	lsr	r24
     200:	87 70       	andi	r24, 0x07	; 7
     202:	80 95       	com	r24
  return res;
}
     204:	81 70       	andi	r24, 0x01	; 1
     206:	08 95       	ret

00000208 <i2c_read>:

char i2c_read(void)
{
  char i, data = 0;
  
  asm("cli");
     208:	f8 94       	cli
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	20 e0       	ldi	r18, 0x00	; 0
     20e:	4d e0       	ldi	r20, 0x0D	; 13
  for (i = 0; i < 8; i++) {
    data <<= 1;
     210:	3a e1       	ldi	r19, 0x1A	; 26
     212:	22 0f       	add	r18, r18
    i2c_DDR &= ~(1 << SCL);
     214:	56 98       	cbi	0x0a, 6	; 10
	while (bit_is_clear(i2c_PIN, SCL))
     216:	4e 9b       	sbis	0x09, 6	; 9
     218:	fe cf       	rjmp	.-4      	; 0x216 <i2c_read+0xe>
     21a:	84 2f       	mov	r24, r20
     21c:	8a 95       	dec	r24
     21e:	f1 f7       	brne	.-4      	; 0x21c <i2c_read+0x14>
	  ;
	_delay_us(5);
	if (bit_is_clear(i2c_PIN, SDA))
     220:	4d 99       	sbic	0x09, 5	; 9
	  data |= 0;
	else data |= 1;
     222:	21 60       	ori	r18, 0x01	; 1
     224:	83 2f       	mov	r24, r19
     226:	8a 95       	dec	r24
     228:	f1 f7       	brne	.-4      	; 0x226 <i2c_read+0x1e>
	_delay_us(10);
	i2c_DDR |= (1 << SCL);
     22a:	56 9a       	sbi	0x0a, 6	; 10
	i2c_PORT &= ~(1 << SCL);
     22c:	5e 98       	cbi	0x0b, 6	; 11
     22e:	83 2f       	mov	r24, r19
     230:	8a 95       	dec	r24
     232:	f1 f7       	brne	.-4      	; 0x230 <i2c_read+0x28>
char i2c_read(void)
{
  char i, data = 0;
  
  asm("cli");
  for (i = 0; i < 8; i++) {
     234:	9f 5f       	subi	r25, 0xFF	; 255
     236:	98 30       	cpi	r25, 0x08	; 8
     238:	61 f7       	brne	.-40     	; 0x212 <i2c_read+0xa>
	_delay_us(10);
	i2c_DDR |= (1 << SCL);
	i2c_PORT &= ~(1 << SCL);
	_delay_us(10);
  }
  i2c_DDR &= ~(1 << SDA);
     23a:	55 98       	cbi	0x0a, 5	; 10
     23c:	8d e0       	ldi	r24, 0x0D	; 13
     23e:	98 2f       	mov	r25, r24
     240:	9a 95       	dec	r25
     242:	f1 f7       	brne	.-4      	; 0x240 <i2c_read+0x38>
  _delay_us(5);
  i2c_DDR &= ~(1 << SCL);
     244:	56 98       	cbi	0x0a, 6	; 10
     246:	9a e1       	ldi	r25, 0x1A	; 26
     248:	9a 95       	dec	r25
     24a:	f1 f7       	brne	.-4      	; 0x248 <i2c_read+0x40>
  _delay_us(10);
  i2c_DDR |= (1 << SCL);
     24c:	56 9a       	sbi	0x0a, 6	; 10
  i2c_PORT &= ~(1 << SCL);
     24e:	5e 98       	cbi	0x0b, 6	; 11
     250:	98 2f       	mov	r25, r24
     252:	9a 95       	dec	r25
     254:	f1 f7       	brne	.-4      	; 0x252 <i2c_read+0x4a>
  _delay_us(5);
  i2c_DDR &= ~(1 << SDA);
     256:	55 98       	cbi	0x0a, 5	; 10
     258:	8a 95       	dec	r24
     25a:	f1 f7       	brne	.-4      	; 0x258 <i2c_read+0x50>
  _delay_us(5);
  asm("sei");
     25c:	78 94       	sei
  return data;
}
     25e:	82 2f       	mov	r24, r18
     260:	08 95       	ret

00000262 <write_ds1307>:
   Funkcia:	 void write_ds1307(char addr, char data)
   Funkcia zapise 'data' na adresu 'addr'
*/

void write_ds1307(char addr, char data)
{
     262:	0f 93       	push	r16
     264:	1f 93       	push	r17
     266:	18 2f       	mov	r17, r24
     268:	06 2f       	mov	r16, r22
 i2c_start();
     26a:	0e 94 ae 00 	call	0x15c	; 0x15c <i2c_start>
 i2c_write(0xD0);
     26e:	80 ed       	ldi	r24, 0xD0	; 208
     270:	0e 94 d5 00 	call	0x1aa	; 0x1aa <i2c_write>
 i2c_write(addr);
     274:	81 2f       	mov	r24, r17
     276:	0e 94 d5 00 	call	0x1aa	; 0x1aa <i2c_write>
 i2c_write(data);
     27a:	80 2f       	mov	r24, r16
     27c:	0e 94 d5 00 	call	0x1aa	; 0x1aa <i2c_write>
 i2c_stop();
     280:	0e 94 c6 00 	call	0x18c	; 0x18c <i2c_stop>
}
     284:	1f 91       	pop	r17
     286:	0f 91       	pop	r16
     288:	08 95       	ret

0000028a <read_ds1307>:
   Funkcia nacita byte z adresy 'addr'
   Vrati nacitane byte
*/

char read_ds1307(char addr)
{       
     28a:	1f 93       	push	r17
     28c:	18 2f       	mov	r17, r24
 char data;
 i2c_start();
     28e:	0e 94 ae 00 	call	0x15c	; 0x15c <i2c_start>
 i2c_write(0xD0);
     292:	80 ed       	ldi	r24, 0xD0	; 208
     294:	0e 94 d5 00 	call	0x1aa	; 0x1aa <i2c_write>
 i2c_write(addr);
     298:	81 2f       	mov	r24, r17
     29a:	0e 94 d5 00 	call	0x1aa	; 0x1aa <i2c_write>
 i2c_start();
     29e:	0e 94 ae 00 	call	0x15c	; 0x15c <i2c_start>
 i2c_write(0xD1);
     2a2:	81 ed       	ldi	r24, 0xD1	; 209
     2a4:	0e 94 d5 00 	call	0x1aa	; 0x1aa <i2c_write>
 data = i2c_read();
     2a8:	0e 94 04 01 	call	0x208	; 0x208 <i2c_read>
     2ac:	18 2f       	mov	r17, r24
 i2c_stop();
     2ae:	0e 94 c6 00 	call	0x18c	; 0x18c <i2c_stop>
 return data;
     2b2:	81 2f       	mov	r24, r17
     2b4:	1f 91       	pop	r17
     2b6:	08 95       	ret

000002b8 <LCDsendChar>:
#include <avr/pgmspace.h>
#include <util/delay.h>

void LCDsendChar(uint8_t ch)		//Sends Char to LCD
{
	asm("cli");
     2b8:	f8 94       	cli
	LDP=(ch&0b11110000);
     2ba:	28 2f       	mov	r18, r24
     2bc:	20 7f       	andi	r18, 0xF0	; 240
     2be:	25 b9       	out	0x05, r18	; 5
	LCP|=1<<LCD_RS;
     2c0:	28 9a       	sbi	0x05, 0	; 5
	LCP|=1<<LCD_E;		
     2c2:	2a 9a       	sbi	0x05, 2	; 5
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     2c4:	20 ed       	ldi	r18, 0xD0	; 208
     2c6:	37 e0       	ldi	r19, 0x07	; 7
     2c8:	f9 01       	movw	r30, r18
     2ca:	31 97       	sbiw	r30, 0x01	; 1
     2cc:	f1 f7       	brne	.-4      	; 0x2ca <LCDsendChar+0x12>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);	
     2ce:	2a 98       	cbi	0x05, 2	; 5
	LCP&=~(1<<LCD_RS);
     2d0:	28 98       	cbi	0x05, 0	; 5
     2d2:	f9 01       	movw	r30, r18
     2d4:	31 97       	sbiw	r30, 0x01	; 1
     2d6:	f1 f7       	brne	.-4      	; 0x2d4 <LCDsendChar+0x1c>
	_delay_ms(1);
	LDP=((ch&0b00001111)<<4);
     2d8:	90 e0       	ldi	r25, 0x00	; 0
     2da:	44 e0       	ldi	r20, 0x04	; 4
     2dc:	88 0f       	add	r24, r24
     2de:	99 1f       	adc	r25, r25
     2e0:	4a 95       	dec	r20
     2e2:	e1 f7       	brne	.-8      	; 0x2dc <LCDsendChar+0x24>
     2e4:	85 b9       	out	0x05, r24	; 5
	LCP|=1<<LCD_RS;
     2e6:	28 9a       	sbi	0x05, 0	; 5
	LCP|=1<<LCD_E;		
     2e8:	2a 9a       	sbi	0x05, 2	; 5
     2ea:	c9 01       	movw	r24, r18
     2ec:	01 97       	sbiw	r24, 0x01	; 1
     2ee:	f1 f7       	brne	.-4      	; 0x2ec <LCDsendChar+0x34>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);	
     2f0:	2a 98       	cbi	0x05, 2	; 5
	LCP&=~(1<<LCD_RS);
     2f2:	28 98       	cbi	0x05, 0	; 5
     2f4:	c9 01       	movw	r24, r18
     2f6:	01 97       	sbiw	r24, 0x01	; 1
     2f8:	f1 f7       	brne	.-4      	; 0x2f6 <LCDsendChar+0x3e>
	_delay_ms(1);
	asm("sei");
     2fa:	78 94       	sei
}
     2fc:	08 95       	ret

000002fe <LCDsendCommand>:
void LCDsendCommand(uint8_t cmd)	//Sends Command to LCD
{
	asm("cli");
     2fe:	f8 94       	cli
	LDP=(cmd&0b11110000);
     300:	28 2f       	mov	r18, r24
     302:	20 7f       	andi	r18, 0xF0	; 240
     304:	25 b9       	out	0x05, r18	; 5
	LCP|=1<<LCD_E;		
     306:	2a 9a       	sbi	0x05, 2	; 5
     308:	20 ed       	ldi	r18, 0xD0	; 208
     30a:	37 e0       	ldi	r19, 0x07	; 7
     30c:	f9 01       	movw	r30, r18
     30e:	31 97       	sbiw	r30, 0x01	; 1
     310:	f1 f7       	brne	.-4      	; 0x30e <LCDsendCommand+0x10>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
     312:	2a 98       	cbi	0x05, 2	; 5
     314:	f9 01       	movw	r30, r18
     316:	31 97       	sbiw	r30, 0x01	; 1
     318:	f1 f7       	brne	.-4      	; 0x316 <LCDsendCommand+0x18>
	_delay_ms(1);
	LDP=((cmd&0b00001111)<<4);	
     31a:	90 e0       	ldi	r25, 0x00	; 0
     31c:	54 e0       	ldi	r21, 0x04	; 4
     31e:	88 0f       	add	r24, r24
     320:	99 1f       	adc	r25, r25
     322:	5a 95       	dec	r21
     324:	e1 f7       	brne	.-8      	; 0x31e <LCDsendCommand+0x20>
     326:	85 b9       	out	0x05, r24	; 5
	LCP|=1<<LCD_E;		
     328:	2a 9a       	sbi	0x05, 2	; 5
     32a:	c9 01       	movw	r24, r18
     32c:	01 97       	sbiw	r24, 0x01	; 1
     32e:	f1 f7       	brne	.-4      	; 0x32c <LCDsendCommand+0x2e>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
     330:	2a 98       	cbi	0x05, 2	; 5
     332:	c9 01       	movw	r24, r18
     334:	01 97       	sbiw	r24, 0x01	; 1
     336:	f1 f7       	brne	.-4      	; 0x334 <LCDsendCommand+0x36>
	_delay_ms(1);
	asm("sei");
     338:	78 94       	sei
}
     33a:	08 95       	ret

0000033c <LCDinit>:
void LCDinit(void)//Initializes LCD
{
	asm("cli");
     33c:	f8 94       	cli
     33e:	80 e3       	ldi	r24, 0x30	; 48
     340:	95 e7       	ldi	r25, 0x75	; 117
     342:	01 97       	sbiw	r24, 0x01	; 1
     344:	f1 f7       	brne	.-4      	; 0x342 <LCDinit+0x6>
	_delay_ms(15);
	LDP=0x00;
     346:	15 b8       	out	0x05, r1	; 5
	LCP=0x00;
     348:	15 b8       	out	0x05, r1	; 5
	LDDR|=1<<LCD_D7|1<<LCD_D6|1<<LCD_D5|1<<LCD_D4;
     34a:	84 b1       	in	r24, 0x04	; 4
     34c:	80 6f       	ori	r24, 0xF0	; 240
     34e:	84 b9       	out	0x04, r24	; 4
	LCDR|=1<<LCD_E|1<<LCD_RW|1<<LCD_RS;
     350:	84 b1       	in	r24, 0x04	; 4
     352:	87 60       	ori	r24, 0x07	; 7
     354:	84 b9       	out	0x04, r24	; 4
   //---------one------
	LDP=0<<LCD_D7|0<<LCD_D6|1<<LCD_D5|1<<LCD_D4; //4 bit mode
     356:	80 e3       	ldi	r24, 0x30	; 48
     358:	85 b9       	out	0x05, r24	; 5
	LCP|=1<<LCD_E|0<<LCD_RW|0<<LCD_RS;		
     35a:	2a 9a       	sbi	0x05, 2	; 5
     35c:	20 ed       	ldi	r18, 0xD0	; 208
     35e:	37 e0       	ldi	r19, 0x07	; 7
     360:	f9 01       	movw	r30, r18
     362:	31 97       	sbiw	r30, 0x01	; 1
     364:	f1 f7       	brne	.-4      	; 0x362 <LCDinit+0x26>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
     366:	2a 98       	cbi	0x05, 2	; 5
     368:	f9 01       	movw	r30, r18
     36a:	31 97       	sbiw	r30, 0x01	; 1
     36c:	f1 f7       	brne	.-4      	; 0x36a <LCDinit+0x2e>
	_delay_ms(1);
	//-----------two-----------
	LDP=0<<LCD_D7|0<<LCD_D6|1<<LCD_D5|1<<LCD_D4; //4 bit mode
     36e:	85 b9       	out	0x05, r24	; 5
	LCP|=1<<LCD_E|0<<LCD_RW|0<<LCD_RS;		
     370:	2a 9a       	sbi	0x05, 2	; 5
     372:	c9 01       	movw	r24, r18
     374:	01 97       	sbiw	r24, 0x01	; 1
     376:	f1 f7       	brne	.-4      	; 0x374 <LCDinit+0x38>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
     378:	2a 98       	cbi	0x05, 2	; 5
     37a:	c9 01       	movw	r24, r18
     37c:	01 97       	sbiw	r24, 0x01	; 1
     37e:	f1 f7       	brne	.-4      	; 0x37c <LCDinit+0x40>
	_delay_ms(1);
	//-------three-------------
	LDP=0<<LCD_D7|0<<LCD_D6|1<<LCD_D5|0<<LCD_D4; //4 bit mode
     380:	80 e2       	ldi	r24, 0x20	; 32
     382:	85 b9       	out	0x05, r24	; 5
	LCP|=1<<LCD_E|0<<LCD_RW|0<<LCD_RS;		
     384:	2a 9a       	sbi	0x05, 2	; 5
     386:	c9 01       	movw	r24, r18
     388:	01 97       	sbiw	r24, 0x01	; 1
     38a:	f1 f7       	brne	.-4      	; 0x388 <LCDinit+0x4c>
	_delay_ms(1);
	LCP&=~(1<<LCD_E);
     38c:	2a 98       	cbi	0x05, 2	; 5
     38e:	c9 01       	movw	r24, r18
     390:	01 97       	sbiw	r24, 0x01	; 1
     392:	f1 f7       	brne	.-4      	; 0x390 <LCDinit+0x54>
	_delay_ms(1);
	//--------4 bit--dual line---------------
	LCDsendCommand(0b00101000);
     394:	88 e2       	ldi	r24, 0x28	; 40
     396:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
   //-----increment address, cursor shift------
	LCDsendCommand(0b00001110);
     39a:	8e e0       	ldi	r24, 0x0E	; 14
     39c:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
	asm("sei");
     3a0:	78 94       	sei
}			
     3a2:	08 95       	ret

000003a4 <LCDclr>:
void LCDclr(void)				//Clears LCD
{
	LCDsendCommand(1<<LCD_CLR);
     3a4:	81 e0       	ldi	r24, 0x01	; 1
     3a6:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     3aa:	08 95       	ret

000003ac <LCDhome>:
void LCDhome(void)			//LCD cursor home
{
	LCDsendCommand(1<<LCD_HOME);
     3ac:	82 e0       	ldi	r24, 0x02	; 2
     3ae:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     3b2:	08 95       	ret

000003b4 <LCDstring>:
void LCDstring(uint8_t* data, uint8_t nBytes)	//Outputs string to LCD
{
     3b4:	0f 93       	push	r16
     3b6:	1f 93       	push	r17
     3b8:	cf 93       	push	r28
     3ba:	df 93       	push	r29
     3bc:	06 2f       	mov	r16, r22
register uint8_t i;

	// check to make sure we have a good pointer
	if (!data) return;
     3be:	00 97       	sbiw	r24, 0x00	; 0
     3c0:	49 f0       	breq	.+18     	; 0x3d4 <LCDstring+0x20>
     3c2:	ec 01       	movw	r28, r24
     3c4:	10 e0       	ldi	r17, 0x00	; 0
     3c6:	04 c0       	rjmp	.+8      	; 0x3d0 <LCDstring+0x1c>

	// print data
	for(i=0; i<nBytes; i++)
	{
		LCDsendChar(data[i]);
     3c8:	89 91       	ld	r24, Y+
     3ca:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>

	// check to make sure we have a good pointer
	if (!data) return;

	// print data
	for(i=0; i<nBytes; i++)
     3ce:	1f 5f       	subi	r17, 0xFF	; 255
     3d0:	10 17       	cp	r17, r16
     3d2:	d0 f3       	brcs	.-12     	; 0x3c8 <LCDstring+0x14>
	{
		LCDsendChar(data[i]);
	}
}
     3d4:	df 91       	pop	r29
     3d6:	cf 91       	pop	r28
     3d8:	1f 91       	pop	r17
     3da:	0f 91       	pop	r16
     3dc:	08 95       	ret

000003de <LCDGotoXY>:
void LCDGotoXY(uint8_t x, uint8_t y)	//Cursor to X Y position
{
	asm("cli");
     3de:	f8 94       	cli
	register uint8_t DDRAMAddr;
	// remap lines into proper order
	switch(y)
     3e0:	62 30       	cpi	r22, 0x02	; 2
     3e2:	31 f0       	breq	.+12     	; 0x3f0 <LCDGotoXY+0x12>
     3e4:	63 30       	cpi	r22, 0x03	; 3
     3e6:	31 f0       	breq	.+12     	; 0x3f4 <LCDGotoXY+0x16>
     3e8:	61 30       	cpi	r22, 0x01	; 1
     3ea:	29 f4       	brne	.+10     	; 0x3f6 <LCDGotoXY+0x18>
	{
	case 0: DDRAMAddr = LCD_LINE0_DDRAMADDR+x; break;
	case 1: DDRAMAddr = LCD_LINE1_DDRAMADDR+x; break;
     3ec:	80 5c       	subi	r24, 0xC0	; 192
     3ee:	03 c0       	rjmp	.+6      	; 0x3f6 <LCDGotoXY+0x18>
	case 2: DDRAMAddr = LCD_LINE2_DDRAMADDR+x; break;
     3f0:	8c 5e       	subi	r24, 0xEC	; 236
     3f2:	01 c0       	rjmp	.+2      	; 0x3f6 <LCDGotoXY+0x18>
	case 3: DDRAMAddr = LCD_LINE3_DDRAMADDR+x; break;
     3f4:	8c 5a       	subi	r24, 0xAC	; 172
	default: DDRAMAddr = LCD_LINE0_DDRAMADDR+x;
	}
	// set data address
	LCDsendCommand(1<<LCD_DDRAM | DDRAMAddr);
     3f6:	80 68       	ori	r24, 0x80	; 128
     3f8:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
	asm("sei");
     3fc:	78 94       	sei
}
     3fe:	08 95       	ret

00000400 <CopyStringtoLCD>:
//Copies string from flash memory to LCD at x y position
//const uint8_t welcomeln1[] PROGMEM="AVR LCD DEMO\0";
//CopyStringtoLCD(welcomeln1, 3, 1);	
void CopyStringtoLCD(const uint8_t *FlashLoc, uint8_t x, uint8_t y)
{
     400:	1f 93       	push	r17
     402:	cf 93       	push	r28
     404:	df 93       	push	r29
     406:	ec 01       	movw	r28, r24
     408:	86 2f       	mov	r24, r22
	uint8_t i;
	LCDGotoXY(x,y);
     40a:	64 2f       	mov	r22, r20
     40c:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
     410:	10 e0       	ldi	r17, 0x00	; 0
     412:	03 c0       	rjmp	.+6      	; 0x41a <CopyStringtoLCD+0x1a>
	for(i=0;(uint8_t)pgm_read_byte(&FlashLoc[i]);i++)
	{
		LCDsendChar((uint8_t)pgm_read_byte(&FlashLoc[i]));
     414:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
//CopyStringtoLCD(welcomeln1, 3, 1);	
void CopyStringtoLCD(const uint8_t *FlashLoc, uint8_t x, uint8_t y)
{
	uint8_t i;
	LCDGotoXY(x,y);
	for(i=0;(uint8_t)pgm_read_byte(&FlashLoc[i]);i++)
     418:	1f 5f       	subi	r17, 0xFF	; 255
     41a:	fe 01       	movw	r30, r28
     41c:	e1 0f       	add	r30, r17
     41e:	f1 1d       	adc	r31, r1
     420:	84 91       	lpm	r24, Z+
     422:	88 23       	and	r24, r24
     424:	b9 f7       	brne	.-18     	; 0x414 <CopyStringtoLCD+0x14>
	{
		LCDsendChar((uint8_t)pgm_read_byte(&FlashLoc[i]));
	}
}
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	1f 91       	pop	r17
     42c:	08 95       	ret

0000042e <LCDdefinechar>:
0b00000000,
0b00000000
};
LCDdefinechar(backslash,0);
*/
void LCDdefinechar(const uint8_t *pc,uint8_t char_code){
     42e:	ef 92       	push	r14
     430:	ff 92       	push	r15
     432:	0f 93       	push	r16
     434:	1f 93       	push	r17
     436:	cf 93       	push	r28
     438:	df 93       	push	r29
     43a:	7c 01       	movw	r14, r24
     43c:	16 2f       	mov	r17, r22
	uint8_t a, pcc;
	uint16_t i;
	a=(char_code<<3)|0x40;
     43e:	11 0f       	add	r17, r17
     440:	11 0f       	add	r17, r17
     442:	11 0f       	add	r17, r17
     444:	10 64       	ori	r17, 0x40	; 64
     446:	c0 e0       	ldi	r28, 0x00	; 0
     448:	d0 e0       	ldi	r29, 0x00	; 0
	for (i=0; i<8; i++){
		pcc=pgm_read_byte(&pc[i]);
     44a:	f7 01       	movw	r30, r14
     44c:	ec 0f       	add	r30, r28
     44e:	fd 1f       	adc	r31, r29
     450:	04 91       	lpm	r16, Z+
		LCDsendCommand(a++);
     452:	81 2f       	mov	r24, r17
     454:	8c 0f       	add	r24, r28
     456:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
		LCDsendChar(pcc);
     45a:	80 2f       	mov	r24, r16
     45c:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
*/
void LCDdefinechar(const uint8_t *pc,uint8_t char_code){
	uint8_t a, pcc;
	uint16_t i;
	a=(char_code<<3)|0x40;
	for (i=0; i<8; i++){
     460:	21 96       	adiw	r28, 0x01	; 1
     462:	c8 30       	cpi	r28, 0x08	; 8
     464:	d1 05       	cpc	r29, r1
     466:	89 f7       	brne	.-30     	; 0x44a <LCDdefinechar+0x1c>
		pcc=pgm_read_byte(&pc[i]);
		LCDsendCommand(a++);
		LCDsendChar(pcc);
		}
}
     468:	df 91       	pop	r29
     46a:	cf 91       	pop	r28
     46c:	1f 91       	pop	r17
     46e:	0f 91       	pop	r16
     470:	ff 90       	pop	r15
     472:	ef 90       	pop	r14
     474:	08 95       	ret

00000476 <LCDshiftLeft>:

void LCDshiftLeft(uint8_t n)	//Scrol n of characters Right
{
     476:	0f 93       	push	r16
     478:	1f 93       	push	r17
     47a:	08 2f       	mov	r16, r24
     47c:	10 e0       	ldi	r17, 0x00	; 0
     47e:	04 c0       	rjmp	.+8      	; 0x488 <LCDshiftLeft+0x12>
	for (uint8_t i=0;i<n;i++)
	{
		LCDsendCommand(0x1E);
     480:	8e e1       	ldi	r24, 0x1E	; 30
     482:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
		}
}

void LCDshiftLeft(uint8_t n)	//Scrol n of characters Right
{
	for (uint8_t i=0;i<n;i++)
     486:	1f 5f       	subi	r17, 0xFF	; 255
     488:	10 17       	cp	r17, r16
     48a:	d0 f3       	brcs	.-12     	; 0x480 <LCDshiftLeft+0xa>
	{
		LCDsendCommand(0x1E);
	}
}
     48c:	1f 91       	pop	r17
     48e:	0f 91       	pop	r16
     490:	08 95       	ret

00000492 <LCDshiftRight>:
void LCDshiftRight(uint8_t n)	//Scrol n of characters Left
{
     492:	0f 93       	push	r16
     494:	1f 93       	push	r17
     496:	08 2f       	mov	r16, r24
     498:	10 e0       	ldi	r17, 0x00	; 0
     49a:	04 c0       	rjmp	.+8      	; 0x4a4 <LCDshiftRight+0x12>
	for (uint8_t i=0;i<n;i++)
	{
		LCDsendCommand(0x18);
     49c:	88 e1       	ldi	r24, 0x18	; 24
     49e:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
		LCDsendCommand(0x1E);
	}
}
void LCDshiftRight(uint8_t n)	//Scrol n of characters Left
{
	for (uint8_t i=0;i<n;i++)
     4a2:	1f 5f       	subi	r17, 0xFF	; 255
     4a4:	10 17       	cp	r17, r16
     4a6:	d0 f3       	brcs	.-12     	; 0x49c <LCDshiftRight+0xa>
	{
		LCDsendCommand(0x18);
	}
}
     4a8:	1f 91       	pop	r17
     4aa:	0f 91       	pop	r16
     4ac:	08 95       	ret

000004ae <LCDcursorOn>:
void LCDcursorOn(void) //displays LCD cursor
{
	LCDsendCommand(0x0E);
     4ae:	8e e0       	ldi	r24, 0x0E	; 14
     4b0:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     4b4:	08 95       	ret

000004b6 <LCDcursorOnBlink>:
void LCDcursorOnBlink(void)	//displays LCD blinking cursor
{
	LCDsendCommand(0x0F);
     4b6:	8f e0       	ldi	r24, 0x0F	; 15
     4b8:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     4bc:	08 95       	ret

000004be <LCDcursorOFF>:
void LCDcursorOFF(void)	//turns OFF cursor
{
	LCDsendCommand(0x0C);
     4be:	8c e0       	ldi	r24, 0x0C	; 12
     4c0:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     4c4:	08 95       	ret

000004c6 <LCDblank>:
void LCDblank(void)		//blanks LCD
{
	LCDsendCommand(0x08);
     4c6:	88 e0       	ldi	r24, 0x08	; 8
     4c8:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     4cc:	08 95       	ret

000004ce <LCDvisible>:
void LCDvisible(void)		//Shows LCD
{
	LCDsendCommand(0x0C);
     4ce:	8c e0       	ldi	r24, 0x0C	; 12
     4d0:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
}
     4d4:	08 95       	ret

000004d6 <LCDcursorLeft>:
void LCDcursorLeft(uint8_t n)	//Moves cursor by n poisitions left
{
     4d6:	0f 93       	push	r16
     4d8:	1f 93       	push	r17
     4da:	08 2f       	mov	r16, r24
     4dc:	10 e0       	ldi	r17, 0x00	; 0
     4de:	04 c0       	rjmp	.+8      	; 0x4e8 <LCDcursorLeft+0x12>
	for (uint8_t i=0;i<n;i++)
	{
		LCDsendCommand(0x10);
     4e0:	80 e1       	ldi	r24, 0x10	; 16
     4e2:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
{
	LCDsendCommand(0x0C);
}
void LCDcursorLeft(uint8_t n)	//Moves cursor by n poisitions left
{
	for (uint8_t i=0;i<n;i++)
     4e6:	1f 5f       	subi	r17, 0xFF	; 255
     4e8:	10 17       	cp	r17, r16
     4ea:	d0 f3       	brcs	.-12     	; 0x4e0 <LCDcursorLeft+0xa>
	{
		LCDsendCommand(0x10);
	}
}
     4ec:	1f 91       	pop	r17
     4ee:	0f 91       	pop	r16
     4f0:	08 95       	ret

000004f2 <LCDcursorRight>:
void LCDcursorRight(uint8_t n)	//Moves cursor by n poisitions left
{
     4f2:	0f 93       	push	r16
     4f4:	1f 93       	push	r17
     4f6:	08 2f       	mov	r16, r24
     4f8:	10 e0       	ldi	r17, 0x00	; 0
     4fa:	04 c0       	rjmp	.+8      	; 0x504 <__stack+0x5>
	for (uint8_t i=0;i<n;i++)
	{
		LCDsendCommand(0x14);
     4fc:	84 e1       	ldi	r24, 0x14	; 20
     4fe:	0e 94 7f 01 	call	0x2fe	; 0x2fe <LCDsendCommand>
		LCDsendCommand(0x10);
	}
}
void LCDcursorRight(uint8_t n)	//Moves cursor by n poisitions left
{
	for (uint8_t i=0;i<n;i++)
     502:	1f 5f       	subi	r17, 0xFF	; 255
     504:	10 17       	cp	r17, r16
     506:	d0 f3       	brcs	.-12     	; 0x4fc <LCDcursorRight+0xa>
	{
		LCDsendCommand(0x14);
	}
}
     508:	1f 91       	pop	r17
     50a:	0f 91       	pop	r16
     50c:	08 95       	ret

0000050e <CHbit_nastav>:
  }
}
//----------------------------------------------------------------------
void CHbit_nastav(void)
{
  udaje.sek = read_ds1307(0);
     50e:	80 e0       	ldi	r24, 0x00	; 0
     510:	0e 94 45 01 	call	0x28a	; 0x28a <read_ds1307>
     514:	68 2f       	mov	r22, r24
     516:	80 93 33 04 	sts	0x0433, r24
  write_ds1307(0, (udaje.sek|0x80));
     51a:	60 68       	ori	r22, 0x80	; 128
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
}
     522:	08 95       	ret

00000524 <CHbit_nuluj>:
//----------------------------------------------------------------------
void CHbit_nuluj(void)
{
  udaje.sek = read_ds1307(0);
     524:	80 e0       	ldi	r24, 0x00	; 0
     526:	0e 94 45 01 	call	0x28a	; 0x28a <read_ds1307>
     52a:	68 2f       	mov	r22, r24
     52c:	80 93 33 04 	sts	0x0433, r24
  write_ds1307(0, (udaje.sek&0x7f));
     530:	6f 77       	andi	r22, 0x7F	; 127
     532:	80 e0       	ldi	r24, 0x00	; 0
     534:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
}
     538:	08 95       	ret

0000053a <cakaj>:
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
     53a:	21 e0       	ldi	r18, 0x01	; 1
     53c:	30 e0       	ldi	r19, 0x00	; 0
     53e:	02 c0       	rjmp	.+4      	; 0x544 <cakaj+0xa>
     540:	22 0f       	add	r18, r18
     542:	33 1f       	adc	r19, r19
     544:	8a 95       	dec	r24
     546:	e2 f7       	brpl	.-8      	; 0x540 <cakaj+0x6>
  while (bit_is_set(PINC, p)) ;
     548:	86 b1       	in	r24, 0x06	; 6
     54a:	90 e0       	ldi	r25, 0x00	; 0
     54c:	82 23       	and	r24, r18
     54e:	93 23       	and	r25, r19
     550:	89 2b       	or	r24, r25
     552:	d1 f7       	brne	.-12     	; 0x548 <cakaj+0xe>
}
     554:	08 95       	ret

00000556 <decToBcd>:
//----------------------------------------------------------------------
char decToBcd(char d)
{
     556:	28 2f       	mov	r18, r24
     558:	6a e0       	ldi	r22, 0x0A	; 10
     55a:	0e 94 8e 13 	call	0x271c	; 0x271c <__udivmodqi4>
     55e:	38 2f       	mov	r19, r24
     560:	32 95       	swap	r19
     562:	30 7f       	andi	r19, 0xF0	; 240
     564:	82 2f       	mov	r24, r18
     566:	0e 94 8e 13 	call	0x271c	; 0x271c <__udivmodqi4>
  return (((d/10)<<4) + (d%10));
}
     56a:	83 2f       	mov	r24, r19
     56c:	89 0f       	add	r24, r25
     56e:	08 95       	ret

00000570 <bcdToDec>:
//----------------------------------------------------------------------
char bcdToDec(char b)
{
     570:	28 2f       	mov	r18, r24
     572:	22 95       	swap	r18
     574:	2f 70       	andi	r18, 0x0F	; 15
     576:	9a e0       	ldi	r25, 0x0A	; 10
     578:	29 9f       	mul	r18, r25
     57a:	90 01       	movw	r18, r0
     57c:	11 24       	eor	r1, r1
     57e:	8f 70       	andi	r24, 0x0F	; 15
  return (((b>>4)*10) + ((b&0x0f)));
}
     580:	82 0f       	add	r24, r18
     582:	08 95       	ret

00000584 <zisti_den>:
//----------------------------------------------------------------------
void zisti_den(void)				//zisti den 
{
     584:	1f 93       	push	r17
     586:	cf 93       	push	r28
     588:	df 93       	push	r29
  char den, mesiac, rok, sum = 0;
									// POSTUP
  den = bcdToDec(udaje.den);		// vsetky hodnoty na dekadicke
     58a:	80 91 37 04 	lds	r24, 0x0437
  mesiac = bcdToDec(udaje.mes);
     58e:	90 91 38 04 	lds	r25, 0x0438
  return (((d/10)<<4) + (d%10));
}
//----------------------------------------------------------------------
char bcdToDec(char b)
{
  return (((b>>4)*10) + ((b&0x0f)));
     592:	29 2f       	mov	r18, r25
     594:	22 95       	swap	r18
     596:	2f 70       	andi	r18, 0x0F	; 15
     598:	5a e0       	ldi	r21, 0x0A	; 10
     59a:	25 9f       	mul	r18, r21
     59c:	90 01       	movw	r18, r0
     59e:	11 24       	eor	r1, r1
     5a0:	19 2f       	mov	r17, r25
     5a2:	1f 70       	andi	r17, 0x0F	; 15
     5a4:	12 0f       	add	r17, r18
{
  char den, mesiac, rok, sum = 0;
									// POSTUP
  den = bcdToDec(udaje.den);		// vsetky hodnoty na dekadicke
  mesiac = bcdToDec(udaje.mes);
  rok = bcdToDec(udaje.rok);
     5a6:	40 91 39 04 	lds	r20, 0x0439
  return (((d/10)<<4) + (d%10));
}
//----------------------------------------------------------------------
char bcdToDec(char b)
{
  return (((b>>4)*10) + ((b&0x0f)));
     5aa:	24 2f       	mov	r18, r20
     5ac:	22 95       	swap	r18
     5ae:	2f 70       	andi	r18, 0x0F	; 15
     5b0:	25 9f       	mul	r18, r21
     5b2:	90 01       	movw	r18, r0
     5b4:	11 24       	eor	r1, r1
     5b6:	4f 70       	andi	r20, 0x0F	; 15
     5b8:	42 0f       	add	r20, r18
  den = bcdToDec(udaje.den);		// vsetky hodnoty na dekadicke
  mesiac = bcdToDec(udaje.mes);
  rok = bcdToDec(udaje.rok);
  sum += (den % 7);
  sum += mon[mesiac-1];
  sum += ((rok + (rok / 4)) % 7);
     5ba:	c4 2f       	mov	r28, r20
     5bc:	d0 e0       	ldi	r29, 0x00	; 0
									// POSTUP
  den = bcdToDec(udaje.den);		// vsetky hodnoty na dekadicke
  mesiac = bcdToDec(udaje.mes);
  rok = bcdToDec(udaje.rok);
  sum += (den % 7);
  sum += mon[mesiac-1];
     5be:	28 2f       	mov	r18, r24
     5c0:	22 95       	swap	r18
     5c2:	2f 70       	andi	r18, 0x0F	; 15
     5c4:	25 9f       	mul	r18, r21
     5c6:	90 01       	movw	r18, r0
     5c8:	11 24       	eor	r1, r1
     5ca:	8f 70       	andi	r24, 0x0F	; 15
     5cc:	82 0f       	add	r24, r18
     5ce:	67 e0       	ldi	r22, 0x07	; 7
     5d0:	0e 94 8e 13 	call	0x271c	; 0x271c <__udivmodqi4>
     5d4:	29 2f       	mov	r18, r25
     5d6:	2a 5f       	subi	r18, 0xFA	; 250
  sum += ((rok + (rok / 4)) % 7);
     5d8:	e1 2f       	mov	r30, r17
     5da:	f0 e0       	ldi	r31, 0x00	; 0
     5dc:	ee 5d       	subi	r30, 0xDE	; 222
     5de:	fc 4f       	sbci	r31, 0xFC	; 252
     5e0:	80 81       	ld	r24, Z
     5e2:	28 0f       	add	r18, r24
  sum += STR;
     5e4:	46 95       	lsr	r20
     5e6:	46 95       	lsr	r20
     5e8:	ce 01       	movw	r24, r28
     5ea:	84 0f       	add	r24, r20
     5ec:	91 1d       	adc	r25, r1
     5ee:	67 e0       	ldi	r22, 0x07	; 7
     5f0:	70 e0       	ldi	r23, 0x00	; 0
     5f2:	0e 94 9a 13 	call	0x2734	; 0x2734 <__divmodhi4>
  if ((sum %= 7) == 0)
     5f6:	82 0f       	add	r24, r18
     5f8:	67 e0       	ldi	r22, 0x07	; 7
     5fa:	0e 94 8e 13 	call	0x271c	; 0x271c <__udivmodqi4>
     5fe:	99 23       	and	r25, r25
     600:	09 f4       	brne	.+2      	; 0x604 <zisti_den+0x80>
     602:	97 e0       	ldi	r25, 0x07	; 7
    sum = 7;
  if ((rok % 4) == 0) {
     604:	c3 70       	andi	r28, 0x03	; 3
     606:	d0 70       	andi	r29, 0x00	; 0
     608:	cd 2b       	or	r28, r29
     60a:	39 f4       	brne	.+14     	; 0x61a <zisti_den+0x96>
    if ((mesiac == 1) || (mesiac == 2))
     60c:	11 50       	subi	r17, 0x01	; 1
     60e:	12 30       	cpi	r17, 0x02	; 2
     610:	20 f4       	brcc	.+8      	; 0x61a <zisti_den+0x96>
      if ((sum += 6) > 7)
     612:	9a 5f       	subi	r25, 0xFA	; 250
     614:	98 30       	cpi	r25, 0x08	; 8
     616:	08 f0       	brcs	.+2      	; 0x61a <zisti_den+0x96>
	    sum -= 7;
     618:	97 50       	subi	r25, 0x07	; 7
  }
  udaje.mDen = sum;
     61a:	90 93 36 04 	sts	0x0436, r25
}
     61e:	df 91       	pop	r29
     620:	cf 91       	pop	r28
     622:	1f 91       	pop	r17
     624:	08 95       	ret

00000626 <nastav_ukoncit>:
}
//----------------------------------------------------------------------
char nastav_ukoncit(void)
{
  return 1;
}
     626:	81 e0       	ldi	r24, 0x01	; 1
     628:	08 95       	ret

0000062a <LCDcistiXY>:
//----------------------------------------------------------------------
void LCDcistiXY(char x, char y, char pct)
{
     62a:	0f 93       	push	r16
     62c:	1f 93       	push	r17
     62e:	04 2f       	mov	r16, r20
  LCDGotoXY(x, y);
     630:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
     634:	10 e0       	ldi	r17, 0x00	; 0
     636:	04 c0       	rjmp	.+8      	; 0x640 <LCDcistiXY+0x16>
  for (unsigned char i = 0; i < pct; i++)
    LCDsendChar(' ');
     638:	80 e2       	ldi	r24, 0x20	; 32
     63a:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
}
//----------------------------------------------------------------------
void LCDcistiXY(char x, char y, char pct)
{
  LCDGotoXY(x, y);
  for (unsigned char i = 0; i < pct; i++)
     63e:	1f 5f       	subi	r17, 0xFF	; 255
     640:	10 17       	cp	r17, r16
     642:	d0 f3       	brcs	.-12     	; 0x638 <LCDcistiXY+0xe>
    LCDsendChar(' ');
}
     644:	1f 91       	pop	r17
     646:	0f 91       	pop	r16
     648:	08 95       	ret

0000064a <LCDstringXY>:
//----------------------------------------------------------------------
void LCDstringXY(char X, char Y, char *str, char pct)
{
     64a:	ff 92       	push	r15
     64c:	0f 93       	push	r16
     64e:	1f 93       	push	r17
     650:	8a 01       	movw	r16, r20
     652:	f2 2e       	mov	r15, r18
  LCDGotoXY(X, Y);
     654:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
  LCDstring(str, pct);
     658:	c8 01       	movw	r24, r16
     65a:	6f 2d       	mov	r22, r15
     65c:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
}
     660:	1f 91       	pop	r17
     662:	0f 91       	pop	r16
     664:	ff 90       	pop	r15
     666:	08 95       	ret

00000668 <skenuj_tep>:
//----------------------------------------------------------------------

//----------------------------------------------------------------------
void skenuj_tep(void)		// funkcia pouzita len v casovaci
{
  if (udaje.teplota < 80) {
     668:	90 91 32 04 	lds	r25, 0x0432
     66c:	90 35       	cpi	r25, 0x50	; 80
     66e:	20 f5       	brcc	.+72     	; 0x6b8 <skenuj_tep+0x50>
    if (udaje.teplota <= mon_udaje.min_temp) {
     670:	80 91 2a 04 	lds	r24, 0x042A
     674:	89 17       	cp	r24, r25
     676:	70 f0       	brcs	.+28     	; 0x694 <skenuj_tep+0x2c>
	  mon_udaje.min_temp = udaje.teplota;
     678:	90 93 2a 04 	sts	0x042A, r25
	  mon_udaje.min_den = udaje.den;
     67c:	80 91 37 04 	lds	r24, 0x0437
     680:	80 93 2b 04 	sts	0x042B, r24
	  mon_udaje.min_mes = udaje.mes;
     684:	80 91 38 04 	lds	r24, 0x0438
     688:	80 93 2c 04 	sts	0x042C, r24
	  mon_udaje.min_rok = udaje.rok;
     68c:	80 91 39 04 	lds	r24, 0x0439
     690:	80 93 2d 04 	sts	0x042D, r24
	}
    if (udaje.teplota >= mon_udaje.max_temp) {
     694:	80 91 2e 04 	lds	r24, 0x042E
     698:	98 17       	cp	r25, r24
     69a:	70 f0       	brcs	.+28     	; 0x6b8 <skenuj_tep+0x50>
	  mon_udaje.max_temp = udaje.teplota;
     69c:	90 93 2e 04 	sts	0x042E, r25
      mon_udaje.max_den = udaje.den;
     6a0:	80 91 37 04 	lds	r24, 0x0437
     6a4:	80 93 2f 04 	sts	0x042F, r24
	  mon_udaje.max_mes = udaje.mes;
     6a8:	80 91 38 04 	lds	r24, 0x0438
     6ac:	80 93 30 04 	sts	0x0430, r24
	  mon_udaje.max_rok = udaje.rok;
     6b0:	80 91 39 04 	lds	r24, 0x0439
     6b4:	80 93 31 04 	sts	0x0431, r24
     6b8:	08 95       	ret

000006ba <USART_Transmit>:
    }
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
     6ba:	98 2f       	mov	r25, r24
   while (!(UCSR0A & (1<<UDRE0)));
     6bc:	80 91 c0 00 	lds	r24, 0x00C0
     6c0:	85 ff       	sbrs	r24, 5
     6c2:	fc cf       	rjmp	.-8      	; 0x6bc <USART_Transmit+0x2>
   UDR0=ch;
     6c4:	90 93 c6 00 	sts	0x00C6, r25

   return 0;
}
     6c8:	08 95       	ret

000006ca <USART_Receive>:
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     6ca:	80 91 c0 00 	lds	r24, 0x00C0
     6ce:	87 ff       	sbrs	r24, 7
     6d0:	fc cf       	rjmp	.-8      	; 0x6ca <USART_Receive>
   ch=UDR0;  
     6d2:	80 91 c6 00 	lds	r24, 0x00C6

   return ch;
}
     6d6:	08 95       	ret

000006d8 <USART_Init>:
//----------------------------------------------------------------------
/* 19200kbps 8N1 */
void USART_Init(void)
{
  UCSR0A = 0x00;
     6d8:	10 92 c0 00 	sts	0x00C0, r1
  UCSR0B = 0x98;
     6dc:	88 e9       	ldi	r24, 0x98	; 152
     6de:	80 93 c1 00 	sts	0x00C1, r24
  UCSR0C = 0x06;
     6e2:	86 e0       	ldi	r24, 0x06	; 6
     6e4:	80 93 c2 00 	sts	0x00C2, r24
  UBRR0H = 0x00;
     6e8:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = 0x19;
     6ec:	89 e1       	ldi	r24, 0x19	; 25
     6ee:	80 93 c4 00 	sts	0x00C4, r24
}
     6f2:	08 95       	ret

000006f4 <USART_Flush>:
//----------------------------------------------------------------------
void USART_Flush(void)
{
     6f4:	02 c0       	rjmp	.+4      	; 0x6fa <USART_Flush+0x6>
  unsigned char dummy;

  while ( UCSR0A & (1<<RXC0) ) 
    dummy = UDR0;
     6f6:	80 91 c6 00 	lds	r24, 0x00C6
//----------------------------------------------------------------------
void USART_Flush(void)
{
  unsigned char dummy;

  while ( UCSR0A & (1<<RXC0) ) 
     6fa:	80 91 c0 00 	lds	r24, 0x00C0
     6fe:	87 fd       	sbrc	r24, 7
     700:	fa cf       	rjmp	.-12     	; 0x6f6 <USART_Flush+0x2>
    dummy = UDR0;
}
     702:	08 95       	ret

00000704 <nastav_casovac0>:
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void nastav_casovac0(char tcra, char tcrb, char tnt, char s)
{
  TCCR0A=tcra;
     704:	84 bd       	out	0x24, r24	; 36
  TCCR0B=tcrb;
     706:	65 bd       	out	0x25, r22	; 37
  TCNT0=tnt;
     708:	46 bd       	out	0x26, r20	; 38
  TIMSK0=s;
     70a:	20 93 6e 00 	sts	0x006E, r18
}
     70e:	08 95       	ret

00000710 <nastav_casovac2>:
//----------------------------------------------------------------------
void nastav_casovac2(char tcra, char tcrb, char tnt, char s)
{
  TCCR2A=tcra;
     710:	80 93 b0 00 	sts	0x00B0, r24
  TCCR2B=tcrb;
     714:	60 93 b1 00 	sts	0x00B1, r22
  TCNT2=tnt;
     718:	40 93 b2 00 	sts	0x00B2, r20
  TIMSK2=s;  
     71c:	20 93 70 00 	sts	0x0070, r18
}
     720:	08 95       	ret

00000722 <skenuj_alarm>:
//----------------------------------------------------------------------
void skenuj_alarm(void)
{
  if (alarm.al_den == 10)
     722:	90 91 26 04 	lds	r25, 0x0426
     726:	9a 30       	cpi	r25, 0x0A	; 10
     728:	b1 f0       	breq	.+44     	; 0x756 <skenuj_alarm+0x34>
    goto pokr_al;
  if ((alarm.al_den <= 7) && (alarm.al_den == udaje.mDen))		// jeden den
     72a:	98 30       	cpi	r25, 0x08	; 8
     72c:	28 f4       	brcc	.+10     	; 0x738 <skenuj_alarm+0x16>
     72e:	80 91 36 04 	lds	r24, 0x0436
     732:	98 17       	cp	r25, r24
     734:	41 f4       	brne	.+16     	; 0x746 <skenuj_alarm+0x24>
     736:	0f c0       	rjmp	.+30     	; 0x756 <skenuj_alarm+0x34>
    goto pokr_al;
  if ((alarm.al_den == 8) && (udaje.mDen <= 5))				// Po - Pia
     738:	98 30       	cpi	r25, 0x08	; 8
     73a:	29 f4       	brne	.+10     	; 0x746 <skenuj_alarm+0x24>
     73c:	80 91 36 04 	lds	r24, 0x0436
     740:	86 30       	cpi	r24, 0x06	; 6
     742:	48 f0       	brcs	.+18     	; 0x756 <skenuj_alarm+0x34>
     744:	08 95       	ret
    goto pokr_al;
  if ((alarm.al_den == 9) && (udaje.mDen >= 6))				// So - Ne
     746:	99 30       	cpi	r25, 0x09	; 9
     748:	09 f0       	breq	.+2      	; 0x74c <skenuj_alarm+0x2a>
     74a:	5d c0       	rjmp	.+186    	; 0x806 <skenuj_alarm+0xe4>
     74c:	80 91 36 04 	lds	r24, 0x0436
     750:	86 30       	cpi	r24, 0x06	; 6
     752:	08 f4       	brcc	.+2      	; 0x756 <skenuj_alarm+0x34>
     754:	58 c0       	rjmp	.+176    	; 0x806 <skenuj_alarm+0xe4>
    goto pokr_al;
  
  return;
  pokr_al:
  if ((alarm.clock == 1) && (alarm.temp == 0)) {
     756:	80 91 24 04 	lds	r24, 0x0424
     75a:	81 30       	cpi	r24, 0x01	; 1
     75c:	e9 f4       	brne	.+58     	; 0x798 <skenuj_alarm+0x76>
     75e:	80 91 23 04 	lds	r24, 0x0423
     762:	88 23       	and	r24, r24
     764:	71 f5       	brne	.+92     	; 0x7c2 <skenuj_alarm+0xa0>
    if ((alarm.al_hod == udaje.hod) && (alarm.al_min == udaje.min) && (alarm.al_sek == udaje.sek)) {
     766:	90 91 1f 04 	lds	r25, 0x041F
     76a:	80 91 35 04 	lds	r24, 0x0435
     76e:	98 17       	cp	r25, r24
     770:	41 f5       	brne	.+80     	; 0x7c2 <skenuj_alarm+0xa0>
     772:	90 91 20 04 	lds	r25, 0x0420
     776:	80 91 34 04 	lds	r24, 0x0434
     77a:	98 17       	cp	r25, r24
     77c:	11 f5       	brne	.+68     	; 0x7c2 <skenuj_alarm+0xa0>
     77e:	90 91 21 04 	lds	r25, 0x0421
     782:	80 91 33 04 	lds	r24, 0x0433
     786:	98 17       	cp	r25, r24
     788:	e1 f4       	brne	.+56     	; 0x7c2 <skenuj_alarm+0xa0>
	  PORTC |= 8;
     78a:	43 9a       	sbi	0x08, 3	; 8
	  al_res.pipa = 1;
     78c:	80 91 29 04 	lds	r24, 0x0429
     790:	81 60       	ori	r24, 0x01	; 1
     792:	80 93 29 04 	sts	0x0429, r24
     796:	15 c0       	rjmp	.+42     	; 0x7c2 <skenuj_alarm+0xa0>
	}
  }
  if ((alarm.clock == 0) && (alarm.temp == 1)) {
     798:	88 23       	and	r24, r24
     79a:	a9 f5       	brne	.+106    	; 0x806 <skenuj_alarm+0xe4>
     79c:	80 91 23 04 	lds	r24, 0x0423
     7a0:	81 30       	cpi	r24, 0x01	; 1
     7a2:	89 f5       	brne	.+98     	; 0x806 <skenuj_alarm+0xe4>
    if (alarm.al_temp == udaje.teplota) {
     7a4:	90 91 22 04 	lds	r25, 0x0422
     7a8:	80 91 32 04 	lds	r24, 0x0432
     7ac:	98 17       	cp	r25, r24
     7ae:	59 f5       	brne	.+86     	; 0x806 <skenuj_alarm+0xe4>
	  PORTC |= 8;
     7b0:	43 9a       	sbi	0x08, 3	; 8
	  alarm.temp = 0;
     7b2:	10 92 23 04 	sts	0x0423, r1
	  al_res.pipa = 1;
     7b6:	80 91 29 04 	lds	r24, 0x0429
     7ba:	81 60       	ori	r24, 0x01	; 1
     7bc:	80 93 29 04 	sts	0x0429, r24
     7c0:	08 95       	ret
	}
  }
  if ((alarm.clock == 1) && (alarm.temp == 1)) {
     7c2:	80 91 23 04 	lds	r24, 0x0423
     7c6:	81 30       	cpi	r24, 0x01	; 1
     7c8:	f1 f4       	brne	.+60     	; 0x806 <skenuj_alarm+0xe4>
    if (((alarm.al_hod == udaje.hod) && (alarm.al_min == udaje.min) && (alarm.al_sek == udaje.sek)) && (alarm.al_temp == udaje.teplota)) {
     7ca:	90 91 1f 04 	lds	r25, 0x041F
     7ce:	80 91 35 04 	lds	r24, 0x0435
     7d2:	98 17       	cp	r25, r24
     7d4:	c1 f4       	brne	.+48     	; 0x806 <skenuj_alarm+0xe4>
     7d6:	90 91 20 04 	lds	r25, 0x0420
     7da:	80 91 34 04 	lds	r24, 0x0434
     7de:	98 17       	cp	r25, r24
     7e0:	91 f4       	brne	.+36     	; 0x806 <skenuj_alarm+0xe4>
     7e2:	90 91 21 04 	lds	r25, 0x0421
     7e6:	80 91 33 04 	lds	r24, 0x0433
     7ea:	98 17       	cp	r25, r24
     7ec:	61 f4       	brne	.+24     	; 0x806 <skenuj_alarm+0xe4>
     7ee:	90 91 22 04 	lds	r25, 0x0422
     7f2:	80 91 32 04 	lds	r24, 0x0432
     7f6:	98 17       	cp	r25, r24
     7f8:	31 f4       	brne	.+12     	; 0x806 <skenuj_alarm+0xe4>
	  PORTC |= 8;
     7fa:	43 9a       	sbi	0x08, 3	; 8
	  al_res.pipa = 1;
     7fc:	80 91 29 04 	lds	r24, 0x0429
     800:	81 60       	ori	r24, 0x01	; 1
     802:	80 93 29 04 	sts	0x0429, r24
     806:	08 95       	ret

00000808 <citaj_hodn>:
	}
  }
}
//----------------------------------------------------------------------
void citaj_hodn(void)
{
     808:	df 92       	push	r13
     80a:	ef 92       	push	r14
     80c:	ff 92       	push	r15
     80e:	0f 93       	push	r16
     810:	1f 93       	push	r17
     812:	cf 93       	push	r28
     814:	df 93       	push	r29
  if ((stav & 1) != 1) {
     816:	80 91 f8 03 	lds	r24, 0x03F8
     81a:	80 fd       	sbrc	r24, 0
     81c:	2b c0       	rjmp	.+86     	; 0x874 <citaj_hodn+0x6c>
#include <util/delay.h>

char one_reset(void)
{
  char r;
  asm("cli");
     81e:	f8 94       	cli
  DDR |= DQ;
     820:	57 9a       	sbi	0x0a, 7	; 10
  PORT &= ~DQ;
     822:	5f 98       	cbi	0x0b, 7	; 11
     824:	88 ee       	ldi	r24, 0xE8	; 232
     826:	93 e0       	ldi	r25, 0x03	; 3
     828:	01 97       	sbiw	r24, 0x01	; 1
     82a:	f1 f7       	brne	.-4      	; 0x828 <citaj_hodn+0x20>
  _delay_us(500);
  DDR &= ~DQ;
     82c:	57 98       	cbi	0x0a, 7	; 10
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     82e:	8a e6       	ldi	r24, 0x6A	; 106
     830:	8a 95       	dec	r24
     832:	f1 f7       	brne	.-4      	; 0x830 <citaj_hodn+0x28>
  _delay_us(40);
  r = (DDR & DQ) ? 0 : 1;
     834:	8a b1       	in	r24, 0x0a	; 10
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     836:	80 ee       	ldi	r24, 0xE0	; 224
     838:	91 e0       	ldi	r25, 0x01	; 1
     83a:	01 97       	sbiw	r24, 0x01	; 1
     83c:	f1 f7       	brne	.-4      	; 0x83a <citaj_hodn+0x32>
  _delay_us(240);
  asm("sei");
     83e:	78 94       	sei
    one_reset();
    send_convert();
     840:	0e 94 a0 00 	call	0x140	; 0x140 <send_convert>
     844:	c0 e0       	ldi	r28, 0x00	; 0
     846:	d0 e0       	ldi	r29, 0x00	; 0
    for (unsigned char i = 0; i < 7; i++)		//nacitam vsetky udaje do struktury - v priebehu cakania
      p_udaje[i] = read_ds1307(i);
     848:	00 91 6d 02 	lds	r16, 0x026D
     84c:	10 91 6e 02 	lds	r17, 0x026E
     850:	0c 0f       	add	r16, r28
     852:	1d 1f       	adc	r17, r29
     854:	8c 2f       	mov	r24, r28
     856:	0e 94 45 01 	call	0x28a	; 0x28a <read_ds1307>
     85a:	f8 01       	movw	r30, r16
     85c:	80 83       	st	Z, r24
     85e:	21 96       	adiw	r28, 0x01	; 1
void citaj_hodn(void)
{
  if ((stav & 1) != 1) {
    one_reset();
    send_convert();
    for (unsigned char i = 0; i < 7; i++)		//nacitam vsetky udaje do struktury - v priebehu cakania
     860:	c7 30       	cpi	r28, 0x07	; 7
     862:	d1 05       	cpc	r29, r1
     864:	89 f7       	brne	.-30     	; 0x848 <citaj_hodn+0x40>
      p_udaje[i] = read_ds1307(i);
    zisti_den();								//zistim den v tyzdni - v priebehu cakania (konvertovanie)
     866:	0e 94 c2 02 	call	0x584	; 0x584 <zisti_den>
	stav |= 1;						// nastavim stav na 1 pre dokoncenie 1. casti
     86a:	80 91 f8 03 	lds	r24, 0x03F8
     86e:	81 60       	ori	r24, 0x01	; 1
     870:	80 93 f8 03 	sts	0x03F8, r24
  }
  if (((stav & 1) == 1) && ((timer_ref % 50) == 0)) {
     874:	80 91 f8 03 	lds	r24, 0x03F8
     878:	80 ff       	sbrs	r24, 0
     87a:	41 c0       	rjmp	.+130    	; 0x8fe <citaj_hodn+0xf6>
     87c:	80 91 f5 03 	lds	r24, 0x03F5
     880:	62 e3       	ldi	r22, 0x32	; 50
     882:	0e 94 8e 13 	call	0x271c	; 0x271c <__udivmodqi4>
     886:	99 23       	and	r25, r25
     888:	09 f0       	breq	.+2      	; 0x88c <citaj_hodn+0x84>
     88a:	39 c0       	rjmp	.+114    	; 0x8fe <citaj_hodn+0xf6>
#include <util/delay.h>

char one_reset(void)
{
  char r;
  asm("cli");
     88c:	f8 94       	cli
  DDR |= DQ;
     88e:	57 9a       	sbi	0x0a, 7	; 10
  PORT &= ~DQ;
     890:	5f 98       	cbi	0x0b, 7	; 11
     892:	78 ee       	ldi	r23, 0xE8	; 232
     894:	e7 2e       	mov	r14, r23
     896:	73 e0       	ldi	r23, 0x03	; 3
     898:	f7 2e       	mov	r15, r23
     89a:	c7 01       	movw	r24, r14
     89c:	01 97       	sbiw	r24, 0x01	; 1
     89e:	f1 f7       	brne	.-4      	; 0x89c <citaj_hodn+0x94>
  _delay_us(500);
  DDR &= ~DQ;
     8a0:	57 98       	cbi	0x0a, 7	; 10
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     8a2:	6a e6       	ldi	r22, 0x6A	; 106
     8a4:	d6 2e       	mov	r13, r22
     8a6:	8d 2d       	mov	r24, r13
     8a8:	8a 95       	dec	r24
     8aa:	f1 f7       	brne	.-4      	; 0x8a8 <citaj_hodn+0xa0>
  _delay_us(40);
  r = (DDR & DQ) ? 0 : 1;
     8ac:	8a b1       	in	r24, 0x0a	; 10
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     8ae:	00 ee       	ldi	r16, 0xE0	; 224
     8b0:	11 e0       	ldi	r17, 0x01	; 1
     8b2:	c8 01       	movw	r24, r16
     8b4:	01 97       	sbiw	r24, 0x01	; 1
     8b6:	f1 f7       	brne	.-4      	; 0x8b4 <citaj_hodn+0xac>
  _delay_us(240);
  asm("sei");
     8b8:	78 94       	sei
    one_reset();
    send_getTemp();
     8ba:	0e 94 a7 00 	call	0x14e	; 0x14e <send_getTemp>
    udaje.teplota = one_read_byte();
     8be:	0e 94 69 00 	call	0xd2	; 0xd2 <one_read_byte>
     8c2:	80 93 32 04 	sts	0x0432, r24
    udaje.temp_flag = one_read_byte();			/// DOKONCIT NASTAV5, Fcia PRE DNI ALARMU
     8c6:	0e 94 69 00 	call	0xd2	; 0xd2 <one_read_byte>
     8ca:	80 93 3a 04 	sts	0x043A, r24
#include <util/delay.h>

char one_reset(void)
{
  char r;
  asm("cli");
     8ce:	f8 94       	cli
  DDR |= DQ;
     8d0:	57 9a       	sbi	0x0a, 7	; 10
  PORT &= ~DQ;
     8d2:	5f 98       	cbi	0x0b, 7	; 11
     8d4:	c7 01       	movw	r24, r14
     8d6:	01 97       	sbiw	r24, 0x01	; 1
     8d8:	f1 f7       	brne	.-4      	; 0x8d6 <citaj_hodn+0xce>
  _delay_us(500);
  DDR &= ~DQ;
     8da:	57 98       	cbi	0x0a, 7	; 10
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     8dc:	da 94       	dec	r13
     8de:	f1 f7       	brne	.-4      	; 0x8dc <citaj_hodn+0xd4>
  _delay_us(40);
  r = (DDR & DQ) ? 0 : 1;
     8e0:	8a b1       	in	r24, 0x0a	; 10
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     8e2:	c8 01       	movw	r24, r16
     8e4:	01 97       	sbiw	r24, 0x01	; 1
     8e6:	f1 f7       	brne	.-4      	; 0x8e4 <citaj_hodn+0xdc>
  _delay_us(240);
  asm("sei");
     8e8:	78 94       	sei
    one_reset();
    //if ((udaje.temp_flag = 0))
    udaje.teplota >>= 1;
     8ea:	80 91 32 04 	lds	r24, 0x0432
     8ee:	86 95       	lsr	r24
     8f0:	80 93 32 04 	sts	0x0432, r24
    //else 
      //udaje.teplota = -(((~udaje.teplota)/2)+1);
    stav &= ~1;
     8f4:	80 91 f8 03 	lds	r24, 0x03F8
     8f8:	8e 7f       	andi	r24, 0xFE	; 254
     8fa:	80 93 f8 03 	sts	0x03F8, r24
  }
}
     8fe:	df 91       	pop	r29
     900:	cf 91       	pop	r28
     902:	1f 91       	pop	r17
     904:	0f 91       	pop	r16
     906:	ff 90       	pop	r15
     908:	ef 90       	pop	r14
     90a:	df 90       	pop	r13
     90c:	08 95       	ret

0000090e <__vector_16>:
char *tst_com(void);
//void vykonaj(void);

//----------------------------------------------------------------------
ISR(TIMER0_OVF_vect) 		// Prerusenie kazdych 8,16ms
{
     90e:	1f 92       	push	r1
     910:	0f 92       	push	r0
     912:	0f b6       	in	r0, 0x3f	; 63
     914:	0f 92       	push	r0
     916:	11 24       	eor	r1, r1
     918:	2f 93       	push	r18
     91a:	3f 93       	push	r19
     91c:	4f 93       	push	r20
     91e:	5f 93       	push	r21
     920:	6f 93       	push	r22
     922:	7f 93       	push	r23
     924:	8f 93       	push	r24
     926:	9f 93       	push	r25
     928:	af 93       	push	r26
     92a:	bf 93       	push	r27
     92c:	ef 93       	push	r30
     92e:	ff 93       	push	r31
  TIMSK0 = 0;
     930:	10 92 6e 00 	sts	0x006E, r1

  timer_ref++;
     934:	80 91 f5 03 	lds	r24, 0x03F5
     938:	8f 5f       	subi	r24, 0xFF	; 255
     93a:	80 93 f5 03 	sts	0x03F5, r24
  if ((udaje.mon_temp) == 1 && ((stav & 2) != 2))  // skenuj monitorovanu teplotu
     93e:	80 91 3b 04 	lds	r24, 0x043B
     942:	81 30       	cpi	r24, 0x01	; 1
     944:	31 f4       	brne	.+12     	; 0x952 <__vector_16+0x44>
     946:	80 91 f8 03 	lds	r24, 0x03F8
     94a:	81 fd       	sbrc	r24, 1
     94c:	02 c0       	rjmp	.+4      	; 0x952 <__vector_16+0x44>
    skenuj_tep(); 
     94e:	0e 94 34 03 	call	0x668	; 0x668 <skenuj_tep>
  if ((alarm.al_flag == 1) && ((stav & 2) != 2)) {	// skenuj alarm - nesnimaj pocas nastavovania
     952:	80 91 25 04 	lds	r24, 0x0425
     956:	81 30       	cpi	r24, 0x01	; 1
     958:	31 f4       	brne	.+12     	; 0x966 <__vector_16+0x58>
     95a:	80 91 f8 03 	lds	r24, 0x03F8
     95e:	81 fd       	sbrc	r24, 1
     960:	02 c0       	rjmp	.+4      	; 0x966 <__vector_16+0x58>
    skenuj_alarm();
     962:	0e 94 91 03 	call	0x722	; 0x722 <skenuj_alarm>
  }	
  citaj_hodn();
     966:	0e 94 04 04 	call	0x808	; 0x808 <citaj_hodn>
  if ((timer_ref % 32) == 0) {
     96a:	80 91 f5 03 	lds	r24, 0x03F5
     96e:	90 e0       	ldi	r25, 0x00	; 0
     970:	8f 71       	andi	r24, 0x1F	; 31
     972:	90 70       	andi	r25, 0x00	; 0
     974:	89 2b       	or	r24, r25
     976:	31 f5       	brne	.+76     	; 0x9c4 <__vector_16+0xb6>
    if (cursor == 0)
     978:	80 91 28 04 	lds	r24, 0x0428
     97c:	88 23       	and	r24, r24
     97e:	11 f4       	brne	.+4      	; 0x984 <__vector_16+0x76>
	  LCDcursorOFF();
     980:	0e 94 5f 02 	call	0x4be	; 0x4be <LCDcursorOFF>
	if (al_res.pipa == 1) {
     984:	80 91 29 04 	lds	r24, 0x0429
     988:	80 ff       	sbrs	r24, 0
     98a:	19 c0       	rjmp	.+50     	; 0x9be <__vector_16+0xb0>
	  if (bit_is_set(PINC, 5)) {
     98c:	35 9b       	sbis	0x06, 5	; 6
     98e:	04 c0       	rjmp	.+8      	; 0x998 <__vector_16+0x8a>
	    PORTC &= ~8;
     990:	43 98       	cbi	0x08, 3	; 8
		al_res.pipa = 0;
     992:	8e 7f       	andi	r24, 0xFE	; 254
     994:	80 93 29 04 	sts	0x0429, r24
	  }
	  if (++al_res.ref == 32) {
     998:	80 91 29 04 	lds	r24, 0x0429
     99c:	98 2f       	mov	r25, r24
     99e:	96 95       	lsr	r25
     9a0:	96 95       	lsr	r25
     9a2:	9f 5f       	subi	r25, 0xFF	; 255
     9a4:	9f 73       	andi	r25, 0x3F	; 63
     9a6:	29 2f       	mov	r18, r25
     9a8:	22 0f       	add	r18, r18
     9aa:	22 0f       	add	r18, r18
     9ac:	83 70       	andi	r24, 0x03	; 3
     9ae:	82 2b       	or	r24, r18
     9b0:	80 93 29 04 	sts	0x0429, r24
     9b4:	90 32       	cpi	r25, 0x20	; 32
     9b6:	31 f4       	brne	.+12     	; 0x9c4 <__vector_16+0xb6>
	    PORTC &= ~8;
     9b8:	43 98       	cbi	0x08, 3	; 8
		al_res.pipa = 0;
     9ba:	8e 7f       	andi	r24, 0xFE	; 254
     9bc:	01 c0       	rjmp	.+2      	; 0x9c0 <__vector_16+0xb2>
	  }
	} else al_res.ref = 0;
     9be:	83 70       	andi	r24, 0x03	; 3
     9c0:	80 93 29 04 	sts	0x0429, r24
  }
  /* --- SAS PRACOVNHO REMU, frekvencia vstupu --- */
  if (prac_stav == 1) {
     9c4:	80 91 f4 03 	lds	r24, 0x03F4
     9c8:	81 30       	cpi	r24, 0x01	; 1
     9ca:	b9 f4       	brne	.+46     	; 0x9fa <__vector_16+0xec>
  /* SPECIFICK KRITRIA PRE DAN LOHU */
    alarm.al_flag = 0;
     9cc:	10 92 25 04 	sts	0x0425, r1
	alarm.clock = 0;
     9d0:	10 92 24 04 	sts	0x0424, r1
	alarm.temp = 0;
     9d4:	10 92 23 04 	sts	0x0423, r1
  /*------- KONIEC --------*/
  }
  if ((prac_stav == 1) && (freq_nastavena != 0)) {
     9d8:	80 91 f3 03 	lds	r24, 0x03F3
     9dc:	88 23       	and	r24, r24
     9de:	69 f0       	breq	.+26     	; 0x9fa <__vector_16+0xec>
    if (freq == 1)
     9e0:	80 91 f2 03 	lds	r24, 0x03F2
     9e4:	81 30       	cpi	r24, 0x01	; 1
     9e6:	11 f4       	brne	.+4      	; 0x9ec <__vector_16+0xde>
	  PORTC |= 8;
     9e8:	43 9a       	sbi	0x08, 3	; 8
     9ea:	08 c0       	rjmp	.+16     	; 0x9fc <__vector_16+0xee>
	if (freq == 2)
     9ec:	82 30       	cpi	r24, 0x02	; 2
     9ee:	31 f4       	brne	.+12     	; 0x9fc <__vector_16+0xee>
	  PORTC ^= 8;
     9f0:	88 b1       	in	r24, 0x08	; 8
     9f2:	98 e0       	ldi	r25, 0x08	; 8
     9f4:	89 27       	eor	r24, r25
     9f6:	88 b9       	out	0x08, r24	; 8
     9f8:	01 c0       	rjmp	.+2      	; 0x9fc <__vector_16+0xee>
  } else PORTC &= ~8;
     9fa:	43 98       	cbi	0x08, 3	; 8
  /*------- KONIEC --------*/
  TIMSK0 = 1;
     9fc:	81 e0       	ldi	r24, 0x01	; 1
     9fe:	80 93 6e 00 	sts	0x006E, r24
}
     a02:	ff 91       	pop	r31
     a04:	ef 91       	pop	r30
     a06:	bf 91       	pop	r27
     a08:	af 91       	pop	r26
     a0a:	9f 91       	pop	r25
     a0c:	8f 91       	pop	r24
     a0e:	7f 91       	pop	r23
     a10:	6f 91       	pop	r22
     a12:	5f 91       	pop	r21
     a14:	4f 91       	pop	r20
     a16:	3f 91       	pop	r19
     a18:	2f 91       	pop	r18
     a1a:	0f 90       	pop	r0
     a1c:	0f be       	out	0x3f, r0	; 63
     a1e:	0f 90       	pop	r0
     a20:	1f 90       	pop	r1
     a22:	18 95       	reti

00000a24 <delete_eeprom>:
    stav &= ~1;
  }
}
//----------------------------------------------------------------------
void delete_eeprom(void)
{
     a24:	80 e0       	ldi	r24, 0x00	; 0
     a26:	90 e0       	ldi	r25, 0x00	; 0
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     a28:	24 e0       	ldi	r18, 0x04	; 4
     a2a:	30 e0       	ldi	r19, 0x00	; 0
#endif
    EEDR = __value;
     a2c:	4f ef       	ldi	r20, 0xFF	; 255
  int e;

  for (e = 0; e < 8; e++) {
    if (e != 4) {
     a2e:	84 30       	cpi	r24, 0x04	; 4
     a30:	91 05       	cpc	r25, r1
     a32:	49 f0       	breq	.+18     	; 0xa46 <delete_eeprom+0x22>
	  EEPROM_CAKAJ;
     a34:	f9 99       	sbic	0x1f, 1	; 31
     a36:	fe cf       	rjmp	.-4      	; 0xa34 <delete_eeprom+0x10>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     a38:	f9 99       	sbic	0x1f, 1	; 31
     a3a:	fe cf       	rjmp	.-4      	; 0xa38 <delete_eeprom+0x14>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     a3c:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     a3e:	92 bd       	out	0x22, r25	; 34
     a40:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
     a42:	40 bd       	out	0x20, r20	; 32
     a44:	08 c0       	rjmp	.+16     	; 0xa56 <delete_eeprom+0x32>
	  eeprom_write_byte(e,255);
	}
	else {
	  EEPROM_CAKAJ;
     a46:	f9 99       	sbic	0x1f, 1	; 31
     a48:	fe cf       	rjmp	.-4      	; 0xa46 <delete_eeprom+0x22>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     a4a:	f9 99       	sbic	0x1f, 1	; 31
     a4c:	fe cf       	rjmp	.-4      	; 0xa4a <delete_eeprom+0x26>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     a4e:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     a50:	32 bd       	out	0x22, r19	; 34
     a52:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
     a54:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
     a56:	0f b6       	in	r0, 0x3f	; 63
     a58:	f8 94       	cli
     a5a:	fa 9a       	sbi	0x1f, 2	; 31
     a5c:	f9 9a       	sbi	0x1f, 1	; 31
     a5e:	0f be       	out	0x3f, r0	; 63
//----------------------------------------------------------------------
void delete_eeprom(void)
{
  int e;

  for (e = 0; e < 8; e++) {
     a60:	01 96       	adiw	r24, 0x01	; 1
     a62:	88 30       	cpi	r24, 0x08	; 8
     a64:	91 05       	cpc	r25, r1
     a66:	19 f7       	brne	.-58     	; 0xa2e <delete_eeprom+0xa>
	  EEPROM_CAKAJ;
	  eeprom_write_byte(4,0);
	}
  }

}
     a68:	08 95       	ret

00000a6a <__vector_18>:
  
  TIMSK2 = 1;
}
//----------------------------------------------------------------------
ISR(USART_RX_vect)
{
     a6a:	1f 92       	push	r1
     a6c:	0f 92       	push	r0
     a6e:	0f b6       	in	r0, 0x3f	; 63
     a70:	0f 92       	push	r0
     a72:	11 24       	eor	r1, r1
     a74:	2f 93       	push	r18
     a76:	3f 93       	push	r19
     a78:	4f 93       	push	r20
     a7a:	5f 93       	push	r21
     a7c:	6f 93       	push	r22
     a7e:	7f 93       	push	r23
     a80:	8f 93       	push	r24
     a82:	9f 93       	push	r25
     a84:	af 93       	push	r26
     a86:	bf 93       	push	r27
     a88:	ef 93       	push	r30
     a8a:	ff 93       	push	r31
  char byte, i, j, check;
  
  UCSR0B &= ~0x80;
     a8c:	80 91 c1 00 	lds	r24, 0x00C1
     a90:	8f 77       	andi	r24, 0x7F	; 127
     a92:	80 93 c1 00 	sts	0x00C1, r24
  TIMSK0 = 0;
     a96:	10 92 6e 00 	sts	0x006E, r1
  byte = UDR0; 
     a9a:	90 91 c6 00 	lds	r25, 0x00C6


//		OBSLUHA PRE PROGRAM
  if (byte == 104)			//otazka 104
     a9e:	98 36       	cpi	r25, 0x68	; 104
     aa0:	41 f4       	brne	.+16     	; 0xab2 <__vector_18+0x48>
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     aa2:	80 91 c0 00 	lds	r24, 0x00C0
     aa6:	85 ff       	sbrs	r24, 5
     aa8:	fc cf       	rjmp	.-8      	; 0xaa2 <__vector_18+0x38>
   UDR0=ch;
     aaa:	84 e6       	ldi	r24, 0x64	; 100
     aac:	80 93 c6 00 	sts	0x00C6, r24
     ab0:	e2 c0       	rjmp	.+452    	; 0xc76 <__vector_18+0x20c>
    USART_Transmit(100);	//odpoved 100
  if (byte == 90)			//poziadavka cas 115
     ab2:	9a 35       	cpi	r25, 0x5A	; 90
     ab4:	21 f4       	brne	.+8      	; 0xabe <__vector_18+0x54>
    com.PC = 1;
     ab6:	80 91 1e 04 	lds	r24, 0x041E
     aba:	81 60       	ori	r24, 0x01	; 1
     abc:	05 c0       	rjmp	.+10     	; 0xac8 <__vector_18+0x5e>
  if (byte == 106)
     abe:	9a 36       	cpi	r25, 0x6A	; 106
     ac0:	31 f4       	brne	.+12     	; 0xace <__vector_18+0x64>
    com.PC = 0;
     ac2:	80 91 1e 04 	lds	r24, 0x041E
     ac6:	8e 7f       	andi	r24, 0xFE	; 254
     ac8:	80 93 1e 04 	sts	0x041E, r24
     acc:	87 c1       	rjmp	.+782    	; 0xddc <__vector_18+0x372>
  if (byte == 115) {
     ace:	93 37       	cpi	r25, 0x73	; 115
     ad0:	09 f0       	breq	.+2      	; 0xad4 <__vector_18+0x6a>
     ad2:	d1 c0       	rjmp	.+418    	; 0xc76 <__vector_18+0x20c>
    for (i = 0; i < 9; i++) {
	  USART_Transmit(p_udaje[i]);
     ad4:	40 91 6d 02 	lds	r20, 0x026D
     ad8:	50 91 6e 02 	lds	r21, 0x026E
     adc:	20 e0       	ldi	r18, 0x00	; 0
     ade:	30 e0       	ldi	r19, 0x00	; 0
     ae0:	fa 01       	movw	r30, r20
     ae2:	e2 0f       	add	r30, r18
     ae4:	f3 1f       	adc	r31, r19
     ae6:	e0 81       	ld	r30, Z
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     ae8:	80 91 c0 00 	lds	r24, 0x00C0
     aec:	85 ff       	sbrs	r24, 5
     aee:	fc cf       	rjmp	.-8      	; 0xae8 <__vector_18+0x7e>
   UDR0=ch;
     af0:	e0 93 c6 00 	sts	0x00C6, r30
     af4:	2f 5f       	subi	r18, 0xFF	; 255
     af6:	3f 4f       	sbci	r19, 0xFF	; 255
  if (byte == 90)			//poziadavka cas 115
    com.PC = 1;
  if (byte == 106)
    com.PC = 0;
  if (byte == 115) {
    for (i = 0; i < 9; i++) {
     af8:	29 30       	cpi	r18, 0x09	; 9
     afa:	31 05       	cpc	r19, r1
     afc:	89 f7       	brne	.-30     	; 0xae0 <__vector_18+0x76>
	  USART_Transmit(p_udaje[i]);
	}
    for (i = 0; i < 8; i++) {
	  USART_Transmit(p_mon[i]);
     afe:	40 91 69 02 	lds	r20, 0x0269
     b02:	50 91 6a 02 	lds	r21, 0x026A
     b06:	20 e0       	ldi	r18, 0x00	; 0
     b08:	30 e0       	ldi	r19, 0x00	; 0
     b0a:	fa 01       	movw	r30, r20
     b0c:	e2 0f       	add	r30, r18
     b0e:	f3 1f       	adc	r31, r19
     b10:	e0 81       	ld	r30, Z
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     b12:	80 91 c0 00 	lds	r24, 0x00C0
     b16:	85 ff       	sbrs	r24, 5
     b18:	fc cf       	rjmp	.-8      	; 0xb12 <__vector_18+0xa8>
   UDR0=ch;
     b1a:	e0 93 c6 00 	sts	0x00C6, r30
     b1e:	2f 5f       	subi	r18, 0xFF	; 255
     b20:	3f 4f       	sbci	r19, 0xFF	; 255
    com.PC = 0;
  if (byte == 115) {
    for (i = 0; i < 9; i++) {
	  USART_Transmit(p_udaje[i]);
	}
    for (i = 0; i < 8; i++) {
     b22:	28 30       	cpi	r18, 0x08	; 8
     b24:	31 05       	cpc	r19, r1
     b26:	89 f7       	brne	.-30     	; 0xb0a <__vector_18+0xa0>
	  USART_Transmit(p_mon[i]);
	}
    for (i = 0; i < 8; i++) {
	  USART_Transmit(p_alarm[i]);
     b28:	40 91 6b 02 	lds	r20, 0x026B
     b2c:	50 91 6c 02 	lds	r21, 0x026C
     b30:	20 e0       	ldi	r18, 0x00	; 0
     b32:	30 e0       	ldi	r19, 0x00	; 0
     b34:	fa 01       	movw	r30, r20
     b36:	e2 0f       	add	r30, r18
     b38:	f3 1f       	adc	r31, r19
     b3a:	e0 81       	ld	r30, Z
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     b3c:	80 91 c0 00 	lds	r24, 0x00C0
     b40:	85 ff       	sbrs	r24, 5
     b42:	fc cf       	rjmp	.-8      	; 0xb3c <__vector_18+0xd2>
   UDR0=ch;
     b44:	e0 93 c6 00 	sts	0x00C6, r30
     b48:	2f 5f       	subi	r18, 0xFF	; 255
     b4a:	3f 4f       	sbci	r19, 0xFF	; 255
	  USART_Transmit(p_udaje[i]);
	}
    for (i = 0; i < 8; i++) {
	  USART_Transmit(p_mon[i]);
	}
    for (i = 0; i < 8; i++) {
     b4c:	28 30       	cpi	r18, 0x08	; 8
     b4e:	31 05       	cpc	r19, r1
     b50:	89 f7       	brne	.-30     	; 0xb34 <__vector_18+0xca>
	  USART_Transmit(p_alarm[i]);
	}
	USART_Transmit((al_res.pipa | al_res.pipalo | al_res.ref));
     b52:	80 91 29 04 	lds	r24, 0x0429
     b56:	38 2f       	mov	r19, r24
     b58:	31 70       	andi	r19, 0x01	; 1
     b5a:	98 2f       	mov	r25, r24
     b5c:	96 95       	lsr	r25
     b5e:	91 70       	andi	r25, 0x01	; 1
     b60:	28 2f       	mov	r18, r24
     b62:	26 95       	lsr	r18
     b64:	26 95       	lsr	r18
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     b66:	80 91 c0 00 	lds	r24, 0x00C0
     b6a:	85 ff       	sbrs	r24, 5
     b6c:	fc cf       	rjmp	.-8      	; 0xb66 <__vector_18+0xfc>
     b6e:	93 2b       	or	r25, r19
     b70:	92 2b       	or	r25, r18
   UDR0=ch;
     b72:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(timer_ref);
     b76:	90 91 f5 03 	lds	r25, 0x03F5
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     b7a:	80 91 c0 00 	lds	r24, 0x00C0
     b7e:	85 ff       	sbrs	r24, 5
     b80:	fc cf       	rjmp	.-8      	; 0xb7a <__vector_18+0x110>
   UDR0=ch;
     b82:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(stav);
     b86:	90 91 f8 03 	lds	r25, 0x03F8
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     b8a:	80 91 c0 00 	lds	r24, 0x00C0
     b8e:	85 ff       	sbrs	r24, 5
     b90:	fc cf       	rjmp	.-8      	; 0xb8a <__vector_18+0x120>
   UDR0=ch;
     b92:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(cursor);
     b96:	90 91 28 04 	lds	r25, 0x0428
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     b9a:	80 91 c0 00 	lds	r24, 0x00C0
     b9e:	85 ff       	sbrs	r24, 5
     ba0:	fc cf       	rjmp	.-8      	; 0xb9a <__vector_18+0x130>
   UDR0=ch;
     ba2:	90 93 c6 00 	sts	0x00C6, r25
     ba6:	4b e0       	ldi	r20, 0x0B	; 11
     ba8:	54 e0       	ldi	r21, 0x04	; 4
     baa:	20 e0       	ldi	r18, 0x00	; 0
     bac:	30 e0       	ldi	r19, 0x00	; 0
     bae:	13 c0       	rjmp	.+38     	; 0xbd6 <__vector_18+0x16c>
	for (i = 0; i < 2; i++) {
	  for (j = 0; j < 16; j++) {
	    USART_Transmit(lcd_dis[i][j]);
     bb0:	90 81       	ld	r25, Z
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     bb2:	80 91 c0 00 	lds	r24, 0x00C0
     bb6:	85 ff       	sbrs	r24, 5
     bb8:	fc cf       	rjmp	.-8      	; 0xbb2 <__vector_18+0x148>
   UDR0=ch;
     bba:	90 93 c6 00 	sts	0x00C6, r25
     bbe:	31 96       	adiw	r30, 0x01	; 1
	USART_Transmit((al_res.pipa | al_res.pipalo | al_res.ref));
	USART_Transmit(timer_ref);
	USART_Transmit(stav);
	USART_Transmit(cursor);
	for (i = 0; i < 2; i++) {
	  for (j = 0; j < 16; j++) {
     bc0:	e4 17       	cp	r30, r20
     bc2:	f5 07       	cpc	r31, r21
     bc4:	a9 f7       	brne	.-22     	; 0xbb0 <__vector_18+0x146>
     bc6:	2f 5f       	subi	r18, 0xFF	; 255
     bc8:	3f 4f       	sbci	r19, 0xFF	; 255
     bca:	af 01       	movw	r20, r30
     bcc:	4f 5e       	subi	r20, 0xEF	; 239
     bce:	5f 4f       	sbci	r21, 0xFF	; 255
	}
	USART_Transmit((al_res.pipa | al_res.pipalo | al_res.ref));
	USART_Transmit(timer_ref);
	USART_Transmit(stav);
	USART_Transmit(cursor);
	for (i = 0; i < 2; i++) {
     bd0:	22 30       	cpi	r18, 0x02	; 2
     bd2:	31 05       	cpc	r19, r1
     bd4:	59 f0       	breq	.+22     	; 0xbec <__vector_18+0x182>
     bd6:	f9 01       	movw	r30, r18
     bd8:	a4 e0       	ldi	r26, 0x04	; 4
     bda:	ee 0f       	add	r30, r30
     bdc:	ff 1f       	adc	r31, r31
     bde:	aa 95       	dec	r26
     be0:	e1 f7       	brne	.-8      	; 0xbda <__vector_18+0x170>
     be2:	e2 0f       	add	r30, r18
     be4:	f3 1f       	adc	r31, r19
     be6:	e5 50       	subi	r30, 0x05	; 5
     be8:	fc 4f       	sbci	r31, 0xFC	; 252
     bea:	e2 cf       	rjmp	.-60     	; 0xbb0 <__vector_18+0x146>
	  for (j = 0; j < 16; j++) {
	    USART_Transmit(lcd_dis[i][j]);
	  }
	} 
	USART_Transmit(udaje.teplota);
     bec:	90 91 32 04 	lds	r25, 0x0432
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     bf0:	80 91 c0 00 	lds	r24, 0x00C0
     bf4:	85 ff       	sbrs	r24, 5
     bf6:	fc cf       	rjmp	.-8      	; 0xbf0 <__vector_18+0x186>
   UDR0=ch;
     bf8:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(timer2_ref);
     bfc:	90 91 f6 03 	lds	r25, 0x03F6
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     c00:	80 91 c0 00 	lds	r24, 0x00C0
     c04:	85 ff       	sbrs	r24, 5
     c06:	fc cf       	rjmp	.-8      	; 0xc00 <__vector_18+0x196>
   UDR0=ch;
     c08:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(PORTD);
     c0c:	9b b1       	in	r25, 0x0b	; 11
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     c0e:	80 91 c0 00 	lds	r24, 0x00C0
     c12:	85 ff       	sbrs	r24, 5
     c14:	fc cf       	rjmp	.-8      	; 0xc0e <__vector_18+0x1a4>
   UDR0=ch;
     c16:	90 93 c6 00 	sts	0x00C6, r25
     c1a:	20 e0       	ldi	r18, 0x00	; 0
     c1c:	30 e0       	ldi	r19, 0x00	; 0
	for (i = 0; i < 8; i++) {
      EEPROM_CAKAJ;
     c1e:	f9 99       	sbic	0x1f, 1	; 31
     c20:	fe cf       	rjmp	.-4      	; 0xc1e <__vector_18+0x1b4>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     c22:	f9 99       	sbic	0x1f, 1	; 31
     c24:	fe cf       	rjmp	.-4      	; 0xc22 <__vector_18+0x1b8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     c26:	32 bd       	out	0x22, r19	; 34
     c28:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     c2a:	f8 9a       	sbi	0x1f, 0	; 31
     c2c:	90 b5       	in	r25, 0x20	; 32
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     c2e:	80 91 c0 00 	lds	r24, 0x00C0
     c32:	85 ff       	sbrs	r24, 5
     c34:	fc cf       	rjmp	.-8      	; 0xc2e <__vector_18+0x1c4>
   UDR0=ch;
     c36:	90 93 c6 00 	sts	0x00C6, r25
     c3a:	2f 5f       	subi	r18, 0xFF	; 255
     c3c:	3f 4f       	sbci	r19, 0xFF	; 255
	  }
	} 
	USART_Transmit(udaje.teplota);
	USART_Transmit(timer2_ref);
	USART_Transmit(PORTD);
	for (i = 0; i < 8; i++) {
     c3e:	28 30       	cpi	r18, 0x08	; 8
     c40:	31 05       	cpc	r19, r1
     c42:	69 f7       	brne	.-38     	; 0xc1e <__vector_18+0x1b4>
      EEPROM_CAKAJ;
      USART_Transmit(eeprom_read_byte(i));
    }
	USART_Transmit(prac_stav);
     c44:	90 91 f4 03 	lds	r25, 0x03F4
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     c48:	80 91 c0 00 	lds	r24, 0x00C0
     c4c:	85 ff       	sbrs	r24, 5
     c4e:	fc cf       	rjmp	.-8      	; 0xc48 <__vector_18+0x1de>
   UDR0=ch;
     c50:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(freq);
     c54:	90 91 f2 03 	lds	r25, 0x03F2
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     c58:	80 91 c0 00 	lds	r24, 0x00C0
     c5c:	85 ff       	sbrs	r24, 5
     c5e:	fc cf       	rjmp	.-8      	; 0xc58 <__vector_18+0x1ee>
   UDR0=ch;
     c60:	90 93 c6 00 	sts	0x00C6, r25
	USART_Transmit(freq_nastavena);
     c64:	90 91 f3 03 	lds	r25, 0x03F3
  }
}
//----------------------------------------------------------------------
void USART_Transmit(char ch)
{
   while (!(UCSR0A & (1<<UDRE0)));
     c68:	80 91 c0 00 	lds	r24, 0x00C0
     c6c:	85 ff       	sbrs	r24, 5
     c6e:	fc cf       	rjmp	.-8      	; 0xc68 <__vector_18+0x1fe>
   UDR0=ch;
     c70:	90 93 c6 00 	sts	0x00C6, r25
     c74:	b3 c0       	rjmp	.+358    	; 0xddc <__vector_18+0x372>
  }
  if (byte == 116) {
     c76:	94 37       	cpi	r25, 0x74	; 116
     c78:	69 f5       	brne	.+90     	; 0xcd4 <__vector_18+0x26a>
     c7a:	80 ed       	ldi	r24, 0xD0	; 208
     c7c:	97 e0       	ldi	r25, 0x07	; 7
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	f1 f7       	brne	.-4      	; 0xc7e <__vector_18+0x214>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     c82:	80 91 c0 00 	lds	r24, 0x00C0
     c86:	87 ff       	sbrs	r24, 7
     c88:	fc cf       	rjmp	.-8      	; 0xc82 <__vector_18+0x218>
   ch=UDR0;  
     c8a:	60 91 c6 00 	lds	r22, 0x00C6
    _delay_ms(1);
    if ((check = USART_Receive()) <= 0x59)
     c8e:	6a 35       	cpi	r22, 0x5A	; 90
     c90:	18 f4       	brcc	.+6      	; 0xc98 <__vector_18+0x22e>
      write_ds1307(0, check);
     c92:	80 e0       	ldi	r24, 0x00	; 0
     c94:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
     c98:	80 ed       	ldi	r24, 0xD0	; 208
     c9a:	97 e0       	ldi	r25, 0x07	; 7
     c9c:	01 97       	sbiw	r24, 0x01	; 1
     c9e:	f1 f7       	brne	.-4      	; 0xc9c <__vector_18+0x232>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     ca0:	80 91 c0 00 	lds	r24, 0x00C0
     ca4:	87 ff       	sbrs	r24, 7
     ca6:	fc cf       	rjmp	.-8      	; 0xca0 <__vector_18+0x236>
   ch=UDR0;  
     ca8:	60 91 c6 00 	lds	r22, 0x00C6
	_delay_ms(1);
	if ((check = USART_Receive()) <= 0x59)  
     cac:	6a 35       	cpi	r22, 0x5A	; 90
     cae:	18 f4       	brcc	.+6      	; 0xcb6 <__vector_18+0x24c>
	  write_ds1307(1, check);
     cb0:	81 e0       	ldi	r24, 0x01	; 1
     cb2:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
     cb6:	80 ed       	ldi	r24, 0xD0	; 208
     cb8:	97 e0       	ldi	r25, 0x07	; 7
     cba:	01 97       	sbiw	r24, 0x01	; 1
     cbc:	f1 f7       	brne	.-4      	; 0xcba <__vector_18+0x250>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     cbe:	80 91 c0 00 	lds	r24, 0x00C0
     cc2:	87 ff       	sbrs	r24, 7
     cc4:	fc cf       	rjmp	.-8      	; 0xcbe <__vector_18+0x254>
   ch=UDR0;  
     cc6:	60 91 c6 00 	lds	r22, 0x00C6
	_delay_ms(1);
	if ((check = USART_Receive()) <= 0x23)
     cca:	64 32       	cpi	r22, 0x24	; 36
     ccc:	08 f0       	brcs	.+2      	; 0xcd0 <__vector_18+0x266>
     cce:	61 c0       	rjmp	.+194    	; 0xd92 <__vector_18+0x328>
	  write_ds1307(2, check);
     cd0:	82 e0       	ldi	r24, 0x02	; 2
     cd2:	2d c0       	rjmp	.+90     	; 0xd2e <__vector_18+0x2c4>
	_delay_ms(1);
  }
  if (byte == 117) {
     cd4:	95 37       	cpi	r25, 0x75	; 117
     cd6:	71 f5       	brne	.+92     	; 0xd34 <__vector_18+0x2ca>
     cd8:	80 ed       	ldi	r24, 0xD0	; 208
     cda:	97 e0       	ldi	r25, 0x07	; 7
     cdc:	01 97       	sbiw	r24, 0x01	; 1
     cde:	f1 f7       	brne	.-4      	; 0xcdc <__vector_18+0x272>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     ce0:	80 91 c0 00 	lds	r24, 0x00C0
     ce4:	87 ff       	sbrs	r24, 7
     ce6:	fc cf       	rjmp	.-8      	; 0xce0 <__vector_18+0x276>
   ch=UDR0;  
     ce8:	60 91 c6 00 	lds	r22, 0x00C6
    _delay_ms(1);
    if ((check = USART_Receive()) <= 0x99)
     cec:	6a 39       	cpi	r22, 0x9A	; 154
     cee:	18 f4       	brcc	.+6      	; 0xcf6 <__vector_18+0x28c>
      write_ds1307(4, check);
     cf0:	84 e0       	ldi	r24, 0x04	; 4
     cf2:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
     cf6:	80 ed       	ldi	r24, 0xD0	; 208
     cf8:	97 e0       	ldi	r25, 0x07	; 7
     cfa:	01 97       	sbiw	r24, 0x01	; 1
     cfc:	f1 f7       	brne	.-4      	; 0xcfa <__vector_18+0x290>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     cfe:	80 91 c0 00 	lds	r24, 0x00C0
     d02:	87 ff       	sbrs	r24, 7
     d04:	fc cf       	rjmp	.-8      	; 0xcfe <__vector_18+0x294>
   ch=UDR0;  
     d06:	60 91 c6 00 	lds	r22, 0x00C6
	_delay_ms(1);
	if ((check = USART_Receive()) <= 0x12)
     d0a:	63 31       	cpi	r22, 0x13	; 19
     d0c:	18 f4       	brcc	.+6      	; 0xd14 <__vector_18+0x2aa>
	  write_ds1307(5, check);
     d0e:	85 e0       	ldi	r24, 0x05	; 5
     d10:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
     d14:	80 ed       	ldi	r24, 0xD0	; 208
     d16:	97 e0       	ldi	r25, 0x07	; 7
     d18:	01 97       	sbiw	r24, 0x01	; 1
     d1a:	f1 f7       	brne	.-4      	; 0xd18 <__vector_18+0x2ae>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     d1c:	80 91 c0 00 	lds	r24, 0x00C0
     d20:	87 ff       	sbrs	r24, 7
     d22:	fc cf       	rjmp	.-8      	; 0xd1c <__vector_18+0x2b2>
   ch=UDR0;  
     d24:	60 91 c6 00 	lds	r22, 0x00C6
	_delay_ms(1);
	if ((check = USART_Receive()) <= 0x31)
     d28:	62 33       	cpi	r22, 0x32	; 50
     d2a:	98 f5       	brcc	.+102    	; 0xd92 <__vector_18+0x328>
	  write_ds1307(6, check);
     d2c:	86 e0       	ldi	r24, 0x06	; 6
     d2e:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
     d32:	2f c0       	rjmp	.+94     	; 0xd92 <__vector_18+0x328>
	_delay_ms(1);
  }
  if (byte == 118) {
     d34:	96 37       	cpi	r25, 0x76	; 118
     d36:	91 f5       	brne	.+100    	; 0xd9c <__vector_18+0x332>
     d38:	20 e0       	ldi	r18, 0x00	; 0
     d3a:	30 e0       	ldi	r19, 0x00	; 0
     d3c:	40 ed       	ldi	r20, 0xD0	; 208
     d3e:	57 e0       	ldi	r21, 0x07	; 7
     d40:	ca 01       	movw	r24, r20
     d42:	01 97       	sbiw	r24, 0x01	; 1
     d44:	f1 f7       	brne	.-4      	; 0xd42 <__vector_18+0x2d8>
    for (i = 0; i < 7; i++) {
	  _delay_ms(1);
	  p_alarm[i] = USART_Receive();
     d46:	e0 91 6b 02 	lds	r30, 0x026B
     d4a:	f0 91 6c 02 	lds	r31, 0x026C
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     d4e:	80 91 c0 00 	lds	r24, 0x00C0
     d52:	87 ff       	sbrs	r24, 7
     d54:	fc cf       	rjmp	.-8      	; 0xd4e <__vector_18+0x2e4>
   ch=UDR0;  
     d56:	80 91 c6 00 	lds	r24, 0x00C6
     d5a:	e2 0f       	add	r30, r18
     d5c:	f3 1f       	adc	r31, r19
     d5e:	80 83       	st	Z, r24
     d60:	2f 5f       	subi	r18, 0xFF	; 255
     d62:	3f 4f       	sbci	r19, 0xFF	; 255
	if ((check = USART_Receive()) <= 0x31)
	  write_ds1307(6, check);
	_delay_ms(1);
  }
  if (byte == 118) {
    for (i = 0; i < 7; i++) {
     d64:	27 30       	cpi	r18, 0x07	; 7
     d66:	31 05       	cpc	r19, r1
     d68:	59 f7       	brne	.-42     	; 0xd40 <__vector_18+0x2d6>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     d6a:	80 91 c0 00 	lds	r24, 0x00C0
     d6e:	87 ff       	sbrs	r24, 7
     d70:	fc cf       	rjmp	.-8      	; 0xd6a <__vector_18+0x300>
   ch=UDR0;  
     d72:	80 91 c6 00 	lds	r24, 0x00C6
	  _delay_ms(1);
	  p_alarm[i] = USART_Receive();
	}
	udaje.mon_temp = USART_Receive();
     d76:	80 93 3b 04 	sts	0x043B, r24
     d7a:	80 ed       	ldi	r24, 0xD0	; 208
     d7c:	97 e0       	ldi	r25, 0x07	; 7
     d7e:	01 97       	sbiw	r24, 0x01	; 1
     d80:	f1 f7       	brne	.-4      	; 0xd7e <__vector_18+0x314>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     d82:	80 91 c0 00 	lds	r24, 0x00C0
     d86:	87 ff       	sbrs	r24, 7
     d88:	fc cf       	rjmp	.-8      	; 0xd82 <__vector_18+0x318>
   ch=UDR0;  
     d8a:	80 91 c6 00 	lds	r24, 0x00C6
	_delay_ms(1);
	alarm.al_den = USART_Receive();
     d8e:	80 93 26 04 	sts	0x0426, r24
     d92:	80 ed       	ldi	r24, 0xD0	; 208
     d94:	97 e0       	ldi	r25, 0x07	; 7
     d96:	01 97       	sbiw	r24, 0x01	; 1
     d98:	f1 f7       	brne	.-4      	; 0xd96 <__vector_18+0x32c>
     d9a:	20 c0       	rjmp	.+64     	; 0xddc <__vector_18+0x372>
	_delay_ms(1);
  }	
  if (byte == 120) {
     d9c:	98 37       	cpi	r25, 0x78	; 120
     d9e:	19 f4       	brne	.+6      	; 0xda6 <__vector_18+0x33c>
    delete_eeprom();
     da0:	0e 94 12 05 	call	0xa24	; 0xa24 <delete_eeprom>
     da4:	1b c0       	rjmp	.+54     	; 0xddc <__vector_18+0x372>
  }
  // --- PRACOVN AS ---
  if (byte == 121) {	/* POIADAVKA PRE PRACOVN STAV */
     da6:	99 37       	cpi	r25, 0x79	; 121
     da8:	39 f4       	brne	.+14     	; 0xdb8 <__vector_18+0x34e>
    prac_stav ^= 1;
     daa:	80 91 f4 03 	lds	r24, 0x03F4
     dae:	91 e0       	ldi	r25, 0x01	; 1
     db0:	89 27       	eor	r24, r25
     db2:	80 93 f4 03 	sts	0x03F4, r24
     db6:	12 c0       	rjmp	.+36     	; 0xddc <__vector_18+0x372>
  }
  if (byte == 95) {
     db8:	9f 35       	cpi	r25, 0x5F	; 95
     dba:	81 f4       	brne	.+32     	; 0xddc <__vector_18+0x372>
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     dbc:	80 91 c0 00 	lds	r24, 0x00C0
     dc0:	87 ff       	sbrs	r24, 7
     dc2:	fc cf       	rjmp	.-8      	; 0xdbc <__vector_18+0x352>
   ch=UDR0;  
     dc4:	80 91 c6 00 	lds	r24, 0x00C6
  /* PRJEM POTREBNCH DAJOV PRE DAN PRCU */  
    freq = USART_Receive();
     dc8:	80 93 f2 03 	sts	0x03F2, r24
//----------------------------------------------------------------------
char USART_Receive(void)
{
   unsigned char ch;

   while (!(UCSR0A & (1<<RXC0)));
     dcc:	80 91 c0 00 	lds	r24, 0x00C0
     dd0:	87 ff       	sbrs	r24, 7
     dd2:	fc cf       	rjmp	.-8      	; 0xdcc <__vector_18+0x362>
   ch=UDR0;  
     dd4:	80 91 c6 00 	lds	r24, 0x00C6
	freq_nastavena = USART_Receive();
     dd8:	80 93 f3 03 	sts	0x03F3, r24
  }
  // --- KONIEC ---
  UCSR0B |= 0x80; 
     ddc:	80 91 c1 00 	lds	r24, 0x00C1
     de0:	80 68       	ori	r24, 0x80	; 128
     de2:	80 93 c1 00 	sts	0x00C1, r24
  TIMSK0 = 1;
     de6:	81 e0       	ldi	r24, 0x01	; 1
     de8:	80 93 6e 00 	sts	0x006E, r24
}
     dec:	ff 91       	pop	r31
     dee:	ef 91       	pop	r30
     df0:	bf 91       	pop	r27
     df2:	af 91       	pop	r26
     df4:	9f 91       	pop	r25
     df6:	8f 91       	pop	r24
     df8:	7f 91       	pop	r23
     dfa:	6f 91       	pop	r22
     dfc:	5f 91       	pop	r21
     dfe:	4f 91       	pop	r20
     e00:	3f 91       	pop	r19
     e02:	2f 91       	pop	r18
     e04:	0f 90       	pop	r0
     e06:	0f be       	out	0x3f, r0	; 63
     e08:	0f 90       	pop	r0
     e0a:	1f 90       	pop	r1
     e0c:	18 95       	reti

00000e0e <tst_monudaje>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
     e0e:	f9 99       	sbic	0x1f, 1	; 31
     e10:	fe cf       	rjmp	.-4      	; 0xe0e <tst_monudaje>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     e12:	84 e0       	ldi	r24, 0x04	; 4
     e14:	90 e0       	ldi	r25, 0x00	; 0
     e16:	92 bd       	out	0x22, r25	; 34
     e18:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     e1a:	f8 9a       	sbi	0x1f, 0	; 31
     e1c:	80 b5       	in	r24, 0x20	; 32

}
//----------------------------------------------------------------------
char *tst_monudaje(void)
{
  if (eeprom_read_byte(4) > 0x70) {
     e1e:	81 37       	cpi	r24, 0x71	; 113
     e20:	18 f4       	brcc	.+6      	; 0xe28 <tst_monudaje+0x1a>
     e22:	20 e0       	ldi	r18, 0x00	; 0
     e24:	30 e0       	ldi	r19, 0x00	; 0
     e26:	13 c0       	rjmp	.+38     	; 0xe4e <tst_monudaje+0x40>
    EEPROM_CAKAJ;
     e28:	f9 99       	sbic	0x1f, 1	; 31
     e2a:	fe cf       	rjmp	.-4      	; 0xe28 <tst_monudaje+0x1a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     e2c:	f9 99       	sbic	0x1f, 1	; 31
     e2e:	fe cf       	rjmp	.-4      	; 0xe2c <tst_monudaje+0x1e>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     e30:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     e32:	84 e0       	ldi	r24, 0x04	; 4
     e34:	90 e0       	ldi	r25, 0x00	; 0
     e36:	92 bd       	out	0x22, r25	; 34
     e38:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
     e3a:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
     e3c:	0f b6       	in	r0, 0x3f	; 63
     e3e:	f8 94       	cli
     e40:	fa 9a       	sbi	0x1f, 2	; 31
     e42:	f9 9a       	sbi	0x1f, 1	; 31
     e44:	0f be       	out	0x3f, r0	; 63
	eeprom_write_byte(4,0);
	mon_udaje.max_temp = 0;
     e46:	10 92 2e 04 	sts	0x042E, r1
     e4a:	20 e0       	ldi	r18, 0x00	; 0
     e4c:	31 e0       	ldi	r19, 0x01	; 1
	return var(mon_udaje.max_temp);
  }
  return 0;
}
     e4e:	c9 01       	movw	r24, r18
     e50:	08 95       	ret

00000e52 <tst_alarm>:
//----------------------------------------------------------------------
char *tst_alarm(void)
{
  if (alarm.temp > 1) {
     e52:	80 91 23 04 	lds	r24, 0x0423
     e56:	82 30       	cpi	r24, 0x02	; 2
     e58:	10 f0       	brcs	.+4      	; 0xe5e <tst_alarm+0xc>
    alarm.temp = 0;
     e5a:	10 92 23 04 	sts	0x0423, r1
  }
  if (alarm.clock > 1) {
     e5e:	80 91 24 04 	lds	r24, 0x0424
     e62:	82 30       	cpi	r24, 0x02	; 2
     e64:	10 f0       	brcs	.+4      	; 0xe6a <tst_alarm+0x18>
    alarm.clock = 0;
     e66:	10 92 24 04 	sts	0x0424, r1
  }
  if (alarm.al_flag > 1) {
     e6a:	80 91 25 04 	lds	r24, 0x0425
     e6e:	82 30       	cpi	r24, 0x02	; 2
     e70:	10 f0       	brcs	.+4      	; 0xe76 <tst_alarm+0x24>
    alarm.al_flag = 0;
     e72:	10 92 25 04 	sts	0x0425, r1
  }
  if (alarm.al_den > 10) {
     e76:	80 91 26 04 	lds	r24, 0x0426
     e7a:	8b 30       	cpi	r24, 0x0B	; 11
     e7c:	18 f0       	brcs	.+6      	; 0xe84 <tst_alarm+0x32>
    alarm.al_den = 1;
     e7e:	81 e0       	ldi	r24, 0x01	; 1
     e80:	80 93 26 04 	sts	0x0426, r24
  }
  return 0;
}
     e84:	80 e0       	ldi	r24, 0x00	; 0
     e86:	90 e0       	ldi	r25, 0x00	; 0
     e88:	08 95       	ret

00000e8a <tst_alres>:
{
  if (al_res.pipa > 1) {
    al_res.pipa = 0;
  }
  return 0;
}
     e8a:	80 e0       	ldi	r24, 0x00	; 0
     e8c:	90 e0       	ldi	r25, 0x00	; 0
     e8e:	08 95       	ret

00000e90 <tst_com>:
//----------------------------------------------------------------------
char *tst_com(void)
{
  return 0;
}
     e90:	80 e0       	ldi	r24, 0x00	; 0
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	08 95       	ret

00000e96 <__vector_9>:
  /*------- KONIEC --------*/
  TIMSK0 = 1;
}
//----------------------------------------------------------------------
ISR(TIMER2_OVF_vect) 		// Prerusenie kazdych 32,64 ms
{
     e96:	1f 92       	push	r1
     e98:	0f 92       	push	r0
     e9a:	0f b6       	in	r0, 0x3f	; 63
     e9c:	0f 92       	push	r0
     e9e:	11 24       	eor	r1, r1
     ea0:	2f 93       	push	r18
     ea2:	3f 93       	push	r19
     ea4:	4f 93       	push	r20
     ea6:	5f 93       	push	r21
     ea8:	6f 93       	push	r22
     eaa:	7f 93       	push	r23
     eac:	8f 93       	push	r24
     eae:	9f 93       	push	r25
     eb0:	af 93       	push	r26
     eb2:	bf 93       	push	r27
     eb4:	cf 93       	push	r28
     eb6:	df 93       	push	r29
     eb8:	ef 93       	push	r30
     eba:	ff 93       	push	r31
  //unsigned char vypis[40];
  unsigned char *check1;
  TIMSK2 = 0;
     ebc:	10 92 70 00 	sts	0x0070, r1
  timer2_ref++;
     ec0:	40 91 f6 03 	lds	r20, 0x03F6
     ec4:	4f 5f       	subi	r20, 0xFF	; 255
     ec6:	40 93 f6 03 	sts	0x03F6, r20

  if ((zmena == 1) && ((cak+10) == timer2_ref))
     eca:	80 91 f7 03 	lds	r24, 0x03F7
     ece:	81 30       	cpi	r24, 0x01	; 1
     ed0:	59 f4       	brne	.+22     	; 0xee8 <__vector_9+0x52>
     ed2:	80 91 fa 03 	lds	r24, 0x03FA
     ed6:	90 e0       	ldi	r25, 0x00	; 0
     ed8:	0a 96       	adiw	r24, 0x0a	; 10
     eda:	24 2f       	mov	r18, r20
     edc:	30 e0       	ldi	r19, 0x00	; 0
     ede:	82 17       	cp	r24, r18
     ee0:	93 07       	cpc	r25, r19
     ee2:	11 f4       	brne	.+4      	; 0xee8 <__vector_9+0x52>
    zmena = 0;
     ee4:	10 92 f7 03 	sts	0x03F7, r1

  if (bit_is_set(PIND, 4) && (zmena == 0)) {
     ee8:	4c 9b       	sbis	0x09, 4	; 9
     eea:	17 c0       	rjmp	.+46     	; 0xf1a <__vector_9+0x84>
     eec:	80 91 f7 03 	lds	r24, 0x03F7
     ef0:	88 23       	and	r24, r24
     ef2:	99 f4       	brne	.+38     	; 0xf1a <__vector_9+0x84>
    podsv_dis ^= 1;
     ef4:	80 91 f9 03 	lds	r24, 0x03F9
     ef8:	21 e0       	ldi	r18, 0x01	; 1
     efa:	82 27       	eor	r24, r18
     efc:	80 93 f9 03 	sts	0x03F9, r24
    PORTD ^= 4;
     f00:	8b b1       	in	r24, 0x0b	; 11
     f02:	94 e0       	ldi	r25, 0x04	; 4
     f04:	89 27       	eor	r24, r25
     f06:	8b b9       	out	0x0b, r24	; 11
	zmena = 1;
     f08:	20 93 f7 03 	sts	0x03F7, r18
	cak = (timer2_ref <= 245) ? timer2_ref : 0;
     f0c:	46 3f       	cpi	r20, 0xF6	; 246
     f0e:	10 f0       	brcs	.+4      	; 0xf14 <__vector_9+0x7e>
     f10:	80 e0       	ldi	r24, 0x00	; 0
     f12:	01 c0       	rjmp	.+2      	; 0xf16 <__vector_9+0x80>
     f14:	84 2f       	mov	r24, r20
     f16:	80 93 fa 03 	sts	0x03FA, r24
  }
  if ((timer2_ref % 250) == 0) {
     f1a:	84 2f       	mov	r24, r20
     f1c:	6a ef       	ldi	r22, 0xFA	; 250
     f1e:	0e 94 8e 13 	call	0x271c	; 0x271c <__udivmodqi4>
     f22:	99 23       	and	r25, r25
     f24:	09 f0       	breq	.+2      	; 0xf28 <__vector_9+0x92>
     f26:	4f c0       	rjmp	.+158    	; 0xfc6 <__vector_9+0x130>
    check1 = tst_monudaje();
     f28:	0e 94 07 07 	call	0xe0e	; 0xe0e <tst_monudaje>
     f2c:	ec 01       	movw	r28, r24
    if (check1 != 0) {
     f2e:	00 97       	sbiw	r24, 0x00	; 0
     f30:	89 f1       	breq	.+98     	; 0xf94 <__vector_9+0xfe>
      LCDclr();
     f32:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
	  strcpy(lcd_dis[0], "Opravena chyba v");
     f36:	8b ef       	ldi	r24, 0xFB	; 251
     f38:	93 e0       	ldi	r25, 0x03	; 3
     f3a:	63 e1       	ldi	r22, 0x13	; 19
     f3c:	71 e0       	ldi	r23, 0x01	; 1
     f3e:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	  strcpy(lcd_dis[1], "                ");
     f42:	8c e0       	ldi	r24, 0x0C	; 12
     f44:	94 e0       	ldi	r25, 0x04	; 4
     f46:	64 e2       	ldi	r22, 0x24	; 36
     f48:	71 e0       	ldi	r23, 0x01	; 1
     f4a:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	  strcpy(lcd_dis[1], check1);
     f4e:	8c e0       	ldi	r24, 0x0C	; 12
     f50:	94 e0       	ldi	r25, 0x04	; 4
     f52:	be 01       	movw	r22, r28
     f54:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	  LCDstringXY(0, 0, lcd_dis[0], 16);
     f58:	80 e0       	ldi	r24, 0x00	; 0
     f5a:	60 e0       	ldi	r22, 0x00	; 0
     f5c:	4b ef       	ldi	r20, 0xFB	; 251
     f5e:	53 e0       	ldi	r21, 0x03	; 3
     f60:	20 e1       	ldi	r18, 0x10	; 16
     f62:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
      LCDstringXY(0, 1, lcd_dis[1], 16);
     f66:	80 e0       	ldi	r24, 0x00	; 0
     f68:	61 e0       	ldi	r22, 0x01	; 1
     f6a:	4c e0       	ldi	r20, 0x0C	; 12
     f6c:	54 e0       	ldi	r21, 0x04	; 4
     f6e:	20 e1       	ldi	r18, 0x10	; 16
     f70:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
     f74:	80 e1       	ldi	r24, 0x10	; 16
     f76:	97 e2       	ldi	r25, 0x27	; 39
     f78:	28 ec       	ldi	r18, 0xC8	; 200
     f7a:	30 e0       	ldi	r19, 0x00	; 0
     f7c:	f9 01       	movw	r30, r18
     f7e:	31 97       	sbiw	r30, 0x01	; 1
     f80:	f1 f7       	brne	.-4      	; 0xf7e <__vector_9+0xe8>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f82:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f84:	d9 f7       	brne	.-10     	; 0xf7c <__vector_9+0xe6>
     f86:	35 c0       	rjmp	.+106    	; 0xff2 <__vector_9+0x15c>
     f88:	ca 01       	movw	r24, r20
     f8a:	01 97       	sbiw	r24, 0x01	; 1
     f8c:	f1 f7       	brne	.-4      	; 0xf8a <__vector_9+0xf4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f8e:	21 50       	subi	r18, 0x01	; 1
     f90:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f92:	d1 f7       	brne	.-12     	; 0xf88 <__vector_9+0xf2>
  return 0;
}
//----------------------------------------------------------------------
char *tst_alarm(void)
{
  if (alarm.temp > 1) {
     f94:	80 91 23 04 	lds	r24, 0x0423
     f98:	82 30       	cpi	r24, 0x02	; 2
     f9a:	10 f0       	brcs	.+4      	; 0xfa0 <__vector_9+0x10a>
    alarm.temp = 0;
     f9c:	10 92 23 04 	sts	0x0423, r1
  }
  if (alarm.clock > 1) {
     fa0:	80 91 24 04 	lds	r24, 0x0424
     fa4:	82 30       	cpi	r24, 0x02	; 2
     fa6:	10 f0       	brcs	.+4      	; 0xfac <__vector_9+0x116>
    alarm.clock = 0;
     fa8:	10 92 24 04 	sts	0x0424, r1
  }
  if (alarm.al_flag > 1) {
     fac:	80 91 25 04 	lds	r24, 0x0425
     fb0:	82 30       	cpi	r24, 0x02	; 2
     fb2:	10 f0       	brcs	.+4      	; 0xfb8 <__vector_9+0x122>
    alarm.al_flag = 0;
     fb4:	10 92 25 04 	sts	0x0425, r1
  }
  if (alarm.al_den > 10) {
     fb8:	80 91 26 04 	lds	r24, 0x0426
     fbc:	8b 30       	cpi	r24, 0x0B	; 11
     fbe:	18 f0       	brcs	.+6      	; 0xfc6 <__vector_9+0x130>
    alarm.al_den = 1;
     fc0:	81 e0       	ldi	r24, 0x01	; 1
     fc2:	80 93 26 04 	sts	0x0426, r24
    tst_alarm();
    tst_alres();
    //tst_com();
  }
  
  TIMSK2 = 1;
     fc6:	81 e0       	ldi	r24, 0x01	; 1
     fc8:	80 93 70 00 	sts	0x0070, r24
}
     fcc:	ff 91       	pop	r31
     fce:	ef 91       	pop	r30
     fd0:	df 91       	pop	r29
     fd2:	cf 91       	pop	r28
     fd4:	bf 91       	pop	r27
     fd6:	af 91       	pop	r26
     fd8:	9f 91       	pop	r25
     fda:	8f 91       	pop	r24
     fdc:	7f 91       	pop	r23
     fde:	6f 91       	pop	r22
     fe0:	5f 91       	pop	r21
     fe2:	4f 91       	pop	r20
     fe4:	3f 91       	pop	r19
     fe6:	2f 91       	pop	r18
     fe8:	0f 90       	pop	r0
     fea:	0f be       	out	0x3f, r0	; 63
     fec:	0f 90       	pop	r0
     fee:	1f 90       	pop	r1
     ff0:	18 95       	reti
      LCDstringXY(0, 1, lcd_dis[1], 16);
	  _delay_ms(1000);
    }
    //check1 = tst_udaje();
    if (check1 != 0) {
      LCDclr();
     ff2:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
	  strcpy(lcd_dis[0], "Najdena chyba v ");
     ff6:	8b ef       	ldi	r24, 0xFB	; 251
     ff8:	93 e0       	ldi	r25, 0x03	; 3
     ffa:	65 e3       	ldi	r22, 0x35	; 53
     ffc:	71 e0       	ldi	r23, 0x01	; 1
     ffe:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	  strcpy(lcd_dis[1], "                ");
    1002:	8c e0       	ldi	r24, 0x0C	; 12
    1004:	94 e0       	ldi	r25, 0x04	; 4
    1006:	64 e2       	ldi	r22, 0x24	; 36
    1008:	71 e0       	ldi	r23, 0x01	; 1
    100a:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	  strcpy(lcd_dis[1], check1);
    100e:	8c e0       	ldi	r24, 0x0C	; 12
    1010:	94 e0       	ldi	r25, 0x04	; 4
    1012:	be 01       	movw	r22, r28
    1014:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	  LCDstringXY(0, 0, lcd_dis[0], 16);
    1018:	80 e0       	ldi	r24, 0x00	; 0
    101a:	60 e0       	ldi	r22, 0x00	; 0
    101c:	4b ef       	ldi	r20, 0xFB	; 251
    101e:	53 e0       	ldi	r21, 0x03	; 3
    1020:	20 e1       	ldi	r18, 0x10	; 16
    1022:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
      LCDstringXY(0, 1, lcd_dis[1], 16);
    1026:	80 e0       	ldi	r24, 0x00	; 0
    1028:	61 e0       	ldi	r22, 0x01	; 1
    102a:	4c e0       	ldi	r20, 0x0C	; 12
    102c:	54 e0       	ldi	r21, 0x04	; 4
    102e:	20 e1       	ldi	r18, 0x10	; 16
    1030:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    1034:	20 e1       	ldi	r18, 0x10	; 16
    1036:	37 e2       	ldi	r19, 0x27	; 39
    1038:	48 ec       	ldi	r20, 0xC8	; 200
    103a:	50 e0       	ldi	r21, 0x00	; 0
    103c:	a5 cf       	rjmp	.-182    	; 0xf88 <__vector_9+0xf2>

0000103e <nastav5>:
  }
  alarm.temp = _temp;
}
//----------------------------------------------------------------------
void nastav5(void)	
{
    103e:	ef 92       	push	r14
    1040:	ff 92       	push	r15
    1042:	0f 93       	push	r16
    1044:	df 93       	push	r29
    1046:	cf 93       	push	r28
    1048:	cd b7       	in	r28, 0x3d	; 61
    104a:	de b7       	in	r29, 0x3e	; 62
    104c:	64 97       	sbiw	r28, 0x14	; 20
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	f8 94       	cli
    1052:	de bf       	out	0x3e, r29	; 62
    1054:	0f be       	out	0x3f, r0	; 63
    1056:	cd bf       	out	0x3d, r28	; 61
  char _aden, j;
  char *al_dni[] = {"Pondelok", "Utorok  ", "Streda  ", "Stvrtok ", "Piatok  ", "Sobota  ", "Nedela  ", "Po - Pia", "So - Ne ", "Po - Ne "};
    1058:	de 01       	movw	r26, r28
    105a:	11 96       	adiw	r26, 0x01	; 1
    105c:	ed ed       	ldi	r30, 0xDD	; 221
    105e:	f3 e0       	ldi	r31, 0x03	; 3
    1060:	84 e1       	ldi	r24, 0x14	; 20
    1062:	01 90       	ld	r0, Z+
    1064:	0d 92       	st	X+, r0
    1066:	81 50       	subi	r24, 0x01	; 1
    1068:	e1 f7       	brne	.-8      	; 0x1062 <nastav5+0x24>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    106a:	30 99       	sbic	0x06, 0	; 6
    106c:	fe cf       	rjmp	.-4      	; 0x106a <nastav5+0x2c>
{
  char _aden, j;
  char *al_dni[] = {"Pondelok", "Utorok  ", "Streda  ", "Stvrtok ", "Piatok  ", "Sobota  ", "Nedela  ", "Po - Pia", "So - Ne ", "Po - Ne "};

  cakaj(0);
  _aden = alarm.al_den;					
    106e:	00 91 26 04 	lds	r16, 0x0426
  LCDclr();
    1072:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
  strcpy(lcd_dis[0], "  Nastavit den");
    1076:	8b ef       	ldi	r24, 0xFB	; 251
    1078:	93 e0       	ldi	r25, 0x03	; 3
    107a:	66 e4       	ldi	r22, 0x46	; 70
    107c:	71 e0       	ldi	r23, 0x01	; 1
    107e:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  strcpy(lcd_dis[1], al_dni[_aden-1]);
    1082:	e0 2f       	mov	r30, r16
    1084:	f0 e0       	ldi	r31, 0x00	; 0
    1086:	31 97       	sbiw	r30, 0x01	; 1
    1088:	ee 0f       	add	r30, r30
    108a:	ff 1f       	adc	r31, r31
    108c:	7e 01       	movw	r14, r28
    108e:	08 94       	sec
    1090:	e1 1c       	adc	r14, r1
    1092:	f1 1c       	adc	r15, r1
    1094:	ee 0d       	add	r30, r14
    1096:	ff 1d       	adc	r31, r15
    1098:	60 81       	ld	r22, Z
    109a:	71 81       	ldd	r23, Z+1	; 0x01
    109c:	8c e0       	ldi	r24, 0x0C	; 12
    109e:	94 e0       	ldi	r25, 0x04	; 4
    10a0:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  LCDstringXY(0, 0, lcd_dis[0], 14);
    10a4:	80 e0       	ldi	r24, 0x00	; 0
    10a6:	60 e0       	ldi	r22, 0x00	; 0
    10a8:	4b ef       	ldi	r20, 0xFB	; 251
    10aa:	53 e0       	ldi	r21, 0x03	; 3
    10ac:	2e e0       	ldi	r18, 0x0E	; 14
    10ae:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
  LCDstringXY(0, 1, lcd_dis[1], 8);
    10b2:	80 e0       	ldi	r24, 0x00	; 0
    10b4:	61 e0       	ldi	r22, 0x01	; 1
    10b6:	4c e0       	ldi	r20, 0x0C	; 12
    10b8:	54 e0       	ldi	r21, 0x04	; 4
    10ba:	28 e0       	ldi	r18, 0x08	; 8
    10bc:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
  for (;;) {
    strcpy(lcd_dis[1], al_dni[_aden-1]);
    10c0:	e0 2f       	mov	r30, r16
    10c2:	f0 e0       	ldi	r31, 0x00	; 0
    10c4:	31 97       	sbiw	r30, 0x01	; 1
    10c6:	ee 0f       	add	r30, r30
    10c8:	ff 1f       	adc	r31, r31
    10ca:	ee 0d       	add	r30, r14
    10cc:	ff 1d       	adc	r31, r15
    10ce:	60 81       	ld	r22, Z
    10d0:	71 81       	ldd	r23, Z+1	; 0x01
    10d2:	8c e0       	ldi	r24, 0x0C	; 12
    10d4:	94 e0       	ldi	r25, 0x04	; 4
    10d6:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
    LCDstringXY(0, 1, lcd_dis[1], 8);	
    10da:	80 e0       	ldi	r24, 0x00	; 0
    10dc:	61 e0       	ldi	r22, 0x01	; 1
    10de:	4c e0       	ldi	r20, 0x0C	; 12
    10e0:	54 e0       	ldi	r21, 0x04	; 4
    10e2:	28 e0       	ldi	r18, 0x08	; 8
    10e4:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    if (bit_is_set(PINC, 1)) {
    10e8:	31 9b       	sbis	0x06, 1	; 6
    10ea:	0c c0       	rjmp	.+24     	; 0x1104 <nastav5+0xc6>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    10ec:	31 99       	sbic	0x06, 1	; 6
    10ee:	fe cf       	rjmp	.-4      	; 0x10ec <nastav5+0xae>
  for (;;) {
    strcpy(lcd_dis[1], al_dni[_aden-1]);
    LCDstringXY(0, 1, lcd_dis[1], 8);	
    if (bit_is_set(PINC, 1)) {
	  cakaj(1);
	  if (_aden < 10)
    10f0:	0a 30       	cpi	r16, 0x0A	; 10
    10f2:	10 f0       	brcs	.+4      	; 0x10f8 <nastav5+0xba>
    10f4:	01 e0       	ldi	r16, 0x01	; 1
    10f6:	01 c0       	rjmp	.+2      	; 0x10fa <nastav5+0xbc>
	    _aden++;
    10f8:	0f 5f       	subi	r16, 0xFF	; 255
	  else _aden = 1;
	  LCDcistiXY(0, 1, 8);
    10fa:	80 e0       	ldi	r24, 0x00	; 0
    10fc:	61 e0       	ldi	r22, 0x01	; 1
    10fe:	48 e0       	ldi	r20, 0x08	; 8
    1100:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
	}
	if (bit_is_set(PINC, 2)) {
    1104:	32 9b       	sbis	0x06, 2	; 6
    1106:	0c c0       	rjmp	.+24     	; 0x1120 <nastav5+0xe2>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1108:	32 99       	sbic	0x06, 2	; 6
    110a:	fe cf       	rjmp	.-4      	; 0x1108 <nastav5+0xca>
	  else _aden = 1;
	  LCDcistiXY(0, 1, 8);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  if (_aden > 1)
    110c:	02 30       	cpi	r16, 0x02	; 2
    110e:	10 f4       	brcc	.+4      	; 0x1114 <nastav5+0xd6>
    1110:	0a e0       	ldi	r16, 0x0A	; 10
    1112:	01 c0       	rjmp	.+2      	; 0x1116 <nastav5+0xd8>
	    _aden--;
    1114:	01 50       	subi	r16, 0x01	; 1
	  else _aden = 10;
	  LCDcistiXY(0, 1, 8);
    1116:	80 e0       	ldi	r24, 0x00	; 0
    1118:	61 e0       	ldi	r22, 0x01	; 1
    111a:	48 e0       	ldi	r20, 0x08	; 8
    111c:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
	}
	if (bit_is_set(PINC, 0)) {
    1120:	30 9b       	sbis	0x06, 0	; 6
    1122:	05 c0       	rjmp	.+10     	; 0x112e <nastav5+0xf0>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1124:	30 99       	sbic	0x06, 0	; 6
    1126:	fe cf       	rjmp	.-4      	; 0x1124 <nastav5+0xe6>
	  else _aden = 10;
	  LCDcistiXY(0, 1, 8);
	}
	if (bit_is_set(PINC, 0)) {
	  cakaj(0);
	  alarm.al_den = _aden;
    1128:	00 93 26 04 	sts	0x0426, r16
    112c:	04 c0       	rjmp	.+8      	; 0x1136 <nastav5+0xf8>
	  break;
	}
	if (bit_is_set(PINC, 4)) {
    112e:	34 9b       	sbis	0x06, 4	; 6
    1130:	c7 cf       	rjmp	.-114    	; 0x10c0 <nastav5+0x82>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1132:	34 99       	sbic	0x06, 4	; 6
    1134:	fe cf       	rjmp	.-4      	; 0x1132 <nastav5+0xf4>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
}
    1136:	64 96       	adiw	r28, 0x14	; 20
    1138:	0f b6       	in	r0, 0x3f	; 63
    113a:	f8 94       	cli
    113c:	de bf       	out	0x3e, r29	; 62
    113e:	0f be       	out	0x3f, r0	; 63
    1140:	cd bf       	out	0x3d, r28	; 61
    1142:	cf 91       	pop	r28
    1144:	df 91       	pop	r29
    1146:	0f 91       	pop	r16
    1148:	ff 90       	pop	r15
    114a:	ef 90       	pop	r14
    114c:	08 95       	ret

0000114e <nastav2>:
	}
  }
}
//----------------------------------------------------------------------
void nastav2(void)		// nastavenie ALARMU (ako celku)
{
    114e:	1f 93       	push	r17
    1150:	cf 93       	push	r28
    1152:	df 93       	push	r29
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1154:	30 99       	sbic	0x06, 0	; 6
    1156:	fe cf       	rjmp	.-4      	; 0x1154 <nastav2+0x6>
void nastav2(void)		// nastavenie ALARMU (ako celku)
{
  char al_flag;

  cakaj(0);
  al_flag = alarm.al_flag;
    1158:	10 91 25 04 	lds	r17, 0x0425
  LCDclr();
    115c:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
  LCDhome();
    1160:	0e 94 d6 01 	call	0x3ac	; 0x3ac <LCDhome>
  strcpy(lcd_dis[0], "Nastavit Alarm  ");	//doplnene
    1164:	8b ef       	ldi	r24, 0xFB	; 251
    1166:	93 e0       	ldi	r25, 0x03	; 3
    1168:	65 e5       	ldi	r22, 0x55	; 85
    116a:	71 e0       	ldi	r23, 0x01	; 1
    116c:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  LCDstring(lcd_dis[0], 16);				// funkcia nastav2() je spustena funkciou nastav1()
    1170:	8b ef       	ldi	r24, 0xFB	; 251
    1172:	93 e0       	ldi	r25, 0x03	; 3
    1174:	60 e1       	ldi	r22, 0x10	; 16
    1176:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
    117a:	c8 ec       	ldi	r28, 0xC8	; 200
    117c:	d0 e0       	ldi	r29, 0x00	; 0
  while (1) {								// v tejto funkcii nastavujem ON/OFF alarm
    LCDGotoXY(0,1);							// po nastaveni ON funkcia automaticky skoci na nastav3()
    117e:	80 e0       	ldi	r24, 0x00	; 0
    1180:	61 e0       	ldi	r22, 0x01	; 1
    1182:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
	if (al_flag == 0) {					// inak neskoci nikam a vrati sa do nastav1() ktora nasledne skonci
    1186:	11 23       	and	r17, r17
    1188:	29 f4       	brne	.+10     	; 0x1194 <nastav2+0x46>
	  strcpy(lcd_dis[1], "Vypnute");	//doplnene
    118a:	8c e0       	ldi	r24, 0x0C	; 12
    118c:	94 e0       	ldi	r25, 0x04	; 4
    118e:	66 e6       	ldi	r22, 0x66	; 102
    1190:	71 e0       	ldi	r23, 0x01	; 1
    1192:	04 c0       	rjmp	.+8      	; 0x119c <nastav2+0x4e>
	  LCDstring(lcd_dis[1], 7);
	}
	else {
	  strcpy(lcd_dis[1], "Zapnute");	//doplnene
    1194:	8c e0       	ldi	r24, 0x0C	; 12
    1196:	94 e0       	ldi	r25, 0x04	; 4
    1198:	6e e6       	ldi	r22, 0x6E	; 110
    119a:	71 e0       	ldi	r23, 0x01	; 1
    119c:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	  LCDstring(lcd_dis[1], 7);
    11a0:	8c e0       	ldi	r24, 0x0C	; 12
    11a2:	94 e0       	ldi	r25, 0x04	; 4
    11a4:	67 e0       	ldi	r22, 0x07	; 7
    11a6:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
	}
	if (bit_is_set(PINC, 1)) {
    11aa:	31 9b       	sbis	0x06, 1	; 6
    11ac:	10 c0       	rjmp	.+32     	; 0x11ce <nastav2+0x80>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    11ae:	31 99       	sbic	0x06, 1	; 6
    11b0:	fe cf       	rjmp	.-4      	; 0x11ae <nastav2+0x60>
	  LCDstring(lcd_dis[1], 7);
	}
	if (bit_is_set(PINC, 1)) {
	  cakaj(1);
	  al_flag ^= 1;
	  LCDcistiXY(0, 1, 7);
    11b2:	80 e0       	ldi	r24, 0x00	; 0
    11b4:	61 e0       	ldi	r22, 0x01	; 1
    11b6:	47 e0       	ldi	r20, 0x07	; 7
    11b8:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    11bc:	80 e2       	ldi	r24, 0x20	; 32
    11be:	93 e0       	ldi	r25, 0x03	; 3
    11c0:	fe 01       	movw	r30, r28
    11c2:	31 97       	sbiw	r30, 0x01	; 1
    11c4:	f1 f7       	brne	.-4      	; 0x11c2 <nastav2+0x74>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    11c6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    11c8:	d9 f7       	brne	.-10     	; 0x11c0 <nastav2+0x72>
	  strcpy(lcd_dis[1], "Zapnute");	//doplnene
	  LCDstring(lcd_dis[1], 7);
	}
	if (bit_is_set(PINC, 1)) {
	  cakaj(1);
	  al_flag ^= 1;
    11ca:	81 e0       	ldi	r24, 0x01	; 1
    11cc:	18 27       	eor	r17, r24
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 2)) {
    11ce:	32 9b       	sbis	0x06, 2	; 6
    11d0:	10 c0       	rjmp	.+32     	; 0x11f2 <nastav2+0xa4>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    11d2:	32 99       	sbic	0x06, 2	; 6
    11d4:	fe cf       	rjmp	.-4      	; 0x11d2 <nastav2+0x84>
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  al_flag ^= 1;
	  LCDcistiXY(0, 1, 7);
    11d6:	80 e0       	ldi	r24, 0x00	; 0
    11d8:	61 e0       	ldi	r22, 0x01	; 1
    11da:	47 e0       	ldi	r20, 0x07	; 7
    11dc:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    11e0:	80 e2       	ldi	r24, 0x20	; 32
    11e2:	93 e0       	ldi	r25, 0x03	; 3
    11e4:	fe 01       	movw	r30, r28
    11e6:	31 97       	sbiw	r30, 0x01	; 1
    11e8:	f1 f7       	brne	.-4      	; 0x11e6 <nastav2+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    11ea:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    11ec:	d9 f7       	brne	.-10     	; 0x11e4 <nastav2+0x96>
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  al_flag ^= 1;
    11ee:	81 e0       	ldi	r24, 0x01	; 1
    11f0:	18 27       	eor	r17, r24
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 0)) {
    11f2:	30 9b       	sbis	0x06, 0	; 6
    11f4:	03 c0       	rjmp	.+6      	; 0x11fc <nastav2+0xae>
	  alarm.al_flag = al_flag;
    11f6:	10 93 25 04 	sts	0x0425, r17
    11fa:	04 c0       	rjmp	.+8      	; 0x1204 <nastav2+0xb6>
	  break;
	}
	if (bit_is_set(PINC, 4)) {
    11fc:	34 9b       	sbis	0x06, 4	; 6
    11fe:	bf cf       	rjmp	.-130    	; 0x117e <nastav2+0x30>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1200:	34 99       	sbic	0x06, 4	; 6
    1202:	fe cf       	rjmp	.-4      	; 0x1200 <nastav2+0xb2>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
}
    1204:	df 91       	pop	r29
    1206:	cf 91       	pop	r28
    1208:	1f 91       	pop	r17
    120a:	08 95       	ret

0000120c <nastav1>:
	}
  }
}
//----------------------------------------------------------------------
void nastav1(void)			
{
    120c:	1f 93       	push	r17
    120e:	cf 93       	push	r28
    1210:	df 93       	push	r29
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1212:	30 99       	sbic	0x06, 0	; 6
    1214:	fe cf       	rjmp	.-4      	; 0x1212 <nastav1+0x6>
void nastav1(void)			
{
  char mon_temp;
  
  cakaj(0);
  mon_temp = udaje.mon_temp;
    1216:	10 91 3b 04 	lds	r17, 0x043B
  LCDclr();
    121a:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
  LCDhome();
    121e:	0e 94 d6 01 	call	0x3ac	; 0x3ac <LCDhome>
  strcpy(lcd_dis[0], "Snimat teplotu >");	//doplnene
    1222:	8b ef       	ldi	r24, 0xFB	; 251
    1224:	93 e0       	ldi	r25, 0x03	; 3
    1226:	66 e7       	ldi	r22, 0x76	; 118
    1228:	71 e0       	ldi	r23, 0x01	; 1
    122a:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  LCDstring(lcd_dis[0], 16);				// zacinam nastavenim sniania teploty
    122e:	8b ef       	ldi	r24, 0xFB	; 251
    1230:	93 e0       	ldi	r25, 0x03	; 3
    1232:	60 e1       	ldi	r22, 0x10	; 16
    1234:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
    1238:	c8 ec       	ldi	r28, 0xC8	; 200
    123a:	d0 e0       	ldi	r29, 0x00	; 0
  while (1) {									// co je funkcia nastav1
    LCDGotoXY(0,1);								// tato funkcia je spustena funkciou nastav_extra()
    123c:	80 e0       	ldi	r24, 0x00	; 0
    123e:	61 e0       	ldi	r22, 0x01	; 1
    1240:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
    if (mon_temp == 0) {					// a ta je spustena ukazatelom podla prislusnej volby
    1244:	11 23       	and	r17, r17
    1246:	29 f4       	brne	.+10     	; 0x1252 <nastav1+0x46>
	  strcpy(lcd_dis[1], "Vypnute");		//doplnene
    1248:	8c e0       	ldi	r24, 0x0C	; 12
    124a:	94 e0       	ldi	r25, 0x04	; 4
    124c:	66 e6       	ldi	r22, 0x66	; 102
    124e:	71 e0       	ldi	r23, 0x01	; 1
    1250:	04 c0       	rjmp	.+8      	; 0x125a <nastav1+0x4e>
      LCDstring(lcd_dis[1], 7);
	}
    else {
	  strcpy(lcd_dis[1],"Zapnute"); 		//doplnene
    1252:	8c e0       	ldi	r24, 0x0C	; 12
    1254:	94 e0       	ldi	r25, 0x04	; 4
    1256:	6e e6       	ldi	r22, 0x6E	; 110
    1258:	71 e0       	ldi	r23, 0x01	; 1
    125a:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	  LCDstring(lcd_dis[1], 7);
    125e:	8c e0       	ldi	r24, 0x0C	; 12
    1260:	94 e0       	ldi	r25, 0x04	; 4
    1262:	67 e0       	ldi	r22, 0x07	; 7
    1264:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
	}
	if (bit_is_set(PINC, 1)) {	
    1268:	31 9b       	sbis	0x06, 1	; 6
    126a:	10 c0       	rjmp	.+32     	; 0x128c <nastav1+0x80>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    126c:	31 99       	sbic	0x06, 1	; 6
    126e:	fe cf       	rjmp	.-4      	; 0x126c <nastav1+0x60>
	  LCDstring(lcd_dis[1], 7);
	}
	if (bit_is_set(PINC, 1)) {	
	  cakaj(1);
	  mon_temp ^= 1;
	  LCDcistiXY(0, 1, 7);
    1270:	80 e0       	ldi	r24, 0x00	; 0
    1272:	61 e0       	ldi	r22, 0x01	; 1
    1274:	47 e0       	ldi	r20, 0x07	; 7
    1276:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    127a:	88 ee       	ldi	r24, 0xE8	; 232
    127c:	93 e0       	ldi	r25, 0x03	; 3
    127e:	fe 01       	movw	r30, r28
    1280:	31 97       	sbiw	r30, 0x01	; 1
    1282:	f1 f7       	brne	.-4      	; 0x1280 <nastav1+0x74>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1284:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1286:	d9 f7       	brne	.-10     	; 0x127e <nastav1+0x72>
	  strcpy(lcd_dis[1],"Zapnute"); 		//doplnene
	  LCDstring(lcd_dis[1], 7);
	}
	if (bit_is_set(PINC, 1)) {	
	  cakaj(1);
	  mon_temp ^= 1;
    1288:	81 e0       	ldi	r24, 0x01	; 1
    128a:	18 27       	eor	r17, r24
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 2)) {
    128c:	32 9b       	sbis	0x06, 2	; 6
    128e:	10 c0       	rjmp	.+32     	; 0x12b0 <nastav1+0xa4>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1290:	32 99       	sbic	0x06, 2	; 6
    1292:	fe cf       	rjmp	.-4      	; 0x1290 <nastav1+0x84>
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  mon_temp ^= 1;
	  LCDcistiXY(0, 1, 7);
    1294:	80 e0       	ldi	r24, 0x00	; 0
    1296:	61 e0       	ldi	r22, 0x01	; 1
    1298:	47 e0       	ldi	r20, 0x07	; 7
    129a:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    129e:	88 ee       	ldi	r24, 0xE8	; 232
    12a0:	93 e0       	ldi	r25, 0x03	; 3
    12a2:	fe 01       	movw	r30, r28
    12a4:	31 97       	sbiw	r30, 0x01	; 1
    12a6:	f1 f7       	brne	.-4      	; 0x12a4 <nastav1+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    12a8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    12aa:	d9 f7       	brne	.-10     	; 0x12a2 <nastav1+0x96>
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  mon_temp ^= 1;
    12ac:	81 e0       	ldi	r24, 0x01	; 1
    12ae:	18 27       	eor	r17, r24
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 0)) {
    12b0:	30 9b       	sbis	0x06, 0	; 6
    12b2:	05 c0       	rjmp	.+10     	; 0x12be <nastav1+0xb2>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    12b4:	30 99       	sbic	0x06, 0	; 6
    12b6:	fe cf       	rjmp	.-4      	; 0x12b4 <nastav1+0xa8>
	  LCDcistiXY(0, 1, 7);
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 0)) {
	  cakaj(0);
	  udaje.mon_temp = mon_temp;
    12b8:	10 93 3b 04 	sts	0x043B, r17
    12bc:	04 c0       	rjmp	.+8      	; 0x12c6 <nastav1+0xba>
	  break;
	}
	if (bit_is_set(PINC, 4)) {
    12be:	34 9b       	sbis	0x06, 4	; 6
    12c0:	bd cf       	rjmp	.-134    	; 0x123c <nastav1+0x30>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    12c2:	34 99       	sbic	0x06, 4	; 6
    12c4:	fe cf       	rjmp	.-4      	; 0x12c2 <nastav1+0xb6>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
}
    12c6:	df 91       	pop	r29
    12c8:	cf 91       	pop	r28
    12ca:	1f 91       	pop	r17
    12cc:	08 95       	ret

000012ce <konfig_hodiny>:
  }
  udaje.mDen = sum;
}
//----------------------------------------------------------------------
void konfig_hodiny(void)
{ 
    12ce:	cf 92       	push	r12
    12d0:	df 92       	push	r13
    12d2:	ff 92       	push	r15
    12d4:	0f 93       	push	r16
    12d6:	1f 93       	push	r17
    12d8:	cf 93       	push	r28
    12da:	df 93       	push	r29
  char i;

  LCDclr();
    12dc:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    12e0:	30 99       	sbic	0x06, 0	; 6
    12e2:	fe cf       	rjmp	.-4      	; 0x12e0 <konfig_hodiny+0x12>
{ 
  char i;

  LCDclr();
  cakaj(0);
  LCDhome();
    12e4:	0e 94 d6 01 	call	0x3ac	; 0x3ac <LCDhome>
  strcpy(lcd_dis[0], "  Hlavne menu   ");	//doplnene
    12e8:	8b ef       	ldi	r24, 0xFB	; 251
    12ea:	93 e0       	ldi	r25, 0x03	; 3
    12ec:	67 e8       	ldi	r22, 0x87	; 135
    12ee:	71 e0       	ldi	r23, 0x01	; 1
    12f0:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  LCDstring(lcd_dis[0], 16);				// prvy riadok vypis Hlavne menu
    12f4:	8b ef       	ldi	r24, 0xFB	; 251
    12f6:	93 e0       	ldi	r25, 0x03	; 3
    12f8:	60 e1       	ldi	r22, 0x10	; 16
    12fa:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
  strcpy(lcd_dis[1], menu[0]);			//doplnene
    12fe:	60 91 7b 03 	lds	r22, 0x037B
    1302:	70 91 7c 03 	lds	r23, 0x037C
    1306:	8c e0       	ldi	r24, 0x0C	; 12
    1308:	94 e0       	ldi	r25, 0x04	; 4
    130a:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  LCDstringXY(0, 1, lcd_dis[1], 16);					// na druhy riadok vypis prvu polozku
    130e:	80 e0       	ldi	r24, 0x00	; 0
    1310:	61 e0       	ldi	r22, 0x01	; 1
    1312:	4c e0       	ldi	r20, 0x0C	; 12
    1314:	54 e0       	ldi	r21, 0x04	; 4
    1316:	20 e1       	ldi	r18, 0x10	; 16
    1318:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    131c:	ff 24       	eor	r15, r15
    131e:	68 ec       	ldi	r22, 0xC8	; 200
    1320:	c6 2e       	mov	r12, r22
    1322:	d1 2c       	mov	r13, r1
  for (i = 0; i < 4;) {
	if (bit_is_set(PINC, 1)) {						//tlacitko 1 zvys i (i = aktualna polozka)
    1324:	31 9b       	sbis	0x06, 1	; 6
    1326:	2a c0       	rjmp	.+84     	; 0x137c <konfig_hodiny+0xae>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1328:	31 99       	sbic	0x06, 1	; 6
    132a:	fe cf       	rjmp	.-4      	; 0x1328 <konfig_hodiny+0x5a>
  strcpy(lcd_dis[1], menu[0]);			//doplnene
  LCDstringXY(0, 1, lcd_dis[1], 16);					// na druhy riadok vypis prvu polozku
  for (i = 0; i < 4;) {
	if (bit_is_set(PINC, 1)) {						//tlacitko 1 zvys i (i = aktualna polozka)
	  cakaj(1);
	  if (++i > 3)
    132c:	f3 94       	inc	r15
    132e:	84 e0       	ldi	r24, 0x04	; 4
    1330:	f8 16       	cp	r15, r24
    1332:	09 f4       	brne	.+2      	; 0x1336 <konfig_hodiny+0x68>
    1334:	ff 24       	eor	r15, r15
	    i = 0;
	  LCDcistiXY(1, 1, 16);
    1336:	81 e0       	ldi	r24, 0x01	; 1
    1338:	61 e0       	ldi	r22, 0x01	; 1
    133a:	40 e1       	ldi	r20, 0x10	; 16
    133c:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    1340:	84 ef       	ldi	r24, 0xF4	; 244
    1342:	91 e0       	ldi	r25, 0x01	; 1
    1344:	f6 01       	movw	r30, r12
    1346:	31 97       	sbiw	r30, 0x01	; 1
    1348:	f1 f7       	brne	.-4      	; 0x1346 <konfig_hodiny+0x78>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    134a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    134c:	d9 f7       	brne	.-10     	; 0x1344 <konfig_hodiny+0x76>
	  _delay_ms(50);
	  strcpy(lcd_dis[1], menu[i]);			//doplnene
    134e:	0f 2d       	mov	r16, r15
    1350:	10 e0       	ldi	r17, 0x00	; 0
    1352:	00 0f       	add	r16, r16
    1354:	11 1f       	adc	r17, r17
    1356:	05 58       	subi	r16, 0x85	; 133
    1358:	1c 4f       	sbci	r17, 0xFC	; 252
    135a:	f8 01       	movw	r30, r16
    135c:	60 81       	ld	r22, Z
    135e:	71 81       	ldd	r23, Z+1	; 0x01
    1360:	8c e0       	ldi	r24, 0x0C	; 12
    1362:	94 e0       	ldi	r25, 0x04	; 4
    1364:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  	  LCDstringXY(1, 1, &menu[i][1], 16);
    1368:	f8 01       	movw	r30, r16
    136a:	40 81       	ld	r20, Z
    136c:	51 81       	ldd	r21, Z+1	; 0x01
    136e:	4f 5f       	subi	r20, 0xFF	; 255
    1370:	5f 4f       	sbci	r21, 0xFF	; 255
    1372:	81 e0       	ldi	r24, 0x01	; 1
    1374:	61 e0       	ldi	r22, 0x01	; 1
    1376:	20 e1       	ldi	r18, 0x10	; 16
    1378:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	}
	if (bit_is_set(PINC, 2)) {
    137c:	32 9b       	sbis	0x06, 2	; 6
    137e:	27 c0       	rjmp	.+78     	; 0x13ce <konfig_hodiny+0x100>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1380:	32 99       	sbic	0x06, 2	; 6
    1382:	fe cf       	rjmp	.-4      	; 0x1380 <konfig_hodiny+0xb2>
	  strcpy(lcd_dis[1], menu[i]);			//doplnene
  	  LCDstringXY(1, 1, &menu[i][1], 16);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  if (--i > 3)
    1384:	fa 94       	dec	r15
    1386:	f3 e0       	ldi	r31, 0x03	; 3
    1388:	ff 15       	cp	r31, r15
    138a:	10 f4       	brcc	.+4      	; 0x1390 <konfig_hodiny+0xc2>
    138c:	43 e0       	ldi	r20, 0x03	; 3
    138e:	f4 2e       	mov	r15, r20
	    i = 3;
	  LCDcistiXY(0, 1, 15);
    1390:	80 e0       	ldi	r24, 0x00	; 0
    1392:	61 e0       	ldi	r22, 0x01	; 1
    1394:	4f e0       	ldi	r20, 0x0F	; 15
    1396:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    139a:	84 ef       	ldi	r24, 0xF4	; 244
    139c:	91 e0       	ldi	r25, 0x01	; 1
    139e:	f6 01       	movw	r30, r12
    13a0:	31 97       	sbiw	r30, 0x01	; 1
    13a2:	f1 f7       	brne	.-4      	; 0x13a0 <konfig_hodiny+0xd2>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    13a4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    13a6:	d9 f7       	brne	.-10     	; 0x139e <konfig_hodiny+0xd0>
	  _delay_ms(50);
	  strcpy(lcd_dis[1], menu[i]);			//doplnene
    13a8:	ef 2d       	mov	r30, r15
    13aa:	f0 e0       	ldi	r31, 0x00	; 0
    13ac:	ee 0f       	add	r30, r30
    13ae:	ff 1f       	adc	r31, r31
    13b0:	e5 58       	subi	r30, 0x85	; 133
    13b2:	fc 4f       	sbci	r31, 0xFC	; 252
    13b4:	60 81       	ld	r22, Z
    13b6:	71 81       	ldd	r23, Z+1	; 0x01
    13b8:	8c e0       	ldi	r24, 0x0C	; 12
    13ba:	94 e0       	ldi	r25, 0x04	; 4
    13bc:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  	  LCDstringXY(0, 1, lcd_dis[1], 15);
    13c0:	80 e0       	ldi	r24, 0x00	; 0
    13c2:	61 e0       	ldi	r22, 0x01	; 1
    13c4:	4c e0       	ldi	r20, 0x0C	; 12
    13c6:	54 e0       	ldi	r21, 0x04	; 4
    13c8:	2f e0       	ldi	r18, 0x0F	; 15
    13ca:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	}
	if (bit_is_set(PINC, 0)) {
    13ce:	30 9b       	sbis	0x06, 0	; 6
    13d0:	47 c0       	rjmp	.+142    	; 0x1460 <konfig_hodiny+0x192>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    13d2:	30 99       	sbic	0x06, 0	; 6
    13d4:	fe cf       	rjmp	.-4      	; 0x13d2 <konfig_hodiny+0x104>
	  strcpy(lcd_dis[1], menu[i]);			//doplnene
  	  LCDstringXY(0, 1, lcd_dis[1], 15);
	}
	if (bit_is_set(PINC, 0)) {
	  cakaj(0);
	  LCDclr();
    13d6:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
	  if (i < 2) { 
    13da:	81 e0       	ldi	r24, 0x01	; 1
    13dc:	8f 15       	cp	r24, r15
    13de:	b8 f0       	brcs	.+46     	; 0x140e <konfig_hodiny+0x140>
	    strcpy(lcd_dis[0], menu[i]);				//doplnene
    13e0:	0f 2d       	mov	r16, r15
    13e2:	10 e0       	ldi	r17, 0x00	; 0
    13e4:	00 0f       	add	r16, r16
    13e6:	11 1f       	adc	r17, r17
    13e8:	05 58       	subi	r16, 0x85	; 133
    13ea:	1c 4f       	sbci	r17, 0xFC	; 252
    13ec:	f8 01       	movw	r30, r16
    13ee:	60 81       	ld	r22, Z
    13f0:	71 81       	ldd	r23, Z+1	; 0x01
    13f2:	8b ef       	ldi	r24, 0xFB	; 251
    13f4:	93 e0       	ldi	r25, 0x03	; 3
    13f6:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	    LCDstringXY(0, 0, &menu[i][1], 14); 
    13fa:	f8 01       	movw	r30, r16
    13fc:	40 81       	ld	r20, Z
    13fe:	51 81       	ldd	r21, Z+1	; 0x01
    1400:	4f 5f       	subi	r20, 0xFF	; 255
    1402:	5f 4f       	sbci	r21, 0xFF	; 255
    1404:	80 e0       	ldi	r24, 0x00	; 0
    1406:	60 e0       	ldi	r22, 0x00	; 0
    1408:	2e e0       	ldi	r18, 0x0E	; 14
    140a:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	  }
	  if (p[i]() != 0) break;
    140e:	cf 2d       	mov	r28, r15
    1410:	d0 e0       	ldi	r29, 0x00	; 0
    1412:	cc 0f       	add	r28, r28
    1414:	dd 1f       	adc	r29, r29
    1416:	fe 01       	movw	r30, r28
    1418:	e1 5d       	subi	r30, 0xD1	; 209
    141a:	fc 4f       	sbci	r31, 0xFC	; 252
    141c:	01 90       	ld	r0, Z+
    141e:	f0 81       	ld	r31, Z
    1420:	e0 2d       	mov	r30, r0
    1422:	09 95       	icall
    1424:	88 23       	and	r24, r24
    1426:	29 f5       	brne	.+74     	; 0x1472 <konfig_hodiny+0x1a4>
	  strcpy(lcd_dis[0], "  Hlavne menu   ");		//doplnene
    1428:	8b ef       	ldi	r24, 0xFB	; 251
    142a:	93 e0       	ldi	r25, 0x03	; 3
    142c:	67 e8       	ldi	r22, 0x87	; 135
    142e:	71 e0       	ldi	r23, 0x01	; 1
    1430:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  	  LCDstringXY(0, 0, lcd_dis[0], 16);
    1434:	80 e0       	ldi	r24, 0x00	; 0
    1436:	60 e0       	ldi	r22, 0x00	; 0
    1438:	4b ef       	ldi	r20, 0xFB	; 251
    143a:	53 e0       	ldi	r21, 0x03	; 3
    143c:	20 e1       	ldi	r18, 0x10	; 16
    143e:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	  strcpy(lcd_dis[1], menu[i]);
    1442:	c5 58       	subi	r28, 0x85	; 133
    1444:	dc 4f       	sbci	r29, 0xFC	; 252
    1446:	68 81       	ld	r22, Y
    1448:	79 81       	ldd	r23, Y+1	; 0x01
    144a:	8c e0       	ldi	r24, 0x0C	; 12
    144c:	94 e0       	ldi	r25, 0x04	; 4
    144e:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	  LCDstringXY(0, 1, lcd_dis[1], 16);
    1452:	80 e0       	ldi	r24, 0x00	; 0
    1454:	61 e0       	ldi	r22, 0x01	; 1
    1456:	4c e0       	ldi	r20, 0x0C	; 12
    1458:	54 e0       	ldi	r21, 0x04	; 4
    145a:	20 e1       	ldi	r18, 0x10	; 16
    145c:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	}
	if (bit_is_set(PINC, 4)) {
    1460:	34 9b       	sbis	0x06, 4	; 6
    1462:	03 c0       	rjmp	.+6      	; 0x146a <konfig_hodiny+0x19c>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1464:	34 99       	sbic	0x06, 4	; 6
    1466:	fe cf       	rjmp	.-4      	; 0x1464 <konfig_hodiny+0x196>
    1468:	04 c0       	rjmp	.+8      	; 0x1472 <konfig_hodiny+0x1a4>
  LCDhome();
  strcpy(lcd_dis[0], "  Hlavne menu   ");	//doplnene
  LCDstring(lcd_dis[0], 16);				// prvy riadok vypis Hlavne menu
  strcpy(lcd_dis[1], menu[0]);			//doplnene
  LCDstringXY(0, 1, lcd_dis[1], 16);					// na druhy riadok vypis prvu polozku
  for (i = 0; i < 4;) {
    146a:	f3 e0       	ldi	r31, 0x03	; 3
    146c:	ff 15       	cp	r31, r15
    146e:	08 f0       	brcs	.+2      	; 0x1472 <konfig_hodiny+0x1a4>
    1470:	59 cf       	rjmp	.-334    	; 0x1324 <konfig_hodiny+0x56>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
}
    1472:	df 91       	pop	r29
    1474:	cf 91       	pop	r28
    1476:	1f 91       	pop	r17
    1478:	0f 91       	pop	r16
    147a:	ff 90       	pop	r15
    147c:	df 90       	pop	r13
    147e:	cf 90       	pop	r12
    1480:	08 95       	ret

00001482 <ansi_cl>:
}
//----------------------------------------------------------------------
void ansi_cl(void)
{
  // ANSI clear screen: cl=\E[H\E[J
  putchar(27);
    1482:	60 91 4e 04 	lds	r22, 0x044E
    1486:	70 91 4f 04 	lds	r23, 0x044F
    148a:	8b e1       	ldi	r24, 0x1B	; 27
    148c:	90 e0       	ldi	r25, 0x00	; 0
    148e:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
  putchar('[');
    1492:	60 91 4e 04 	lds	r22, 0x044E
    1496:	70 91 4f 04 	lds	r23, 0x044F
    149a:	8b e5       	ldi	r24, 0x5B	; 91
    149c:	90 e0       	ldi	r25, 0x00	; 0
    149e:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
  putchar('H');
    14a2:	60 91 4e 04 	lds	r22, 0x044E
    14a6:	70 91 4f 04 	lds	r23, 0x044F
    14aa:	88 e4       	ldi	r24, 0x48	; 72
    14ac:	90 e0       	ldi	r25, 0x00	; 0
    14ae:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
  putchar(27);
    14b2:	60 91 4e 04 	lds	r22, 0x044E
    14b6:	70 91 4f 04 	lds	r23, 0x044F
    14ba:	8b e1       	ldi	r24, 0x1B	; 27
    14bc:	90 e0       	ldi	r25, 0x00	; 0
    14be:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
  putchar('[');
    14c2:	60 91 4e 04 	lds	r22, 0x044E
    14c6:	70 91 4f 04 	lds	r23, 0x044F
    14ca:	8b e5       	ldi	r24, 0x5B	; 91
    14cc:	90 e0       	ldi	r25, 0x00	; 0
    14ce:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
  putchar('J');
    14d2:	60 91 4e 04 	lds	r22, 0x044E
    14d6:	70 91 4f 04 	lds	r23, 0x044F
    14da:	8a e4       	ldi	r24, 0x4A	; 74
    14dc:	90 e0       	ldi	r25, 0x00	; 0
    14de:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
}
    14e2:	08 95       	ret

000014e4 <ansi_cm>:
//----------------------------------------------------------------------

void ansi_cm(unsigned char row,unsigned char col)
{
    14e4:	ef 92       	push	r14
    14e6:	ff 92       	push	r15
    14e8:	0f 93       	push	r16
    14ea:	1f 93       	push	r17
    14ec:	f8 2e       	mov	r15, r24
    14ee:	e6 2e       	mov	r14, r22
  // ANSI cursor movement: cl=\E%row;%colH
  putchar(27);
    14f0:	60 91 4e 04 	lds	r22, 0x044E
    14f4:	70 91 4f 04 	lds	r23, 0x044F
    14f8:	8b e1       	ldi	r24, 0x1B	; 27
    14fa:	90 e0       	ldi	r25, 0x00	; 0
    14fc:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
  putchar('[');
    1500:	60 91 4e 04 	lds	r22, 0x044E
    1504:	70 91 4f 04 	lds	r23, 0x044F
    1508:	8b e5       	ldi	r24, 0x5B	; 91
    150a:	90 e0       	ldi	r25, 0x00	; 0
    150c:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
  printf("%d",row);
    1510:	00 d0       	rcall	.+0      	; 0x1512 <ansi_cm+0x2e>
    1512:	00 d0       	rcall	.+0      	; 0x1514 <ansi_cm+0x30>
    1514:	ed b7       	in	r30, 0x3d	; 61
    1516:	fe b7       	in	r31, 0x3e	; 62
    1518:	31 96       	adiw	r30, 0x01	; 1
    151a:	08 e9       	ldi	r16, 0x98	; 152
    151c:	11 e0       	ldi	r17, 0x01	; 1
    151e:	ad b7       	in	r26, 0x3d	; 61
    1520:	be b7       	in	r27, 0x3e	; 62
    1522:	12 96       	adiw	r26, 0x02	; 2
    1524:	1c 93       	st	X, r17
    1526:	0e 93       	st	-X, r16
    1528:	11 97       	sbiw	r26, 0x01	; 1
    152a:	f2 82       	std	Z+2, r15	; 0x02
    152c:	13 82       	std	Z+3, r1	; 0x03
    152e:	0e 94 04 11 	call	0x2208	; 0x2208 <printf>
  putchar(';');
    1532:	0f 90       	pop	r0
    1534:	0f 90       	pop	r0
    1536:	0f 90       	pop	r0
    1538:	0f 90       	pop	r0
    153a:	60 91 4e 04 	lds	r22, 0x044E
    153e:	70 91 4f 04 	lds	r23, 0x044F
    1542:	8b e3       	ldi	r24, 0x3B	; 59
    1544:	90 e0       	ldi	r25, 0x00	; 0
    1546:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
  printf("%d",col);
    154a:	00 d0       	rcall	.+0      	; 0x154c <ansi_cm+0x68>
    154c:	00 d0       	rcall	.+0      	; 0x154e <ansi_cm+0x6a>
    154e:	ed b7       	in	r30, 0x3d	; 61
    1550:	fe b7       	in	r31, 0x3e	; 62
    1552:	31 96       	adiw	r30, 0x01	; 1
    1554:	ad b7       	in	r26, 0x3d	; 61
    1556:	be b7       	in	r27, 0x3e	; 62
    1558:	12 96       	adiw	r26, 0x02	; 2
    155a:	1c 93       	st	X, r17
    155c:	0e 93       	st	-X, r16
    155e:	11 97       	sbiw	r26, 0x01	; 1
    1560:	e2 82       	std	Z+2, r14	; 0x02
    1562:	13 82       	std	Z+3, r1	; 0x03
    1564:	0e 94 04 11 	call	0x2208	; 0x2208 <printf>
  putchar('H');
    1568:	0f 90       	pop	r0
    156a:	0f 90       	pop	r0
    156c:	0f 90       	pop	r0
    156e:	0f 90       	pop	r0
    1570:	60 91 4e 04 	lds	r22, 0x044E
    1574:	70 91 4f 04 	lds	r23, 0x044F
    1578:	88 e4       	ldi	r24, 0x48	; 72
    157a:	90 e0       	ldi	r25, 0x00	; 0
    157c:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
}
    1580:	1f 91       	pop	r17
    1582:	0f 91       	pop	r16
    1584:	ff 90       	pop	r15
    1586:	ef 90       	pop	r14
    1588:	08 95       	ret

0000158a <nastav4>:
  alarm.clock = _clock;
  LCDcursorOFF();cursor = 0;
}
//----------------------------------------------------------------------
void nastav4(void)
{
    158a:	af 92       	push	r10
    158c:	bf 92       	push	r11
    158e:	cf 92       	push	r12
    1590:	df 92       	push	r13
    1592:	ef 92       	push	r14
    1594:	ff 92       	push	r15
    1596:	0f 93       	push	r16
    1598:	1f 93       	push	r17
    159a:	df 93       	push	r29
    159c:	cf 93       	push	r28
    159e:	00 d0       	rcall	.+0      	; 0x15a0 <nastav4+0x16>
    15a0:	cd b7       	in	r28, 0x3d	; 61
    15a2:	de b7       	in	r29, 0x3e	; 62
  char _temp, _altemp;

  _temp = alarm.temp;
    15a4:	d0 90 23 04 	lds	r13, 0x0423
  LCDclr();
    15a8:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
  strcpy(lcd_dis[0], "Teplota: ");			//doplnene
    15ac:	8b ef       	ldi	r24, 0xFB	; 251
    15ae:	93 e0       	ldi	r25, 0x03	; 3
    15b0:	6b e9       	ldi	r22, 0x9B	; 155
    15b2:	71 e0       	ldi	r23, 0x01	; 1
    15b4:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  strcpy(lcd_dis[1], "                ");
    15b8:	1c e0       	ldi	r17, 0x0C	; 12
    15ba:	e1 2e       	mov	r14, r17
    15bc:	14 e0       	ldi	r17, 0x04	; 4
    15be:	f1 2e       	mov	r15, r17
    15c0:	c7 01       	movw	r24, r14
    15c2:	64 e2       	ldi	r22, 0x24	; 36
    15c4:	71 e0       	ldi	r23, 0x01	; 1
    15c6:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  LCDstringXY(0, 0, lcd_dis[0], 9);
    15ca:	80 e0       	ldi	r24, 0x00	; 0
    15cc:	60 e0       	ldi	r22, 0x00	; 0
    15ce:	a7 01       	movw	r20, r14
    15d0:	41 51       	subi	r20, 0x11	; 17
    15d2:	50 40       	sbci	r21, 0x00	; 0
    15d4:	29 e0       	ldi	r18, 0x09	; 9
    15d6:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    15da:	b8 ec       	ldi	r27, 0xC8	; 200
    15dc:	ab 2e       	mov	r10, r27
    15de:	b1 2c       	mov	r11, r1
	  strcpy(lcd_dis[0], "Teplota: Zapnute");	//doplnene
	  LCDstringXY(0, 0, lcd_dis[0], 16); 
	}
    if (bit_is_set(PINC, 1)) {
      cakaj(1);
	  _temp ^= 1;				// zakazat/povolit alram pre teplotu
    15e0:	11 e0       	ldi	r17, 0x01	; 1
  LCDclr();
  strcpy(lcd_dis[0], "Teplota: ");			//doplnene
  strcpy(lcd_dis[1], "                ");
  LCDstringXY(0, 0, lcd_dis[0], 9);
  while (1) {
    if (_temp == 0) {
    15e2:	dd 20       	and	r13, r13
    15e4:	29 f4       	brne	.+10     	; 0x15f0 <nastav4+0x66>
	  strcpy(lcd_dis[0], "Teplota: Vypnute");	//doplnene
    15e6:	8b ef       	ldi	r24, 0xFB	; 251
    15e8:	93 e0       	ldi	r25, 0x03	; 3
    15ea:	65 ea       	ldi	r22, 0xA5	; 165
    15ec:	71 e0       	ldi	r23, 0x01	; 1
    15ee:	04 c0       	rjmp	.+8      	; 0x15f8 <nastav4+0x6e>
	  LCDstringXY(0, 0, lcd_dis[0], 16);
	}
    else {
	  strcpy(lcd_dis[0], "Teplota: Zapnute");	//doplnene
    15f0:	8b ef       	ldi	r24, 0xFB	; 251
    15f2:	93 e0       	ldi	r25, 0x03	; 3
    15f4:	66 eb       	ldi	r22, 0xB6	; 182
    15f6:	71 e0       	ldi	r23, 0x01	; 1
    15f8:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	  LCDstringXY(0, 0, lcd_dis[0], 16); 
    15fc:	80 e0       	ldi	r24, 0x00	; 0
    15fe:	60 e0       	ldi	r22, 0x00	; 0
    1600:	4b ef       	ldi	r20, 0xFB	; 251
    1602:	53 e0       	ldi	r21, 0x03	; 3
    1604:	20 e1       	ldi	r18, 0x10	; 16
    1606:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	}
    if (bit_is_set(PINC, 1)) {
    160a:	31 9b       	sbis	0x06, 1	; 6
    160c:	0f c0       	rjmp	.+30     	; 0x162c <nastav4+0xa2>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    160e:	31 99       	sbic	0x06, 1	; 6
    1610:	fe cf       	rjmp	.-4      	; 0x160e <nastav4+0x84>
	  LCDstringXY(0, 0, lcd_dis[0], 16); 
	}
    if (bit_is_set(PINC, 1)) {
      cakaj(1);
	  _temp ^= 1;				// zakazat/povolit alram pre teplotu
	  LCDcistiXY(9, 0, 7);
    1612:	89 e0       	ldi	r24, 0x09	; 9
    1614:	60 e0       	ldi	r22, 0x00	; 0
    1616:	47 e0       	ldi	r20, 0x07	; 7
    1618:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    161c:	80 e2       	ldi	r24, 0x20	; 32
    161e:	93 e0       	ldi	r25, 0x03	; 3
    1620:	f5 01       	movw	r30, r10
    1622:	31 97       	sbiw	r30, 0x01	; 1
    1624:	f1 f7       	brne	.-4      	; 0x1622 <nastav4+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1626:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1628:	d9 f7       	brne	.-10     	; 0x1620 <nastav4+0x96>
	  strcpy(lcd_dis[0], "Teplota: Zapnute");	//doplnene
	  LCDstringXY(0, 0, lcd_dis[0], 16); 
	}
    if (bit_is_set(PINC, 1)) {
      cakaj(1);
	  _temp ^= 1;				// zakazat/povolit alram pre teplotu
    162a:	d1 26       	eor	r13, r17
	  LCDcistiXY(9, 0, 7);
	  _delay_ms(80);
    }
	if (bit_is_set(PINC, 2)) {
    162c:	32 9b       	sbis	0x06, 2	; 6
    162e:	0f c0       	rjmp	.+30     	; 0x164e <nastav4+0xc4>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1630:	32 99       	sbic	0x06, 2	; 6
    1632:	fe cf       	rjmp	.-4      	; 0x1630 <nastav4+0xa6>
	  _delay_ms(80);
    }
	if (bit_is_set(PINC, 2)) {
      cakaj(2);
	  _temp ^= 1;				// zakazat/povolit alram pre teplotu
	  LCDcistiXY(9, 0, 7);
    1634:	89 e0       	ldi	r24, 0x09	; 9
    1636:	60 e0       	ldi	r22, 0x00	; 0
    1638:	47 e0       	ldi	r20, 0x07	; 7
    163a:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    163e:	80 e2       	ldi	r24, 0x20	; 32
    1640:	93 e0       	ldi	r25, 0x03	; 3
    1642:	f5 01       	movw	r30, r10
    1644:	31 97       	sbiw	r30, 0x01	; 1
    1646:	f1 f7       	brne	.-4      	; 0x1644 <nastav4+0xba>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1648:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    164a:	d9 f7       	brne	.-10     	; 0x1642 <nastav4+0xb8>
	  LCDcistiXY(9, 0, 7);
	  _delay_ms(80);
    }
	if (bit_is_set(PINC, 2)) {
      cakaj(2);
	  _temp ^= 1;				// zakazat/povolit alram pre teplotu
    164c:	d1 26       	eor	r13, r17
	  LCDcistiXY(9, 0, 7);
	  _delay_ms(80);
    }
    if (bit_is_set(PINC, 0)) {
    164e:	30 9b       	sbis	0x06, 0	; 6
    1650:	06 c0       	rjmp	.+12     	; 0x165e <nastav4+0xd4>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1652:	30 99       	sbic	0x06, 0	; 6
    1654:	fe cf       	rjmp	.-4      	; 0x1652 <nastav4+0xc8>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
  if (_temp != 0) {
    1656:	dd 20       	and	r13, r13
    1658:	09 f4       	brne	.+2      	; 0x165c <nastav4+0xd2>
    165a:	aa c0       	rjmp	.+340    	; 0x17b0 <nastav4+0x226>
    165c:	05 c0       	rjmp	.+10     	; 0x1668 <nastav4+0xde>
    }
    if (bit_is_set(PINC, 0)) {
      cakaj(0);
	  break;
    }
	if (bit_is_set(PINC, 4)) {
    165e:	34 9b       	sbis	0x06, 4	; 6
    1660:	c0 cf       	rjmp	.-128    	; 0x15e2 <nastav4+0x58>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1662:	34 99       	sbic	0x06, 4	; 6
    1664:	fe cf       	rjmp	.-4      	; 0x1662 <nastav4+0xd8>
    1666:	a6 c0       	rjmp	.+332    	; 0x17b4 <nastav4+0x22a>
	  cakaj(4);
	  return;
	}
  }
  if (_temp != 0) {
    _altemp = p_alarm[3];
    1668:	e0 91 6b 02 	lds	r30, 0x026B
    166c:	f0 91 6c 02 	lds	r31, 0x026C
    1670:	03 81       	ldd	r16, Z+3	; 0x03
    sprintf(lcd_dis[1], "%02d\xdf", _altemp);			//doplnene
    1672:	00 d0       	rcall	.+0      	; 0x1674 <nastav4+0xea>
    1674:	00 d0       	rcall	.+0      	; 0x1676 <nastav4+0xec>
    1676:	00 d0       	rcall	.+0      	; 0x1678 <nastav4+0xee>
    1678:	ed b7       	in	r30, 0x3d	; 61
    167a:	fe b7       	in	r31, 0x3e	; 62
    167c:	31 96       	adiw	r30, 0x01	; 1
    167e:	ad b7       	in	r26, 0x3d	; 61
    1680:	be b7       	in	r27, 0x3e	; 62
    1682:	12 96       	adiw	r26, 0x02	; 2
    1684:	fc 92       	st	X, r15
    1686:	ee 92       	st	-X, r14
    1688:	11 97       	sbiw	r26, 0x01	; 1
    168a:	a7 ec       	ldi	r26, 0xC7	; 199
    168c:	aa 2e       	mov	r10, r26
    168e:	a1 e0       	ldi	r26, 0x01	; 1
    1690:	ba 2e       	mov	r11, r26
    1692:	b3 82       	std	Z+3, r11	; 0x03
    1694:	a2 82       	std	Z+2, r10	; 0x02
    1696:	04 83       	std	Z+4, r16	; 0x04
    1698:	15 82       	std	Z+5, r1	; 0x05
    169a:	0e 94 19 11 	call	0x2232	; 0x2232 <sprintf>
    LCDstringXY(0, 1, lcd_dis[1], 3); LCDsendChar('C');
    169e:	ed b7       	in	r30, 0x3d	; 61
    16a0:	fe b7       	in	r31, 0x3e	; 62
    16a2:	36 96       	adiw	r30, 0x06	; 6
    16a4:	0f b6       	in	r0, 0x3f	; 63
    16a6:	f8 94       	cli
    16a8:	fe bf       	out	0x3e, r31	; 62
    16aa:	0f be       	out	0x3f, r0	; 63
    16ac:	ed bf       	out	0x3d, r30	; 61
    16ae:	80 e0       	ldi	r24, 0x00	; 0
    16b0:	61 e0       	ldi	r22, 0x01	; 1
    16b2:	a7 01       	movw	r20, r14
    16b4:	23 e0       	ldi	r18, 0x03	; 3
    16b6:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    16ba:	83 e4       	ldi	r24, 0x43	; 67
    16bc:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
    while (1) {
	  if (bit_is_set(PINC, 1)) {
	    if (_altemp < 70)
	      _altemp++;
	    else _altemp = 0;
	    sprintf(lcd_dis[1], "%02d\xdf", _altemp);		//doplnene
    16c0:	ba 82       	std	Y+2, r11	; 0x02
    16c2:	a9 82       	std	Y+1, r10	; 0x01
    16c4:	c9 80       	ldd	r12, Y+1	; 0x01
    16c6:	1a 81       	ldd	r17, Y+2	; 0x02
    16c8:	78 ec       	ldi	r23, 0xC8	; 200
    16ca:	a7 2e       	mov	r10, r23
    16cc:	b1 2c       	mov	r11, r1
  if (_temp != 0) {
    _altemp = p_alarm[3];
    sprintf(lcd_dis[1], "%02d\xdf", _altemp);			//doplnene
    LCDstringXY(0, 1, lcd_dis[1], 3); LCDsendChar('C');
    while (1) {
	  if (bit_is_set(PINC, 1)) {
    16ce:	31 9b       	sbis	0x06, 1	; 6
    16d0:	2f c0       	rjmp	.+94     	; 0x1730 <nastav4+0x1a6>
	    if (_altemp < 70)
    16d2:	06 34       	cpi	r16, 0x46	; 70
    16d4:	10 f0       	brcs	.+4      	; 0x16da <nastav4+0x150>
    16d6:	00 e0       	ldi	r16, 0x00	; 0
    16d8:	01 c0       	rjmp	.+2      	; 0x16dc <nastav4+0x152>
	      _altemp++;
    16da:	0f 5f       	subi	r16, 0xFF	; 255
	    else _altemp = 0;
	    sprintf(lcd_dis[1], "%02d\xdf", _altemp);		//doplnene
    16dc:	00 d0       	rcall	.+0      	; 0x16de <nastav4+0x154>
    16de:	00 d0       	rcall	.+0      	; 0x16e0 <nastav4+0x156>
    16e0:	00 d0       	rcall	.+0      	; 0x16e2 <nastav4+0x158>
    16e2:	ed b7       	in	r30, 0x3d	; 61
    16e4:	fe b7       	in	r31, 0x3e	; 62
    16e6:	31 96       	adiw	r30, 0x01	; 1
    16e8:	ad b7       	in	r26, 0x3d	; 61
    16ea:	be b7       	in	r27, 0x3e	; 62
    16ec:	12 96       	adiw	r26, 0x02	; 2
    16ee:	fc 92       	st	X, r15
    16f0:	ee 92       	st	-X, r14
    16f2:	11 97       	sbiw	r26, 0x01	; 1
    16f4:	c2 82       	std	Z+2, r12	; 0x02
    16f6:	13 83       	std	Z+3, r17	; 0x03
    16f8:	04 83       	std	Z+4, r16	; 0x04
    16fa:	15 82       	std	Z+5, r1	; 0x05
    16fc:	0e 94 19 11 	call	0x2232	; 0x2232 <sprintf>
  	    LCDstringXY(0, 1, lcd_dis[1], 3); LCDsendChar('C');
    1700:	ed b7       	in	r30, 0x3d	; 61
    1702:	fe b7       	in	r31, 0x3e	; 62
    1704:	36 96       	adiw	r30, 0x06	; 6
    1706:	0f b6       	in	r0, 0x3f	; 63
    1708:	f8 94       	cli
    170a:	fe bf       	out	0x3e, r31	; 62
    170c:	0f be       	out	0x3f, r0	; 63
    170e:	ed bf       	out	0x3d, r30	; 61
    1710:	80 e0       	ldi	r24, 0x00	; 0
    1712:	61 e0       	ldi	r22, 0x01	; 1
    1714:	a7 01       	movw	r20, r14
    1716:	23 e0       	ldi	r18, 0x03	; 3
    1718:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    171c:	83 e4       	ldi	r24, 0x43	; 67
    171e:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
    1722:	88 ee       	ldi	r24, 0xE8	; 232
    1724:	93 e0       	ldi	r25, 0x03	; 3
    1726:	f5 01       	movw	r30, r10
    1728:	31 97       	sbiw	r30, 0x01	; 1
    172a:	f1 f7       	brne	.-4      	; 0x1728 <nastav4+0x19e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    172c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    172e:	d9 f7       	brne	.-10     	; 0x1726 <nastav4+0x19c>
	    _delay_ms(100);
	  }
	  if (bit_is_set(PINC, 2)) {
    1730:	32 9b       	sbis	0x06, 2	; 6
    1732:	2f c0       	rjmp	.+94     	; 0x1792 <nastav4+0x208>
	    if (_altemp > 0)
    1734:	00 23       	and	r16, r16
    1736:	11 f4       	brne	.+4      	; 0x173c <nastav4+0x1b2>
    1738:	06 e4       	ldi	r16, 0x46	; 70
    173a:	01 c0       	rjmp	.+2      	; 0x173e <nastav4+0x1b4>
	      _altemp--;
    173c:	01 50       	subi	r16, 0x01	; 1
	    else _altemp = 70;
	    sprintf(lcd_dis[1], "%02d\xdf", _altemp);		//doplnene
    173e:	00 d0       	rcall	.+0      	; 0x1740 <nastav4+0x1b6>
    1740:	00 d0       	rcall	.+0      	; 0x1742 <nastav4+0x1b8>
    1742:	00 d0       	rcall	.+0      	; 0x1744 <nastav4+0x1ba>
    1744:	ed b7       	in	r30, 0x3d	; 61
    1746:	fe b7       	in	r31, 0x3e	; 62
    1748:	31 96       	adiw	r30, 0x01	; 1
    174a:	ad b7       	in	r26, 0x3d	; 61
    174c:	be b7       	in	r27, 0x3e	; 62
    174e:	12 96       	adiw	r26, 0x02	; 2
    1750:	fc 92       	st	X, r15
    1752:	ee 92       	st	-X, r14
    1754:	11 97       	sbiw	r26, 0x01	; 1
    1756:	c2 82       	std	Z+2, r12	; 0x02
    1758:	13 83       	std	Z+3, r17	; 0x03
    175a:	04 83       	std	Z+4, r16	; 0x04
    175c:	15 82       	std	Z+5, r1	; 0x05
    175e:	0e 94 19 11 	call	0x2232	; 0x2232 <sprintf>
  	    LCDstringXY(0, 1, lcd_dis[1], 3); LCDsendChar('C');
    1762:	ed b7       	in	r30, 0x3d	; 61
    1764:	fe b7       	in	r31, 0x3e	; 62
    1766:	36 96       	adiw	r30, 0x06	; 6
    1768:	0f b6       	in	r0, 0x3f	; 63
    176a:	f8 94       	cli
    176c:	fe bf       	out	0x3e, r31	; 62
    176e:	0f be       	out	0x3f, r0	; 63
    1770:	ed bf       	out	0x3d, r30	; 61
    1772:	80 e0       	ldi	r24, 0x00	; 0
    1774:	61 e0       	ldi	r22, 0x01	; 1
    1776:	a7 01       	movw	r20, r14
    1778:	23 e0       	ldi	r18, 0x03	; 3
    177a:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    177e:	83 e4       	ldi	r24, 0x43	; 67
    1780:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
    1784:	88 ee       	ldi	r24, 0xE8	; 232
    1786:	93 e0       	ldi	r25, 0x03	; 3
    1788:	f5 01       	movw	r30, r10
    178a:	31 97       	sbiw	r30, 0x01	; 1
    178c:	f1 f7       	brne	.-4      	; 0x178a <nastav4+0x200>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    178e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1790:	d9 f7       	brne	.-10     	; 0x1788 <nastav4+0x1fe>
	    _delay_ms(100);
	  }
	  if (bit_is_set(PINC, 0)) {
    1792:	30 9b       	sbis	0x06, 0	; 6
    1794:	08 c0       	rjmp	.+16     	; 0x17a6 <nastav4+0x21c>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1796:	30 99       	sbic	0x06, 0	; 6
    1798:	fe cf       	rjmp	.-4      	; 0x1796 <nastav4+0x20c>
	  if (bit_is_set(PINC, 4)) {
	    cakaj(4);
		return;
	  }
    }
	p_alarm[3] = _altemp;
    179a:	e0 91 6b 02 	lds	r30, 0x026B
    179e:	f0 91 6c 02 	lds	r31, 0x026C
    17a2:	03 83       	std	Z+3, r16	; 0x03
    17a4:	05 c0       	rjmp	.+10     	; 0x17b0 <nastav4+0x226>
	  }
	  if (bit_is_set(PINC, 0)) {
	    cakaj(0);
	    break;
	  }
	  if (bit_is_set(PINC, 4)) {
    17a6:	34 9b       	sbis	0x06, 4	; 6
    17a8:	92 cf       	rjmp	.-220    	; 0x16ce <nastav4+0x144>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    17aa:	34 99       	sbic	0x06, 4	; 6
    17ac:	fe cf       	rjmp	.-4      	; 0x17aa <nastav4+0x220>
    17ae:	02 c0       	rjmp	.+4      	; 0x17b4 <nastav4+0x22a>
		return;
	  }
    }
	p_alarm[3] = _altemp;
  }
  alarm.temp = _temp;
    17b0:	d0 92 23 04 	sts	0x0423, r13
}
    17b4:	0f 90       	pop	r0
    17b6:	0f 90       	pop	r0
    17b8:	cf 91       	pop	r28
    17ba:	df 91       	pop	r29
    17bc:	1f 91       	pop	r17
    17be:	0f 91       	pop	r16
    17c0:	ff 90       	pop	r15
    17c2:	ef 90       	pop	r14
    17c4:	df 90       	pop	r13
    17c6:	cf 90       	pop	r12
    17c8:	bf 90       	pop	r11
    17ca:	af 90       	pop	r10
    17cc:	08 95       	ret

000017ce <nastav3>:
	}
  }
}
//----------------------------------------------------------------------
void nastav3(void)
{
    17ce:	6f 92       	push	r6
    17d0:	7f 92       	push	r7
    17d2:	8f 92       	push	r8
    17d4:	9f 92       	push	r9
    17d6:	af 92       	push	r10
    17d8:	bf 92       	push	r11
    17da:	cf 92       	push	r12
    17dc:	df 92       	push	r13
    17de:	ef 92       	push	r14
    17e0:	ff 92       	push	r15
    17e2:	0f 93       	push	r16
    17e4:	1f 93       	push	r17
    17e6:	df 93       	push	r29
    17e8:	cf 93       	push	r28
    17ea:	00 d0       	rcall	.+0      	; 0x17ec <nastav3+0x1e>
    17ec:	0f 92       	push	r0
    17ee:	cd b7       	in	r28, 0x3d	; 61
    17f0:	de b7       	in	r29, 0x3e	; 62
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    17f2:	30 99       	sbic	0x06, 0	; 6
    17f4:	fe cf       	rjmp	.-4      	; 0x17f2 <nastav3+0x24>
{
  unsigned char i, _clock;
  char _alarm[3];

  cakaj(0);
  _clock = alarm.clock;
    17f6:	e0 90 24 04 	lds	r14, 0x0424
  LCDclr();
    17fa:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
  strcpy(lcd_dis[0], "Cas: ");		//doplnene
    17fe:	8b ef       	ldi	r24, 0xFB	; 251
    1800:	93 e0       	ldi	r25, 0x03	; 3
    1802:	6d ec       	ldi	r22, 0xCD	; 205
    1804:	71 e0       	ldi	r23, 0x01	; 1
    1806:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  strcpy(lcd_dis[1], "               ");
    180a:	2c e0       	ldi	r18, 0x0C	; 12
    180c:	c2 2e       	mov	r12, r18
    180e:	24 e0       	ldi	r18, 0x04	; 4
    1810:	d2 2e       	mov	r13, r18
    1812:	c6 01       	movw	r24, r12
    1814:	63 ed       	ldi	r22, 0xD3	; 211
    1816:	71 e0       	ldi	r23, 0x01	; 1
    1818:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  LCDstringXY(0,0,lcd_dis[0], 5);		// tato funkcia je volana z funkcie nastav2(), sluzi pre nastavenie alarmu - casu
    181c:	80 e0       	ldi	r24, 0x00	; 0
    181e:	60 e0       	ldi	r22, 0x00	; 0
    1820:	a6 01       	movw	r20, r12
    1822:	41 51       	subi	r20, 0x11	; 17
    1824:	50 40       	sbci	r21, 0x00	; 0
    1826:	25 e0       	ldi	r18, 0x05	; 5
    1828:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    182c:	08 ec       	ldi	r16, 0xC8	; 200
    182e:	10 e0       	ldi	r17, 0x00	; 0
	  strcpy(lcd_dis[0], "Cas: Zapnute");	//doplnene
	  LCDstringXY(0,0,lcd_dis[0], 12); 
	}
	if (bit_is_set(PINC, 1)) {
	  cakaj(1);
	  _clock ^= 1;					// zakazat/povolit alram pre cas
    1830:	ff 24       	eor	r15, r15
    1832:	f3 94       	inc	r15
  LCDclr();
  strcpy(lcd_dis[0], "Cas: ");		//doplnene
  strcpy(lcd_dis[1], "               ");
  LCDstringXY(0,0,lcd_dis[0], 5);		// tato funkcia je volana z funkcie nastav2(), sluzi pre nastavenie alarmu - casu
  while (1) {
    if (_clock == 0) {
    1834:	ee 20       	and	r14, r14
    1836:	29 f4       	brne	.+10     	; 0x1842 <nastav3+0x74>
	  strcpy(lcd_dis[0], "Cas: Vypnute");	//doplnene
    1838:	8b ef       	ldi	r24, 0xFB	; 251
    183a:	93 e0       	ldi	r25, 0x03	; 3
    183c:	63 ee       	ldi	r22, 0xE3	; 227
    183e:	71 e0       	ldi	r23, 0x01	; 1
    1840:	04 c0       	rjmp	.+8      	; 0x184a <nastav3+0x7c>
      LCDstringXY(0,0,lcd_dis[0], 12);
	}
    else { 
	  strcpy(lcd_dis[0], "Cas: Zapnute");	//doplnene
    1842:	8b ef       	ldi	r24, 0xFB	; 251
    1844:	93 e0       	ldi	r25, 0x03	; 3
    1846:	60 ef       	ldi	r22, 0xF0	; 240
    1848:	71 e0       	ldi	r23, 0x01	; 1
    184a:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	  LCDstringXY(0,0,lcd_dis[0], 12); 
    184e:	80 e0       	ldi	r24, 0x00	; 0
    1850:	60 e0       	ldi	r22, 0x00	; 0
    1852:	4b ef       	ldi	r20, 0xFB	; 251
    1854:	53 e0       	ldi	r21, 0x03	; 3
    1856:	2c e0       	ldi	r18, 0x0C	; 12
    1858:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	}
	if (bit_is_set(PINC, 1)) {
    185c:	31 9b       	sbis	0x06, 1	; 6
    185e:	0f c0       	rjmp	.+30     	; 0x187e <nastav3+0xb0>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1860:	31 99       	sbic	0x06, 1	; 6
    1862:	fe cf       	rjmp	.-4      	; 0x1860 <nastav3+0x92>
	  LCDstringXY(0,0,lcd_dis[0], 12); 
	}
	if (bit_is_set(PINC, 1)) {
	  cakaj(1);
	  _clock ^= 1;					// zakazat/povolit alram pre cas
	  LCDcistiXY(5, 0, 7);
    1864:	85 e0       	ldi	r24, 0x05	; 5
    1866:	60 e0       	ldi	r22, 0x00	; 0
    1868:	47 e0       	ldi	r20, 0x07	; 7
    186a:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    186e:	80 e2       	ldi	r24, 0x20	; 32
    1870:	93 e0       	ldi	r25, 0x03	; 3
    1872:	f8 01       	movw	r30, r16
    1874:	31 97       	sbiw	r30, 0x01	; 1
    1876:	f1 f7       	brne	.-4      	; 0x1874 <nastav3+0xa6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1878:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    187a:	d9 f7       	brne	.-10     	; 0x1872 <nastav3+0xa4>
	  strcpy(lcd_dis[0], "Cas: Zapnute");	//doplnene
	  LCDstringXY(0,0,lcd_dis[0], 12); 
	}
	if (bit_is_set(PINC, 1)) {
	  cakaj(1);
	  _clock ^= 1;					// zakazat/povolit alram pre cas
    187c:	ef 24       	eor	r14, r15
	  LCDcistiXY(5, 0, 7);
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 2)) {
    187e:	32 9b       	sbis	0x06, 2	; 6
    1880:	0f c0       	rjmp	.+30     	; 0x18a0 <nastav3+0xd2>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1882:	32 99       	sbic	0x06, 2	; 6
    1884:	fe cf       	rjmp	.-4      	; 0x1882 <nastav3+0xb4>
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  _clock ^= 1;	
	  LCDcistiXY(5, 0, 7);
    1886:	85 e0       	ldi	r24, 0x05	; 5
    1888:	60 e0       	ldi	r22, 0x00	; 0
    188a:	47 e0       	ldi	r20, 0x07	; 7
    188c:	0e 94 15 03 	call	0x62a	; 0x62a <LCDcistiXY>
    1890:	80 e2       	ldi	r24, 0x20	; 32
    1892:	93 e0       	ldi	r25, 0x03	; 3
    1894:	f8 01       	movw	r30, r16
    1896:	31 97       	sbiw	r30, 0x01	; 1
    1898:	f1 f7       	brne	.-4      	; 0x1896 <nastav3+0xc8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    189a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    189c:	d9 f7       	brne	.-10     	; 0x1894 <nastav3+0xc6>
	  LCDcistiXY(5, 0, 7);
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 2)) {
	  cakaj(2);
	  _clock ^= 1;	
    189e:	ef 24       	eor	r14, r15
	  LCDcistiXY(5, 0, 7);
	  _delay_ms(80);
	}
	if (bit_is_set(PINC, 0)) {
    18a0:	30 9b       	sbis	0x06, 0	; 6
    18a2:	05 c0       	rjmp	.+10     	; 0x18ae <nastav3+0xe0>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    18a4:	30 99       	sbic	0x06, 0	; 6
    18a6:	fe cf       	rjmp	.-4      	; 0x18a4 <nastav3+0xd6>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
  if (_clock != 0) {
    18a8:	ee 20       	and	r14, r14
    18aa:	31 f4       	brne	.+12     	; 0x18b8 <nastav3+0xea>
    18ac:	36 c1       	rjmp	.+620    	; 0x1b1a <nastav3+0x34c>
	}
	if (bit_is_set(PINC, 0)) {
	  cakaj(0);
	  break;
	}
	if (bit_is_set(PINC, 4)) {
    18ae:	34 9b       	sbis	0x06, 4	; 6
    18b0:	c1 cf       	rjmp	.-126    	; 0x1834 <nastav3+0x66>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    18b2:	34 99       	sbic	0x06, 4	; 6
    18b4:	fe cf       	rjmp	.-4      	; 0x18b2 <nastav3+0xe4>
    18b6:	37 c1       	rjmp	.+622    	; 0x1b26 <nastav3+0x358>
	  return;
	}
  }
  if (_clock != 0) {
    for (i = 0; i < 3; i++)
	  _alarm[i] = p_alarm[i];
    18b8:	e0 91 6b 02 	lds	r30, 0x026B
    18bc:	f0 91 6c 02 	lds	r31, 0x026C
    18c0:	80 81       	ld	r24, Z
    18c2:	89 83       	std	Y+1, r24	; 0x01
    18c4:	91 81       	ldd	r25, Z+1	; 0x01
    18c6:	9a 83       	std	Y+2, r25	; 0x02
    18c8:	22 81       	ldd	r18, Z+2	; 0x02
    18ca:	2b 83       	std	Y+3, r18	; 0x03
    sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);		//doplnene
    18cc:	4d b7       	in	r20, 0x3d	; 61
    18ce:	5e b7       	in	r21, 0x3e	; 62
    18d0:	4a 50       	subi	r20, 0x0A	; 10
    18d2:	50 40       	sbci	r21, 0x00	; 0
    18d4:	0f b6       	in	r0, 0x3f	; 63
    18d6:	f8 94       	cli
    18d8:	5e bf       	out	0x3e, r21	; 62
    18da:	0f be       	out	0x3f, r0	; 63
    18dc:	4d bf       	out	0x3d, r20	; 61
    18de:	ed b7       	in	r30, 0x3d	; 61
    18e0:	fe b7       	in	r31, 0x3e	; 62
    18e2:	31 96       	adiw	r30, 0x01	; 1
    18e4:	ad b7       	in	r26, 0x3d	; 61
    18e6:	be b7       	in	r27, 0x3e	; 62
    18e8:	12 96       	adiw	r26, 0x02	; 2
    18ea:	dc 92       	st	X, r13
    18ec:	ce 92       	st	-X, r12
    18ee:	11 97       	sbiw	r26, 0x01	; 1
    18f0:	0d ef       	ldi	r16, 0xFD	; 253
    18f2:	11 e0       	ldi	r17, 0x01	; 1
    18f4:	13 83       	std	Z+3, r17	; 0x03
    18f6:	02 83       	std	Z+2, r16	; 0x02
    18f8:	84 83       	std	Z+4, r24	; 0x04
    18fa:	15 82       	std	Z+5, r1	; 0x05
    18fc:	96 83       	std	Z+6, r25	; 0x06
    18fe:	17 82       	std	Z+7, r1	; 0x07
    1900:	20 87       	std	Z+8, r18	; 0x08
    1902:	11 86       	std	Z+9, r1	; 0x09
    1904:	0e 94 19 11 	call	0x2232	; 0x2232 <sprintf>
	LCDstringXY(0, 1, lcd_dis[1], 8);
    1908:	4d b7       	in	r20, 0x3d	; 61
    190a:	5e b7       	in	r21, 0x3e	; 62
    190c:	46 5f       	subi	r20, 0xF6	; 246
    190e:	5f 4f       	sbci	r21, 0xFF	; 255
    1910:	0f b6       	in	r0, 0x3f	; 63
    1912:	f8 94       	cli
    1914:	5e bf       	out	0x3e, r21	; 62
    1916:	0f be       	out	0x3f, r0	; 63
    1918:	4d bf       	out	0x3d, r20	; 61
    191a:	80 e0       	ldi	r24, 0x00	; 0
    191c:	61 e0       	ldi	r22, 0x01	; 1
    191e:	a6 01       	movw	r20, r12
    1920:	28 e0       	ldi	r18, 0x08	; 8
    1922:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    1926:	ff 24       	eor	r15, r15
	for (i = 0; i < 3;) {
	  if (bit_is_set(PINC, 1)) {
	    if ((_alarm[i]) < ((i == 0) ? 0x23 : 0x59)) {
    1928:	5e 01       	movw	r10, r28
    192a:	08 94       	sec
    192c:	a1 1c       	adc	r10, r1
    192e:	b1 1c       	adc	r11, r1
		  (_alarm[i])++;
		  if ((bcdToDec(_alarm[i]) % 10) == 0)
		    (_alarm[i]) += 6;
		} else _alarm[i] = 0;
		LCDcursorOFF(); cursor = 0;
		sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);	//doplnene
    1930:	48 01       	movw	r8, r16
    1932:	08 ec       	ldi	r16, 0xC8	; 200
    1934:	10 e0       	ldi	r17, 0x00	; 0
	LCDstringXY(0, 1, lcd_dis[1], 8);
	for (i = 0; i < 3;) {
	  if (bit_is_set(PINC, 1)) {
	    if ((_alarm[i]) < ((i == 0) ? 0x23 : 0x59)) {
		  (_alarm[i])++;
		  if ((bcdToDec(_alarm[i]) % 10) == 0)
    1936:	9a e0       	ldi	r25, 0x0A	; 10
    1938:	79 2e       	mov	r7, r25
		sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);	//doplnene
		LCDstringXY(0, 1, lcd_dis[1], 8);
		_delay_ms(100);
	  }
	  LCDcursorOnBlink(); cursor = 1;
	  LCDGotoXY(1+(i*3),1);
    193a:	83 e0       	ldi	r24, 0x03	; 3
    193c:	68 2e       	mov	r6, r24
    for (i = 0; i < 3; i++)
	  _alarm[i] = p_alarm[i];
    sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);		//doplnene
	LCDstringXY(0, 1, lcd_dis[1], 8);
	for (i = 0; i < 3;) {
	  if (bit_is_set(PINC, 1)) {
    193e:	31 9b       	sbis	0x06, 1	; 6
    1940:	62 c0       	rjmp	.+196    	; 0x1a06 <nastav3+0x238>
	    if ((_alarm[i]) < ((i == 0) ? 0x23 : 0x59)) {
    1942:	af 2d       	mov	r26, r15
    1944:	b0 e0       	ldi	r27, 0x00	; 0
    1946:	f5 01       	movw	r30, r10
    1948:	ea 0f       	add	r30, r26
    194a:	fb 1f       	adc	r31, r27
    194c:	e0 81       	ld	r30, Z
    194e:	ff 20       	and	r15, r15
    1950:	19 f4       	brne	.+6      	; 0x1958 <nastav3+0x18a>
    1952:	23 e2       	ldi	r18, 0x23	; 35
    1954:	30 e0       	ldi	r19, 0x00	; 0
    1956:	02 c0       	rjmp	.+4      	; 0x195c <nastav3+0x18e>
    1958:	29 e5       	ldi	r18, 0x59	; 89
    195a:	30 e0       	ldi	r19, 0x00	; 0
    195c:	8e 2f       	mov	r24, r30
    195e:	90 e0       	ldi	r25, 0x00	; 0
    1960:	82 17       	cp	r24, r18
    1962:	93 07       	cpc	r25, r19
    1964:	ac f4       	brge	.+42     	; 0x1990 <nastav3+0x1c2>
		  (_alarm[i])++;
    1966:	8e 2f       	mov	r24, r30
    1968:	8f 5f       	subi	r24, 0xFF	; 255
    196a:	aa 0d       	add	r26, r10
    196c:	bb 1d       	adc	r27, r11
    196e:	8c 93       	st	X, r24
		  if ((bcdToDec(_alarm[i]) % 10) == 0)
    1970:	28 2f       	mov	r18, r24
    1972:	22 95       	swap	r18
    1974:	2f 70       	andi	r18, 0x0F	; 15
    1976:	27 9d       	mul	r18, r7
    1978:	90 01       	movw	r18, r0
    197a:	11 24       	eor	r1, r1
    197c:	8f 70       	andi	r24, 0x0F	; 15
    197e:	82 0f       	add	r24, r18
    1980:	6a e0       	ldi	r22, 0x0A	; 10
    1982:	0e 94 8e 13 	call	0x271c	; 0x271c <__udivmodqi4>
    1986:	99 23       	and	r25, r25
    1988:	31 f4       	brne	.+12     	; 0x1996 <nastav3+0x1c8>
		    (_alarm[i]) += 6;
    198a:	e9 5f       	subi	r30, 0xF9	; 249
    198c:	ec 93       	st	X, r30
    198e:	03 c0       	rjmp	.+6      	; 0x1996 <nastav3+0x1c8>
		} else _alarm[i] = 0;
    1990:	aa 0d       	add	r26, r10
    1992:	bb 1d       	adc	r27, r11
    1994:	1c 92       	st	X, r1
		LCDcursorOFF(); cursor = 0;
    1996:	0e 94 5f 02 	call	0x4be	; 0x4be <LCDcursorOFF>
    199a:	10 92 28 04 	sts	0x0428, r1
		sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);	//doplnene
    199e:	8d b7       	in	r24, 0x3d	; 61
    19a0:	9e b7       	in	r25, 0x3e	; 62
    19a2:	0a 97       	sbiw	r24, 0x0a	; 10
    19a4:	0f b6       	in	r0, 0x3f	; 63
    19a6:	f8 94       	cli
    19a8:	9e bf       	out	0x3e, r25	; 62
    19aa:	0f be       	out	0x3f, r0	; 63
    19ac:	8d bf       	out	0x3d, r24	; 61
    19ae:	ed b7       	in	r30, 0x3d	; 61
    19b0:	fe b7       	in	r31, 0x3e	; 62
    19b2:	31 96       	adiw	r30, 0x01	; 1
    19b4:	ad b7       	in	r26, 0x3d	; 61
    19b6:	be b7       	in	r27, 0x3e	; 62
    19b8:	12 96       	adiw	r26, 0x02	; 2
    19ba:	dc 92       	st	X, r13
    19bc:	ce 92       	st	-X, r12
    19be:	11 97       	sbiw	r26, 0x01	; 1
    19c0:	82 82       	std	Z+2, r8	; 0x02
    19c2:	93 82       	std	Z+3, r9	; 0x03
    19c4:	89 81       	ldd	r24, Y+1	; 0x01
    19c6:	84 83       	std	Z+4, r24	; 0x04
    19c8:	15 82       	std	Z+5, r1	; 0x05
    19ca:	8a 81       	ldd	r24, Y+2	; 0x02
    19cc:	86 83       	std	Z+6, r24	; 0x06
    19ce:	17 82       	std	Z+7, r1	; 0x07
    19d0:	8b 81       	ldd	r24, Y+3	; 0x03
    19d2:	80 87       	std	Z+8, r24	; 0x08
    19d4:	11 86       	std	Z+9, r1	; 0x09
    19d6:	0e 94 19 11 	call	0x2232	; 0x2232 <sprintf>
		LCDstringXY(0, 1, lcd_dis[1], 8);
    19da:	4d b7       	in	r20, 0x3d	; 61
    19dc:	5e b7       	in	r21, 0x3e	; 62
    19de:	46 5f       	subi	r20, 0xF6	; 246
    19e0:	5f 4f       	sbci	r21, 0xFF	; 255
    19e2:	0f b6       	in	r0, 0x3f	; 63
    19e4:	f8 94       	cli
    19e6:	5e bf       	out	0x3e, r21	; 62
    19e8:	0f be       	out	0x3f, r0	; 63
    19ea:	4d bf       	out	0x3d, r20	; 61
    19ec:	80 e0       	ldi	r24, 0x00	; 0
    19ee:	61 e0       	ldi	r22, 0x01	; 1
    19f0:	a6 01       	movw	r20, r12
    19f2:	28 e0       	ldi	r18, 0x08	; 8
    19f4:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    19f8:	88 ee       	ldi	r24, 0xE8	; 232
    19fa:	93 e0       	ldi	r25, 0x03	; 3
    19fc:	f8 01       	movw	r30, r16
    19fe:	31 97       	sbiw	r30, 0x01	; 1
    1a00:	f1 f7       	brne	.-4      	; 0x19fe <nastav3+0x230>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a02:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a04:	d9 f7       	brne	.-10     	; 0x19fc <nastav3+0x22e>
		_delay_ms(100);
	  }
	  if (bit_is_set(PINC, 2)) {
    1a06:	32 9b       	sbis	0x06, 2	; 6
    1a08:	5c c0       	rjmp	.+184    	; 0x1ac2 <nastav3+0x2f4>
	    if (_alarm[i] > 0) {
    1a0a:	ef 2d       	mov	r30, r15
    1a0c:	f0 e0       	ldi	r31, 0x00	; 0
    1a0e:	d5 01       	movw	r26, r10
    1a10:	ae 0f       	add	r26, r30
    1a12:	bf 1f       	adc	r27, r31
    1a14:	4c 91       	ld	r20, X
    1a16:	44 23       	and	r20, r20
    1a18:	a1 f0       	breq	.+40     	; 0x1a42 <nastav3+0x274>
		  if ((bcdToDec(_alarm[i]--) % 10) == 0)
    1a1a:	41 50       	subi	r20, 0x01	; 1
    1a1c:	4c 93       	st	X, r20
    1a1e:	4f 5f       	subi	r20, 0xFF	; 255
    1a20:	24 2f       	mov	r18, r20
    1a22:	22 95       	swap	r18
    1a24:	2f 70       	andi	r18, 0x0F	; 15
    1a26:	27 9d       	mul	r18, r7
    1a28:	90 01       	movw	r18, r0
    1a2a:	11 24       	eor	r1, r1
    1a2c:	84 2f       	mov	r24, r20
    1a2e:	8f 70       	andi	r24, 0x0F	; 15
    1a30:	82 0f       	add	r24, r18
    1a32:	6a e0       	ldi	r22, 0x0A	; 10
    1a34:	0e 94 8e 13 	call	0x271c	; 0x271c <__udivmodqi4>
    1a38:	99 23       	and	r25, r25
    1a3a:	59 f4       	brne	.+22     	; 0x1a52 <nastav3+0x284>
		    (_alarm[i]) -= 6;
    1a3c:	47 50       	subi	r20, 0x07	; 7
    1a3e:	4c 93       	st	X, r20
    1a40:	08 c0       	rjmp	.+16     	; 0x1a52 <nastav3+0x284>
		} else { _alarm[i] = (i == 0) ? 0x23 : 0x59;}
    1a42:	ff 20       	and	r15, r15
    1a44:	11 f0       	breq	.+4      	; 0x1a4a <nastav3+0x27c>
    1a46:	89 e5       	ldi	r24, 0x59	; 89
    1a48:	01 c0       	rjmp	.+2      	; 0x1a4c <nastav3+0x27e>
    1a4a:	83 e2       	ldi	r24, 0x23	; 35
    1a4c:	ea 0d       	add	r30, r10
    1a4e:	fb 1d       	adc	r31, r11
    1a50:	80 83       	st	Z, r24
	    LCDcursorOFF(); cursor = 0;
    1a52:	0e 94 5f 02 	call	0x4be	; 0x4be <LCDcursorOFF>
    1a56:	10 92 28 04 	sts	0x0428, r1
		sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);	//doplnene
    1a5a:	8d b7       	in	r24, 0x3d	; 61
    1a5c:	9e b7       	in	r25, 0x3e	; 62
    1a5e:	0a 97       	sbiw	r24, 0x0a	; 10
    1a60:	0f b6       	in	r0, 0x3f	; 63
    1a62:	f8 94       	cli
    1a64:	9e bf       	out	0x3e, r25	; 62
    1a66:	0f be       	out	0x3f, r0	; 63
    1a68:	8d bf       	out	0x3d, r24	; 61
    1a6a:	ed b7       	in	r30, 0x3d	; 61
    1a6c:	fe b7       	in	r31, 0x3e	; 62
    1a6e:	31 96       	adiw	r30, 0x01	; 1
    1a70:	ad b7       	in	r26, 0x3d	; 61
    1a72:	be b7       	in	r27, 0x3e	; 62
    1a74:	12 96       	adiw	r26, 0x02	; 2
    1a76:	dc 92       	st	X, r13
    1a78:	ce 92       	st	-X, r12
    1a7a:	11 97       	sbiw	r26, 0x01	; 1
    1a7c:	82 82       	std	Z+2, r8	; 0x02
    1a7e:	93 82       	std	Z+3, r9	; 0x03
    1a80:	89 81       	ldd	r24, Y+1	; 0x01
    1a82:	84 83       	std	Z+4, r24	; 0x04
    1a84:	15 82       	std	Z+5, r1	; 0x05
    1a86:	8a 81       	ldd	r24, Y+2	; 0x02
    1a88:	86 83       	std	Z+6, r24	; 0x06
    1a8a:	17 82       	std	Z+7, r1	; 0x07
    1a8c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a8e:	80 87       	std	Z+8, r24	; 0x08
    1a90:	11 86       	std	Z+9, r1	; 0x09
    1a92:	0e 94 19 11 	call	0x2232	; 0x2232 <sprintf>
		LCDstringXY(0, 1, lcd_dis[1], 8);
    1a96:	4d b7       	in	r20, 0x3d	; 61
    1a98:	5e b7       	in	r21, 0x3e	; 62
    1a9a:	46 5f       	subi	r20, 0xF6	; 246
    1a9c:	5f 4f       	sbci	r21, 0xFF	; 255
    1a9e:	0f b6       	in	r0, 0x3f	; 63
    1aa0:	f8 94       	cli
    1aa2:	5e bf       	out	0x3e, r21	; 62
    1aa4:	0f be       	out	0x3f, r0	; 63
    1aa6:	4d bf       	out	0x3d, r20	; 61
    1aa8:	80 e0       	ldi	r24, 0x00	; 0
    1aaa:	61 e0       	ldi	r22, 0x01	; 1
    1aac:	a6 01       	movw	r20, r12
    1aae:	28 e0       	ldi	r18, 0x08	; 8
    1ab0:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
    1ab4:	88 ee       	ldi	r24, 0xE8	; 232
    1ab6:	93 e0       	ldi	r25, 0x03	; 3
    1ab8:	f8 01       	movw	r30, r16
    1aba:	31 97       	sbiw	r30, 0x01	; 1
    1abc:	f1 f7       	brne	.-4      	; 0x1aba <nastav3+0x2ec>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1abe:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ac0:	d9 f7       	brne	.-10     	; 0x1ab8 <nastav3+0x2ea>
		_delay_ms(100);
	  }
	  LCDcursorOnBlink(); cursor = 1;
    1ac2:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <LCDcursorOnBlink>
    1ac6:	81 e0       	ldi	r24, 0x01	; 1
    1ac8:	80 93 28 04 	sts	0x0428, r24
	  LCDGotoXY(1+(i*3),1);
    1acc:	f6 9c       	mul	r15, r6
    1ace:	c0 01       	movw	r24, r0
    1ad0:	11 24       	eor	r1, r1
    1ad2:	8f 5f       	subi	r24, 0xFF	; 255
    1ad4:	61 e0       	ldi	r22, 0x01	; 1
    1ad6:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>

	  if (bit_is_set(PINC, 0)) {
    1ada:	30 9b       	sbis	0x06, 0	; 6
    1adc:	03 c0       	rjmp	.+6      	; 0x1ae4 <nastav3+0x316>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1ade:	30 99       	sbic	0x06, 0	; 6
    1ae0:	fe cf       	rjmp	.-4      	; 0x1ade <nastav3+0x310>
	  LCDcursorOnBlink(); cursor = 1;
	  LCDGotoXY(1+(i*3),1);

	  if (bit_is_set(PINC, 0)) {
	    cakaj(0);
		i++;
    1ae2:	f3 94       	inc	r15
	  }
	  if (bit_is_set(PINC, 4)) {
    1ae4:	34 9b       	sbis	0x06, 4	; 6
    1ae6:	03 c0       	rjmp	.+6      	; 0x1aee <nastav3+0x320>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1ae8:	34 99       	sbic	0x06, 4	; 6
    1aea:	fe cf       	rjmp	.-4      	; 0x1ae8 <nastav3+0x31a>
    1aec:	18 c0       	rjmp	.+48     	; 0x1b1e <nastav3+0x350>
  if (_clock != 0) {
    for (i = 0; i < 3; i++)
	  _alarm[i] = p_alarm[i];
    sprintf(lcd_dis[1], "%02x:%02x:%02x", _alarm[0], _alarm[1], _alarm[2]);		//doplnene
	LCDstringXY(0, 1, lcd_dis[1], 8);
	for (i = 0; i < 3;) {
    1aee:	52 e0       	ldi	r21, 0x02	; 2
    1af0:	5f 15       	cp	r21, r15
    1af2:	08 f0       	brcs	.+2      	; 0x1af6 <nastav3+0x328>
    1af4:	24 cf       	rjmp	.-440    	; 0x193e <nastav3+0x170>
		LCDcursorOFF(); cursor = 0;
		return;
	  }
	}
	for (i = 0; i < 3; i++)
	  p_alarm[i] = _alarm[i];
    1af6:	e0 91 6b 02 	lds	r30, 0x026B
    1afa:	f0 91 6c 02 	lds	r31, 0x026C
    1afe:	89 81       	ldd	r24, Y+1	; 0x01
    1b00:	80 83       	st	Z, r24
    1b02:	e0 91 6b 02 	lds	r30, 0x026B
    1b06:	f0 91 6c 02 	lds	r31, 0x026C
    1b0a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b0c:	81 83       	std	Z+1, r24	; 0x01
    1b0e:	e0 91 6b 02 	lds	r30, 0x026B
    1b12:	f0 91 6c 02 	lds	r31, 0x026C
    1b16:	8b 81       	ldd	r24, Y+3	; 0x03
    1b18:	82 83       	std	Z+2, r24	; 0x02
  }
  alarm.clock = _clock;
    1b1a:	e0 92 24 04 	sts	0x0424, r14
  LCDcursorOFF();cursor = 0;
    1b1e:	0e 94 5f 02 	call	0x4be	; 0x4be <LCDcursorOFF>
    1b22:	10 92 28 04 	sts	0x0428, r1
}
    1b26:	0f 90       	pop	r0
    1b28:	0f 90       	pop	r0
    1b2a:	0f 90       	pop	r0
    1b2c:	cf 91       	pop	r28
    1b2e:	df 91       	pop	r29
    1b30:	1f 91       	pop	r17
    1b32:	0f 91       	pop	r16
    1b34:	ff 90       	pop	r15
    1b36:	ef 90       	pop	r14
    1b38:	df 90       	pop	r13
    1b3a:	cf 90       	pop	r12
    1b3c:	bf 90       	pop	r11
    1b3e:	af 90       	pop	r10
    1b40:	9f 90       	pop	r9
    1b42:	8f 90       	pop	r8
    1b44:	7f 90       	pop	r7
    1b46:	6f 90       	pop	r6
    1b48:	08 95       	ret

00001b4a <nastav_extra>:
  return 0;
}
//----------------------------------------------------------------------
char nastav_extra(void)
{
  nastav1();
    1b4a:	0e 94 06 09 	call	0x120c	; 0x120c <nastav1>
  stav |= 2;			// nesnimaj pocas nastavovania - alarm
    1b4e:	80 91 f8 03 	lds	r24, 0x03F8
    1b52:	82 60       	ori	r24, 0x02	; 2
    1b54:	80 93 f8 03 	sts	0x03F8, r24
  nastav2();
    1b58:	0e 94 a7 08 	call	0x114e	; 0x114e <nastav2>
  if (alarm.al_flag == 1) {
    1b5c:	80 91 25 04 	lds	r24, 0x0425
    1b60:	81 30       	cpi	r24, 0x01	; 1
    1b62:	21 f4       	brne	.+8      	; 0x1b6c <nastav_extra+0x22>
    nastav3();
    1b64:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <nastav3>
    nastav4();
    1b68:	0e 94 c5 0a 	call	0x158a	; 0x158a <nastav4>
  }
  if ((alarm.al_flag == 1) && ((alarm.clock == 1) || (alarm.temp == 1)) )
    1b6c:	80 91 25 04 	lds	r24, 0x0425
    1b70:	81 30       	cpi	r24, 0x01	; 1
    1b72:	51 f4       	brne	.+20     	; 0x1b88 <nastav_extra+0x3e>
    1b74:	80 91 24 04 	lds	r24, 0x0424
    1b78:	81 30       	cpi	r24, 0x01	; 1
    1b7a:	21 f0       	breq	.+8      	; 0x1b84 <nastav_extra+0x3a>
    1b7c:	80 91 23 04 	lds	r24, 0x0423
    1b80:	81 30       	cpi	r24, 0x01	; 1
    1b82:	11 f4       	brne	.+4      	; 0x1b88 <nastav_extra+0x3e>
    nastav5();
    1b84:	0e 94 1f 08 	call	0x103e	; 0x103e <nastav5>
  stav &= ~2;
    1b88:	80 91 f8 03 	lds	r24, 0x03F8
    1b8c:	8d 7f       	andi	r24, 0xFD	; 253
    1b8e:	80 93 f8 03 	sts	0x03F8, r24
  return 0;
}
    1b92:	80 e0       	ldi	r24, 0x00	; 0
    1b94:	08 95       	ret

00001b96 <nastav>:
  LCDGotoXY(0,1);
  LCDstring(lcd_dis[1], strlen(lcd_dis[1]));
}
//----------------------------------------------------------------------
void nastav(char str_ud[], char val, char addr)		// (hodnota zo struktury, prislusny retazec, max zobrazena hodnota, adresa (na zapis))
{
    1b96:	4f 92       	push	r4
    1b98:	5f 92       	push	r5
    1b9a:	6f 92       	push	r6
    1b9c:	7f 92       	push	r7
    1b9e:	8f 92       	push	r8
    1ba0:	9f 92       	push	r9
    1ba2:	af 92       	push	r10
    1ba4:	bf 92       	push	r11
    1ba6:	cf 92       	push	r12
    1ba8:	df 92       	push	r13
    1baa:	ef 92       	push	r14
    1bac:	ff 92       	push	r15
    1bae:	0f 93       	push	r16
    1bb0:	1f 93       	push	r17
    1bb2:	df 93       	push	r29
    1bb4:	cf 93       	push	r28
    1bb6:	0f 92       	push	r0
    1bb8:	cd b7       	in	r28, 0x3d	; 61
    1bba:	de b7       	in	r29, 0x3e	; 62
    1bbc:	3c 01       	movw	r6, r24
    1bbe:	f6 2e       	mov	r15, r22
    1bc0:	04 2f       	mov	r16, r20
    1bc2:	e0 91 6d 02 	lds	r30, 0x026D
    1bc6:	f0 91 6e 02 	lds	r31, 0x026E
  char p_udaj;
  p_udaj = (addr != 0) ? p_udaje[addr] : p_udaje[addr]&0x7f;
    1bca:	44 23       	and	r20, r20
    1bcc:	31 f0       	breq	.+12     	; 0x1bda <nastav+0x44>
    1bce:	e4 0f       	add	r30, r20
    1bd0:	f1 1d       	adc	r31, r1
    1bd2:	10 81       	ld	r17, Z
  if (addr == 4)													// Ak nastavujem den 
    1bd4:	44 30       	cpi	r20, 0x04	; 4
    1bd6:	21 f0       	breq	.+8      	; 0x1be0 <nastav+0x4a>
    1bd8:	2a c0       	rjmp	.+84     	; 0x1c2e <nastav+0x98>
}
//----------------------------------------------------------------------
void nastav(char str_ud[], char val, char addr)		// (hodnota zo struktury, prislusny retazec, max zobrazena hodnota, adresa (na zapis))
{
  char p_udaj;
  p_udaj = (addr != 0) ? p_udaje[addr] : p_udaje[addr]&0x7f;
    1bda:	10 81       	ld	r17, Z
    1bdc:	1f 77       	andi	r17, 0x7F	; 127
    1bde:	27 c0       	rjmp	.+78     	; 0x1c2e <nastav+0x98>
  if (addr == 4)													// Ak nastavujem den 
    if (p_udaj > pct_dni[bcdToDec(udaje.mes)-1]) {				// zisti ci je pocet dni vacsi ako celkovy pocet v danom mesiaci
    1be0:	40 91 38 04 	lds	r20, 0x0438
    1be4:	84 2f       	mov	r24, r20
    1be6:	82 95       	swap	r24
    1be8:	8f 70       	andi	r24, 0x0F	; 15
    1bea:	3a e0       	ldi	r19, 0x0A	; 10
    1bec:	83 9f       	mul	r24, r19
    1bee:	c0 01       	movw	r24, r0
    1bf0:	11 24       	eor	r1, r1
    1bf2:	e4 2f       	mov	r30, r20
    1bf4:	ef 70       	andi	r30, 0x0F	; 15
    1bf6:	e8 0f       	add	r30, r24
    1bf8:	f0 e0       	ldi	r31, 0x00	; 0
    1bfa:	ea 5e       	subi	r30, 0xEA	; 234
    1bfc:	fc 4f       	sbci	r31, 0xFC	; 252
    1bfe:	e0 81       	ld	r30, Z
    1c00:	e1 17       	cp	r30, r17
    1c02:	a8 f4       	brcc	.+42     	; 0x1c2e <nastav+0x98>
	  p_udaj = pct_dni[bcdToDec(udaje.mes)-1];						// pokial je vacsi nastav max. pocet dni a
	  if (((bcdToDec(udaje.rok) % 4) == 0) && (udaje.mes == 2)) 	// pokial je februar a priestupny rok tak este zvys den
    1c04:	80 91 39 04 	lds	r24, 0x0439
    1c08:	28 2f       	mov	r18, r24
    1c0a:	22 95       	swap	r18
    1c0c:	2f 70       	andi	r18, 0x0F	; 15
    1c0e:	23 9f       	mul	r18, r19
    1c10:	90 01       	movw	r18, r0
    1c12:	11 24       	eor	r1, r1
    1c14:	8f 70       	andi	r24, 0x0F	; 15
    1c16:	82 0f       	add	r24, r18
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	83 70       	andi	r24, 0x03	; 3
    1c1c:	90 70       	andi	r25, 0x00	; 0
    1c1e:	89 2b       	or	r24, r25
    1c20:	29 f4       	brne	.+10     	; 0x1c2c <nastav+0x96>
    1c22:	42 30       	cpi	r20, 0x02	; 2
    1c24:	19 f4       	brne	.+6      	; 0x1c2c <nastav+0x96>
	    p_udaj++;												// jedna sa o strukturu (nie o zobrazovacie hodnoty)
    1c26:	1e 2f       	mov	r17, r30
    1c28:	1f 5f       	subi	r17, 0xFF	; 255
    1c2a:	01 c0       	rjmp	.+2      	; 0x1c2e <nastav+0x98>
    1c2c:	1e 2f       	mov	r17, r30
    1c2e:	4f 2c       	mov	r4, r15
    1c30:	55 24       	eor	r5, r5
	}
  while (1) {
  	LCDGotoXY(0,1);
    sprintf(lcd_dis[1], str_ud, p_udaj, (addr == 0) ? val&0x7f : val);	// vyplnenie str_pis (o max hodnoty val-pom)
    1c32:	6f e7       	ldi	r22, 0x7F	; 127
    1c34:	c6 2e       	mov	r12, r22
    1c36:	d1 2c       	mov	r13, r1
    1c38:	c4 20       	and	r12, r4
    1c3a:	d5 20       	and	r13, r5
    1c3c:	5c e0       	ldi	r21, 0x0C	; 12
    1c3e:	85 2e       	mov	r8, r21
    1c40:	54 e0       	ldi	r21, 0x04	; 4
    1c42:	95 2e       	mov	r9, r21
    1c44:	48 ec       	ldi	r20, 0xC8	; 200
    1c46:	a4 2e       	mov	r10, r20
    1c48:	b1 2c       	mov	r11, r1
	if (bit_is_set(PINC, 1)) {										// zvacsovanie hodnoty pri stlacani tlacitka 1
	  if (p_udaj < val) {									
	    p_udaj++;
	    if ((bcdToDec(p_udaj) % 10) == 0)							//osetrenie hex cislic na BCD (vynechanie pismen pricitanim 6)
		  p_udaj += 6;	
	  } else p_udaj = ((addr == 5)||(addr == 4)) ? 1 : 0;		//pokial je Den a Mesiac nastav min na 1 (inak zacinaj od nuly)
    1c4a:	40 2f       	mov	r20, r16
    1c4c:	44 50       	subi	r20, 0x04	; 4
    1c4e:	49 83       	std	Y+1, r20	; 0x01
    sprintf(lcd_dis[1], str_ud, p_udaj, (addr == 0) ? val&0x7f : val);	// vyplnenie str_pis (o max hodnoty val-pom)
	LCDstring(lcd_dis[1], 16);											//16 znakov kvoli >
	if (bit_is_set(PINC, 1)) {										// zvacsovanie hodnoty pri stlacani tlacitka 1
	  if (p_udaj < val) {									
	    p_udaj++;
	    if ((bcdToDec(p_udaj) % 10) == 0)							//osetrenie hex cislic na BCD (vynechanie pismen pricitanim 6)
    1c50:	3a e0       	ldi	r19, 0x0A	; 10
    1c52:	e3 2e       	mov	r14, r19
	  p_udaj = pct_dni[bcdToDec(udaje.mes)-1];						// pokial je vacsi nastav max. pocet dni a
	  if (((bcdToDec(udaje.rok) % 4) == 0) && (udaje.mes == 2)) 	// pokial je februar a priestupny rok tak este zvys den
	    p_udaj++;												// jedna sa o strukturu (nie o zobrazovacie hodnoty)
	}
  while (1) {
  	LCDGotoXY(0,1);
    1c54:	80 e0       	ldi	r24, 0x00	; 0
    1c56:	61 e0       	ldi	r22, 0x01	; 1
    1c58:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
    sprintf(lcd_dis[1], str_ud, p_udaj, (addr == 0) ? val&0x7f : val);	// vyplnenie str_pis (o max hodnoty val-pom)
    1c5c:	00 23       	and	r16, r16
    1c5e:	11 f4       	brne	.+4      	; 0x1c64 <nastav+0xce>
    1c60:	c6 01       	movw	r24, r12
    1c62:	01 c0       	rjmp	.+2      	; 0x1c66 <nastav+0xd0>
    1c64:	c2 01       	movw	r24, r4
    1c66:	28 2f       	mov	r18, r24
    1c68:	ad b7       	in	r26, 0x3d	; 61
    1c6a:	be b7       	in	r27, 0x3e	; 62
    1c6c:	18 97       	sbiw	r26, 0x08	; 8
    1c6e:	0f b6       	in	r0, 0x3f	; 63
    1c70:	f8 94       	cli
    1c72:	be bf       	out	0x3e, r27	; 62
    1c74:	0f be       	out	0x3f, r0	; 63
    1c76:	ad bf       	out	0x3d, r26	; 61
    1c78:	ed b7       	in	r30, 0x3d	; 61
    1c7a:	fe b7       	in	r31, 0x3e	; 62
    1c7c:	31 96       	adiw	r30, 0x01	; 1
    1c7e:	12 96       	adiw	r26, 0x02	; 2
    1c80:	9c 92       	st	X, r9
    1c82:	8e 92       	st	-X, r8
    1c84:	11 97       	sbiw	r26, 0x01	; 1
    1c86:	73 82       	std	Z+3, r7	; 0x03
    1c88:	62 82       	std	Z+2, r6	; 0x02
    1c8a:	14 83       	std	Z+4, r17	; 0x04
    1c8c:	15 82       	std	Z+5, r1	; 0x05
    1c8e:	26 83       	std	Z+6, r18	; 0x06
    1c90:	97 83       	std	Z+7, r25	; 0x07
    1c92:	0e 94 19 11 	call	0x2232	; 0x2232 <sprintf>
	LCDstring(lcd_dis[1], 16);											//16 znakov kvoli >
    1c96:	ed b7       	in	r30, 0x3d	; 61
    1c98:	fe b7       	in	r31, 0x3e	; 62
    1c9a:	38 96       	adiw	r30, 0x08	; 8
    1c9c:	0f b6       	in	r0, 0x3f	; 63
    1c9e:	f8 94       	cli
    1ca0:	fe bf       	out	0x3e, r31	; 62
    1ca2:	0f be       	out	0x3f, r0	; 63
    1ca4:	ed bf       	out	0x3d, r30	; 61
    1ca6:	c4 01       	movw	r24, r8
    1ca8:	60 e1       	ldi	r22, 0x10	; 16
    1caa:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
	if (bit_is_set(PINC, 1)) {										// zvacsovanie hodnoty pri stlacani tlacitka 1
    1cae:	31 9b       	sbis	0x06, 1	; 6
    1cb0:	1f c0       	rjmp	.+62     	; 0x1cf0 <nastav+0x15a>
	  if (p_udaj < val) {									
    1cb2:	1f 15       	cp	r17, r15
    1cb4:	88 f4       	brcc	.+34     	; 0x1cd8 <nastav+0x142>
	    p_udaj++;
    1cb6:	1f 5f       	subi	r17, 0xFF	; 255
	    if ((bcdToDec(p_udaj) % 10) == 0)							//osetrenie hex cislic na BCD (vynechanie pismen pricitanim 6)
    1cb8:	21 2f       	mov	r18, r17
    1cba:	22 95       	swap	r18
    1cbc:	2f 70       	andi	r18, 0x0F	; 15
    1cbe:	2e 9d       	mul	r18, r14
    1cc0:	90 01       	movw	r18, r0
    1cc2:	11 24       	eor	r1, r1
    1cc4:	81 2f       	mov	r24, r17
    1cc6:	8f 70       	andi	r24, 0x0F	; 15
    1cc8:	82 0f       	add	r24, r18
    1cca:	6a e0       	ldi	r22, 0x0A	; 10
    1ccc:	0e 94 8e 13 	call	0x271c	; 0x271c <__udivmodqi4>
    1cd0:	99 23       	and	r25, r25
    1cd2:	39 f4       	brne	.+14     	; 0x1ce2 <nastav+0x14c>
		  p_udaj += 6;	
    1cd4:	1a 5f       	subi	r17, 0xFA	; 250
    1cd6:	05 c0       	rjmp	.+10     	; 0x1ce2 <nastav+0x14c>
	  } else p_udaj = ((addr == 5)||(addr == 4)) ? 1 : 0;		//pokial je Den a Mesiac nastav min na 1 (inak zacinaj od nuly)
    1cd8:	10 e0       	ldi	r17, 0x00	; 0
    1cda:	f9 81       	ldd	r31, Y+1	; 0x01
    1cdc:	f2 30       	cpi	r31, 0x02	; 2
    1cde:	08 f4       	brcc	.+2      	; 0x1ce2 <nastav+0x14c>
    1ce0:	11 e0       	ldi	r17, 0x01	; 1
    1ce2:	88 ee       	ldi	r24, 0xE8	; 232
    1ce4:	93 e0       	ldi	r25, 0x03	; 3
    1ce6:	f5 01       	movw	r30, r10
    1ce8:	31 97       	sbiw	r30, 0x01	; 1
    1cea:	f1 f7       	brne	.-4      	; 0x1ce8 <nastav+0x152>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1cec:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1cee:	d9 f7       	brne	.-10     	; 0x1ce6 <nastav+0x150>
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 2)) {
    1cf0:	32 9b       	sbis	0x06, 2	; 6
    1cf2:	28 c0       	rjmp	.+80     	; 0x1d44 <nastav+0x1ae>
	  if (p_udaj > ((addr == 4) || (addr == 5)) ? 1 : 0) {
    1cf4:	21 2f       	mov	r18, r17
    1cf6:	30 e0       	ldi	r19, 0x00	; 0
    1cf8:	80 e0       	ldi	r24, 0x00	; 0
    1cfa:	90 e0       	ldi	r25, 0x00	; 0
    1cfc:	49 81       	ldd	r20, Y+1	; 0x01
    1cfe:	42 30       	cpi	r20, 0x02	; 2
    1d00:	10 f4       	brcc	.+4      	; 0x1d06 <nastav+0x170>
    1d02:	81 e0       	ldi	r24, 0x01	; 1
    1d04:	90 e0       	ldi	r25, 0x00	; 0
    1d06:	82 17       	cp	r24, r18
    1d08:	93 07       	cpc	r25, r19
    1d0a:	14 f0       	brlt	.+4      	; 0x1d10 <nastav+0x17a>
    1d0c:	1f 2d       	mov	r17, r15
    1d0e:	13 c0       	rjmp	.+38     	; 0x1d36 <nastav+0x1a0>
	    if ((bcdToDec(p_udaj--) % 10) == 0)
    1d10:	41 2f       	mov	r20, r17
    1d12:	41 50       	subi	r20, 0x01	; 1
    1d14:	21 2f       	mov	r18, r17
    1d16:	22 95       	swap	r18
    1d18:	2f 70       	andi	r18, 0x0F	; 15
    1d1a:	2e 9d       	mul	r18, r14
    1d1c:	90 01       	movw	r18, r0
    1d1e:	11 24       	eor	r1, r1
    1d20:	81 2f       	mov	r24, r17
    1d22:	8f 70       	andi	r24, 0x0F	; 15
    1d24:	82 0f       	add	r24, r18
    1d26:	6a e0       	ldi	r22, 0x0A	; 10
    1d28:	0e 94 8e 13 	call	0x271c	; 0x271c <__udivmodqi4>
    1d2c:	99 23       	and	r25, r25
    1d2e:	11 f0       	breq	.+4      	; 0x1d34 <nastav+0x19e>
    1d30:	14 2f       	mov	r17, r20
    1d32:	01 c0       	rjmp	.+2      	; 0x1d36 <nastav+0x1a0>
		  p_udaj -= 6;
    1d34:	17 50       	subi	r17, 0x07	; 7
    1d36:	88 ee       	ldi	r24, 0xE8	; 232
    1d38:	93 e0       	ldi	r25, 0x03	; 3
    1d3a:	f5 01       	movw	r30, r10
    1d3c:	31 97       	sbiw	r30, 0x01	; 1
    1d3e:	f1 f7       	brne	.-4      	; 0x1d3c <nastav+0x1a6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d40:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d42:	d9 f7       	brne	.-10     	; 0x1d3a <nastav+0x1a4>
	  } else p_udaj = val;
	  _delay_ms(100);
	}
	if (bit_is_set(PINC, 0)) {										//pri stlaceni tlacitka 0 uloz hodnoty do DS1307
    1d44:	30 9b       	sbis	0x06, 0	; 6
    1d46:	0e c0       	rjmp	.+28     	; 0x1d64 <nastav+0x1ce>
	  write_ds1307(addr, p_udaj);
    1d48:	80 2f       	mov	r24, r16
    1d4a:	61 2f       	mov	r22, r17
    1d4c:	0e 94 31 01 	call	0x262	; 0x262 <write_ds1307>
	  if (addr == 5)
    1d50:	05 30       	cpi	r16, 0x05	; 5
    1d52:	29 f4       	brne	.+10     	; 0x1d5e <nastav+0x1c8>
	    udaje.mes = read_ds1307(addr);
    1d54:	85 e0       	ldi	r24, 0x05	; 5
    1d56:	0e 94 45 01 	call	0x28a	; 0x28a <read_ds1307>
    1d5a:	80 93 38 04 	sts	0x0438, r24
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1d5e:	30 99       	sbic	0x06, 0	; 6
    1d60:	fe cf       	rjmp	.-4      	; 0x1d5e <nastav+0x1c8>
    1d62:	04 c0       	rjmp	.+8      	; 0x1d6c <nastav+0x1d6>
	  if (addr == 5)
	    udaje.mes = read_ds1307(addr);
	  cakaj(0);
	  break;
	}
	if (bit_is_set(PINC, 4)) {
    1d64:	34 9b       	sbis	0x06, 4	; 6
    1d66:	76 cf       	rjmp	.-276    	; 0x1c54 <nastav+0xbe>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1d68:	34 99       	sbic	0x06, 4	; 6
    1d6a:	fe cf       	rjmp	.-4      	; 0x1d68 <nastav+0x1d2>
	if (bit_is_set(PINC, 4)) {
	  cakaj(4);
	  return;
	}
  }
}
    1d6c:	0f 90       	pop	r0
    1d6e:	cf 91       	pop	r28
    1d70:	df 91       	pop	r29
    1d72:	1f 91       	pop	r17
    1d74:	0f 91       	pop	r16
    1d76:	ff 90       	pop	r15
    1d78:	ef 90       	pop	r14
    1d7a:	df 90       	pop	r13
    1d7c:	cf 90       	pop	r12
    1d7e:	bf 90       	pop	r11
    1d80:	af 90       	pop	r10
    1d82:	9f 90       	pop	r9
    1d84:	8f 90       	pop	r8
    1d86:	7f 90       	pop	r7
    1d88:	6f 90       	pop	r6
    1d8a:	5f 90       	pop	r5
    1d8c:	4f 90       	pop	r4
    1d8e:	08 95       	ret

00001d90 <nastav_datum>:
//----------------------------------------------------------------------
char nastav_datum(void)
{
  unsigned char pom;

  nastav(str_pis[5], 0x99, 6);			// nastavenie roku
    1d90:	80 91 15 03 	lds	r24, 0x0315
    1d94:	90 91 16 03 	lds	r25, 0x0316
    1d98:	69 e9       	ldi	r22, 0x99	; 153
    1d9a:	46 e0       	ldi	r20, 0x06	; 6
    1d9c:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <nastav>
  nastav(str_pis[4], 0x12, 5);			//nastavenie mesiaca
    1da0:	80 91 13 03 	lds	r24, 0x0313
    1da4:	90 91 14 03 	lds	r25, 0x0314
    1da8:	62 e1       	ldi	r22, 0x12	; 18
    1daa:	45 e0       	ldi	r20, 0x05	; 5
    1dac:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <nastav>
  pom = pct_dni[(unsigned char)bcdToDec(udaje.mes)-1];
    1db0:	20 91 38 04 	lds	r18, 0x0438
    1db4:	82 2f       	mov	r24, r18
    1db6:	82 95       	swap	r24
    1db8:	8f 70       	andi	r24, 0x0F	; 15
    1dba:	3a e0       	ldi	r19, 0x0A	; 10
    1dbc:	83 9f       	mul	r24, r19
    1dbe:	c0 01       	movw	r24, r0
    1dc0:	11 24       	eor	r1, r1
    1dc2:	e2 2f       	mov	r30, r18
    1dc4:	ef 70       	andi	r30, 0x0F	; 15
    1dc6:	e8 0f       	add	r30, r24
    1dc8:	f0 e0       	ldi	r31, 0x00	; 0
    1dca:	ea 5e       	subi	r30, 0xEA	; 234
    1dcc:	fc 4f       	sbci	r31, 0xFC	; 252
    1dce:	60 81       	ld	r22, Z
  if ((udaje.mes == 2) && ((bcdToDec(udaje.rok) % 4) == 0))			//ak je februar a rok delitelny 4 potom
    1dd0:	22 30       	cpi	r18, 0x02	; 2
    1dd2:	81 f4       	brne	.+32     	; 0x1df4 <nastav_datum+0x64>
    1dd4:	80 91 39 04 	lds	r24, 0x0439
    1dd8:	28 2f       	mov	r18, r24
    1dda:	22 95       	swap	r18
    1ddc:	2f 70       	andi	r18, 0x0F	; 15
    1dde:	23 9f       	mul	r18, r19
    1de0:	90 01       	movw	r18, r0
    1de2:	11 24       	eor	r1, r1
    1de4:	8f 70       	andi	r24, 0x0F	; 15
    1de6:	82 0f       	add	r24, r18
    1de8:	90 e0       	ldi	r25, 0x00	; 0
    1dea:	83 70       	andi	r24, 0x03	; 3
    1dec:	90 70       	andi	r25, 0x00	; 0
    1dee:	89 2b       	or	r24, r25
    1df0:	09 f4       	brne	.+2      	; 0x1df4 <nastav_datum+0x64>
    pom++;															//zvacsi zobrazene dni (pom) o 1 (29)
    1df2:	6f 5f       	subi	r22, 0xFF	; 255
  nastav(str_pis[3], pom, 4);		// nastavenie dna	// pom - max zobrazena hodnota
    1df4:	80 91 11 03 	lds	r24, 0x0311
    1df8:	90 91 12 03 	lds	r25, 0x0312
    1dfc:	44 e0       	ldi	r20, 0x04	; 4
    1dfe:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <nastav>
  return 0;
}
    1e02:	80 e0       	ldi	r24, 0x00	; 0
    1e04:	08 95       	ret

00001e06 <nastav_cas>:
  }
}
//----------------------------------------------------------------------
char nastav_cas(void)
{
  CHbit_nastav();							// pri nastaveni casu stopni cas
    1e06:	0e 94 87 02 	call	0x50e	; 0x50e <CHbit_nastav>
  ch_bit = 1;
    1e0a:	81 e0       	ldi	r24, 0x01	; 1
    1e0c:	80 93 1d 04 	sts	0x041D, r24
  nastav(str_pis[2], 0x23, 2);		// nastavenie kazdeho udaju
    1e10:	80 91 0f 03 	lds	r24, 0x030F
    1e14:	90 91 10 03 	lds	r25, 0x0310
    1e18:	63 e2       	ldi	r22, 0x23	; 35
    1e1a:	42 e0       	ldi	r20, 0x02	; 2
    1e1c:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <nastav>
  nastav(str_pis[1], 0x59, 1);
    1e20:	80 91 0d 03 	lds	r24, 0x030D
    1e24:	90 91 0e 03 	lds	r25, 0x030E
    1e28:	69 e5       	ldi	r22, 0x59	; 89
    1e2a:	41 e0       	ldi	r20, 0x01	; 1
    1e2c:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <nastav>
  nastav(str_pis[0], 0x59, 0);
    1e30:	80 91 0b 03 	lds	r24, 0x030B
    1e34:	90 91 0c 03 	lds	r25, 0x030C
    1e38:	69 e5       	ldi	r22, 0x59	; 89
    1e3a:	40 e0       	ldi	r20, 0x00	; 0
    1e3c:	0e 94 cb 0d 	call	0x1b96	; 0x1b96 <nastav>
  CHbit_nuluj();
    1e40:	0e 94 92 02 	call	0x524	; 0x524 <CHbit_nuluj>
  ch_bit = 0;
    1e44:	10 92 1d 04 	sts	0x041D, r1
  return 0;
}
    1e48:	80 e0       	ldi	r24, 0x00	; 0
    1e4a:	08 95       	ret

00001e4c <zobraz_mon_temp>:
	}
  }
}
//----------------------------------------------------------------------
void zobraz_mon_temp(void)
{
    1e4c:	cf 92       	push	r12
    1e4e:	df 92       	push	r13
    1e50:	ef 92       	push	r14
    1e52:	ff 92       	push	r15
    1e54:	0f 93       	push	r16
    1e56:	1f 93       	push	r17
    1e58:	cf 93       	push	r28
    1e5a:	df 93       	push	r29
  unsigned char i;  

  LCDclr();
    1e5c:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1e60:	31 99       	sbic	0x06, 1	; 6
    1e62:	fe cf       	rjmp	.-4      	; 0x1e60 <zobraz_mon_temp+0x14>
  LCDclr();
  cakaj(1);
  
  for (;;) {
    LCDhome();
    sprintf(lcd_dis[0], "MIN:%+2d\xdf", mon_udaje.min_temp);	// pre zobrazenie monitorovanej teploty pouzit lcd_dis
    1e64:	cb ef       	ldi	r28, 0xFB	; 251
    1e66:	d3 e0       	ldi	r29, 0x03	; 3
    1e68:	ec e0       	ldi	r30, 0x0C	; 12
    1e6a:	ce 2e       	mov	r12, r30
    1e6c:	e2 e0       	ldi	r30, 0x02	; 2
    1e6e:	de 2e       	mov	r13, r30
    sprintf(lcd_dis[1], "MAX:%+2d\xdf", mon_udaje.max_temp);
    1e70:	8e 01       	movw	r16, r28
    1e72:	0f 5e       	subi	r16, 0xEF	; 239
    1e74:	1f 4f       	sbci	r17, 0xFF	; 255
    1e76:	76 e1       	ldi	r23, 0x16	; 22
    1e78:	e7 2e       	mov	r14, r23
    1e7a:	72 e0       	ldi	r23, 0x02	; 2
    1e7c:	f7 2e       	mov	r15, r23

  LCDclr();
  cakaj(1);
  
  for (;;) {
    LCDhome();
    1e7e:	0e 94 d6 01 	call	0x3ac	; 0x3ac <LCDhome>
    sprintf(lcd_dis[0], "MIN:%+2d\xdf", mon_udaje.min_temp);	// pre zobrazenie monitorovanej teploty pouzit lcd_dis
    1e82:	00 d0       	rcall	.+0      	; 0x1e84 <zobraz_mon_temp+0x38>
    1e84:	00 d0       	rcall	.+0      	; 0x1e86 <zobraz_mon_temp+0x3a>
    1e86:	00 d0       	rcall	.+0      	; 0x1e88 <zobraz_mon_temp+0x3c>
    1e88:	ed b7       	in	r30, 0x3d	; 61
    1e8a:	fe b7       	in	r31, 0x3e	; 62
    1e8c:	31 96       	adiw	r30, 0x01	; 1
    1e8e:	ad b7       	in	r26, 0x3d	; 61
    1e90:	be b7       	in	r27, 0x3e	; 62
    1e92:	12 96       	adiw	r26, 0x02	; 2
    1e94:	dc 93       	st	X, r29
    1e96:	ce 93       	st	-X, r28
    1e98:	11 97       	sbiw	r26, 0x01	; 1
    1e9a:	d3 82       	std	Z+3, r13	; 0x03
    1e9c:	c2 82       	std	Z+2, r12	; 0x02
    1e9e:	80 91 2a 04 	lds	r24, 0x042A
    1ea2:	84 83       	std	Z+4, r24	; 0x04
    1ea4:	15 82       	std	Z+5, r1	; 0x05
    1ea6:	0e 94 19 11 	call	0x2232	; 0x2232 <sprintf>
    sprintf(lcd_dis[1], "MAX:%+2d\xdf", mon_udaje.max_temp);
    1eaa:	ed b7       	in	r30, 0x3d	; 61
    1eac:	fe b7       	in	r31, 0x3e	; 62
    1eae:	31 96       	adiw	r30, 0x01	; 1
    1eb0:	ad b7       	in	r26, 0x3d	; 61
    1eb2:	be b7       	in	r27, 0x3e	; 62
    1eb4:	12 96       	adiw	r26, 0x02	; 2
    1eb6:	1c 93       	st	X, r17
    1eb8:	0e 93       	st	-X, r16
    1eba:	11 97       	sbiw	r26, 0x01	; 1
    1ebc:	f3 82       	std	Z+3, r15	; 0x03
    1ebe:	e2 82       	std	Z+2, r14	; 0x02
    1ec0:	80 91 2e 04 	lds	r24, 0x042E
    1ec4:	84 83       	std	Z+4, r24	; 0x04
    1ec6:	15 82       	std	Z+5, r1	; 0x05
    1ec8:	0e 94 19 11 	call	0x2232	; 0x2232 <sprintf>
    LCDstring(lcd_dis[0], strlen(lcd_dis[0]));LCDsendChar('C');
    1ecc:	de 01       	movw	r26, r28
    1ece:	0d 90       	ld	r0, X+
    1ed0:	00 20       	and	r0, r0
    1ed2:	e9 f7       	brne	.-6      	; 0x1ece <zobraz_mon_temp+0x82>
    1ed4:	11 97       	sbiw	r26, 0x01	; 1
    1ed6:	ac 1b       	sub	r26, r28
    1ed8:	bd 0b       	sbc	r27, r29
    1eda:	8d b7       	in	r24, 0x3d	; 61
    1edc:	9e b7       	in	r25, 0x3e	; 62
    1ede:	06 96       	adiw	r24, 0x06	; 6
    1ee0:	0f b6       	in	r0, 0x3f	; 63
    1ee2:	f8 94       	cli
    1ee4:	9e bf       	out	0x3e, r25	; 62
    1ee6:	0f be       	out	0x3f, r0	; 63
    1ee8:	8d bf       	out	0x3d, r24	; 61
    1eea:	ce 01       	movw	r24, r28
    1eec:	6a 2f       	mov	r22, r26
    1eee:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
    1ef2:	83 e4       	ldi	r24, 0x43	; 67
    1ef4:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
    LCDGotoXY(0,1);
    1ef8:	80 e0       	ldi	r24, 0x00	; 0
    1efa:	61 e0       	ldi	r22, 0x01	; 1
    1efc:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
    LCDstring(lcd_dis[1], strlen(lcd_dis[1]));LCDsendChar('C');
    1f00:	f8 01       	movw	r30, r16
    1f02:	01 90       	ld	r0, Z+
    1f04:	00 20       	and	r0, r0
    1f06:	e9 f7       	brne	.-6      	; 0x1f02 <zobraz_mon_temp+0xb6>
    1f08:	ed 50       	subi	r30, 0x0D	; 13
    1f0a:	f4 40       	sbci	r31, 0x04	; 4
    1f0c:	c8 01       	movw	r24, r16
    1f0e:	6e 2f       	mov	r22, r30
    1f10:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
    1f14:	83 e4       	ldi	r24, 0x43	; 67
    1f16:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
	if (bit_is_set(PINC, 1)) {									// pri stlaceni tlacitka 1 vrat sa spat na default zobrazovanie
    1f1a:	31 9b       	sbis	0x06, 1	; 6
    1f1c:	05 c0       	rjmp	.+10     	; 0x1f28 <zobraz_mon_temp+0xdc>
	  LCDclr();
    1f1e:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1f22:	31 99       	sbic	0x06, 1	; 6
    1f24:	fe cf       	rjmp	.-4      	; 0x1f22 <zobraz_mon_temp+0xd6>
    1f26:	40 c0       	rjmp	.+128    	; 0x1fa8 <zobraz_mon_temp+0x15c>
	if (bit_is_set(PINC, 1)) {									// pri stlaceni tlacitka 1 vrat sa spat na default zobrazovanie
	  LCDclr();
	  cakaj(1);
	  break;
	}
	if (bit_is_set(PINC, 0)) {									// pri stlaceni tlacitka 0 uloz zaznam do EEPROM
    1f28:	30 9b       	sbis	0x06, 0	; 6
    1f2a:	a9 cf       	rjmp	.-174    	; 0x1e7e <zobraz_mon_temp+0x32>
	  for (i = 0; i < 8; i++) {
	    EEPROM_CAKAJ;
		eeprom_write_byte(i,p_mon[i]);
    1f2c:	20 91 69 02 	lds	r18, 0x0269
    1f30:	30 91 6a 02 	lds	r19, 0x026A
    1f34:	80 e0       	ldi	r24, 0x00	; 0
    1f36:	90 e0       	ldi	r25, 0x00	; 0
	  cakaj(1);
	  break;
	}
	if (bit_is_set(PINC, 0)) {									// pri stlaceni tlacitka 0 uloz zaznam do EEPROM
	  for (i = 0; i < 8; i++) {
	    EEPROM_CAKAJ;
    1f38:	f9 99       	sbic	0x1f, 1	; 31
    1f3a:	fe cf       	rjmp	.-4      	; 0x1f38 <zobraz_mon_temp+0xec>
		eeprom_write_byte(i,p_mon[i]);
    1f3c:	f9 01       	movw	r30, r18
    1f3e:	e8 0f       	add	r30, r24
    1f40:	f9 1f       	adc	r31, r25
    1f42:	e0 81       	ld	r30, Z
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1f44:	f9 99       	sbic	0x1f, 1	; 31
    1f46:	fe cf       	rjmp	.-4      	; 0x1f44 <zobraz_mon_temp+0xf8>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    1f48:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1f4a:	92 bd       	out	0x22, r25	; 34
    1f4c:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    1f4e:	e0 bd       	out	0x20, r30	; 32

    __asm__ __volatile__ (
    1f50:	0f b6       	in	r0, 0x3f	; 63
    1f52:	f8 94       	cli
    1f54:	fa 9a       	sbi	0x1f, 2	; 31
    1f56:	f9 9a       	sbi	0x1f, 1	; 31
    1f58:	0f be       	out	0x3f, r0	; 63
    1f5a:	01 96       	adiw	r24, 0x01	; 1
	  LCDclr();
	  cakaj(1);
	  break;
	}
	if (bit_is_set(PINC, 0)) {									// pri stlaceni tlacitka 0 uloz zaznam do EEPROM
	  for (i = 0; i < 8; i++) {
    1f5c:	88 30       	cpi	r24, 0x08	; 8
    1f5e:	91 05       	cpc	r25, r1
    1f60:	59 f7       	brne	.-42     	; 0x1f38 <zobraz_mon_temp+0xec>
	    EEPROM_CAKAJ;
		eeprom_write_byte(i,p_mon[i]);
	  }
	  LCDclr();
    1f62:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
	  strcpy(lcd_dis[0], "Hodnoty ulozene ");
    1f66:	8b ef       	ldi	r24, 0xFB	; 251
    1f68:	93 e0       	ldi	r25, 0x03	; 3
    1f6a:	60 e2       	ldi	r22, 0x20	; 32
    1f6c:	72 e0       	ldi	r23, 0x02	; 2
    1f6e:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	  strcpy(lcd_dis[1], "v pamati        ");
    1f72:	8c e0       	ldi	r24, 0x0C	; 12
    1f74:	94 e0       	ldi	r25, 0x04	; 4
    1f76:	61 e3       	ldi	r22, 0x31	; 49
    1f78:	72 e0       	ldi	r23, 0x02	; 2
    1f7a:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
	  LCDstringXY(0, 0, lcd_dis[0], 16);
    1f7e:	80 e0       	ldi	r24, 0x00	; 0
    1f80:	60 e0       	ldi	r22, 0x00	; 0
    1f82:	4b ef       	ldi	r20, 0xFB	; 251
    1f84:	53 e0       	ldi	r21, 0x03	; 3
    1f86:	20 e1       	ldi	r18, 0x10	; 16
    1f88:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	  LCDstringXY(0, 1, lcd_dis[1], 16);
    1f8c:	80 e0       	ldi	r24, 0x00	; 0
    1f8e:	61 e0       	ldi	r22, 0x01	; 1
    1f90:	4c e0       	ldi	r20, 0x0C	; 12
    1f92:	54 e0       	ldi	r21, 0x04	; 4
    1f94:	20 e1       	ldi	r18, 0x10	; 16
    1f96:	0e 94 25 03 	call	0x64a	; 0x64a <LCDstringXY>
	  while (1) {
	    if (bit_is_set(PINC, 0)) {
    1f9a:	30 9b       	sbis	0x06, 0	; 6
    1f9c:	fe cf       	rjmp	.-4      	; 0x1f9a <zobraz_mon_temp+0x14e>
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void cakaj(char p)
{
  while (bit_is_set(PINC, p)) ;
    1f9e:	30 99       	sbic	0x06, 0	; 6
    1fa0:	fe cf       	rjmp	.-4      	; 0x1f9e <zobraz_mon_temp+0x152>
	    if (bit_is_set(PINC, 0)) {
		  cakaj(0);
		  break;
		}  
	  }
	  LCDclr();
    1fa2:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <LCDclr>
    1fa6:	6b cf       	rjmp	.-298    	; 0x1e7e <zobraz_mon_temp+0x32>
	}
  }
}
    1fa8:	df 91       	pop	r29
    1faa:	cf 91       	pop	r28
    1fac:	1f 91       	pop	r17
    1fae:	0f 91       	pop	r16
    1fb0:	ff 90       	pop	r15
    1fb2:	ef 90       	pop	r14
    1fb4:	df 90       	pop	r13
    1fb6:	cf 90       	pop	r12
    1fb8:	08 95       	ret

00001fba <display1>:
#ifndef Clock_F
#define Clock_F

//----------------------------------------------------------------------
void display1(void)					//samotne vypisanie (stav po spusteni)
{
    1fba:	0f 93       	push	r16
    1fbc:	1f 93       	push	r17
    1fbe:	cf 93       	push	r28
    1fc0:	df 93       	push	r29
  LCDhome();
    1fc2:	0e 94 d6 01 	call	0x3ac	; 0x3ac <LCDhome>
  sprintf(lcd_dis[0], "%2x:%02x:%02x%+6d", udaje.hod, udaje.min, udaje.sek, ((udaje.teplota == 85) || (udaje.teplota == 84) || (udaje.teplota == 127)) ? 0 : udaje.teplota);				//prichystane na vypis
    1fc6:	cb ef       	ldi	r28, 0xFB	; 251
    1fc8:	d3 e0       	ldi	r29, 0x03	; 3
    1fca:	40 91 35 04 	lds	r20, 0x0435
    1fce:	50 91 34 04 	lds	r21, 0x0434
    1fd2:	60 91 33 04 	lds	r22, 0x0433
    1fd6:	90 91 32 04 	lds	r25, 0x0432
    1fda:	89 2f       	mov	r24, r25
    1fdc:	84 55       	subi	r24, 0x54	; 84
    1fde:	82 30       	cpi	r24, 0x02	; 2
    1fe0:	28 f0       	brcs	.+10     	; 0x1fec <display1+0x32>
    1fe2:	9f 37       	cpi	r25, 0x7F	; 127
    1fe4:	19 f0       	breq	.+6      	; 0x1fec <display1+0x32>
    1fe6:	29 2f       	mov	r18, r25
    1fe8:	30 e0       	ldi	r19, 0x00	; 0
    1fea:	02 c0       	rjmp	.+4      	; 0x1ff0 <display1+0x36>
    1fec:	20 e0       	ldi	r18, 0x00	; 0
    1fee:	30 e0       	ldi	r19, 0x00	; 0
    1ff0:	8d b7       	in	r24, 0x3d	; 61
    1ff2:	9e b7       	in	r25, 0x3e	; 62
    1ff4:	0c 97       	sbiw	r24, 0x0c	; 12
    1ff6:	0f b6       	in	r0, 0x3f	; 63
    1ff8:	f8 94       	cli
    1ffa:	9e bf       	out	0x3e, r25	; 62
    1ffc:	0f be       	out	0x3f, r0	; 63
    1ffe:	8d bf       	out	0x3d, r24	; 61
    2000:	ed b7       	in	r30, 0x3d	; 61
    2002:	fe b7       	in	r31, 0x3e	; 62
    2004:	31 96       	adiw	r30, 0x01	; 1
    2006:	ad b7       	in	r26, 0x3d	; 61
    2008:	be b7       	in	r27, 0x3e	; 62
    200a:	12 96       	adiw	r26, 0x02	; 2
    200c:	dc 93       	st	X, r29
    200e:	ce 93       	st	-X, r28
    2010:	11 97       	sbiw	r26, 0x01	; 1
    2012:	82 e4       	ldi	r24, 0x42	; 66
    2014:	92 e0       	ldi	r25, 0x02	; 2
    2016:	93 83       	std	Z+3, r25	; 0x03
    2018:	82 83       	std	Z+2, r24	; 0x02
    201a:	44 83       	std	Z+4, r20	; 0x04
    201c:	15 82       	std	Z+5, r1	; 0x05
    201e:	56 83       	std	Z+6, r21	; 0x06
    2020:	17 82       	std	Z+7, r1	; 0x07
    2022:	60 87       	std	Z+8, r22	; 0x08
    2024:	11 86       	std	Z+9, r1	; 0x09
    2026:	33 87       	std	Z+11, r19	; 0x0b
    2028:	22 87       	std	Z+10, r18	; 0x0a
    202a:	0e 94 19 11 	call	0x2232	; 0x2232 <sprintf>
  sprintf(lcd_dis[1], "%3s  %2x.%2x. 20%02x", dni[udaje.mDen - 1], udaje.den, udaje.mes, udaje.rok);	//taktiez vyplnim lcd_dis pole ktore je
    202e:	ad b7       	in	r26, 0x3d	; 61
    2030:	be b7       	in	r27, 0x3e	; 62
    2032:	11 96       	adiw	r26, 0x01	; 1
    2034:	8e 01       	movw	r16, r28
    2036:	0f 5e       	subi	r16, 0xEF	; 239
    2038:	1f 4f       	sbci	r17, 0xFF	; 255
    203a:	ed b7       	in	r30, 0x3d	; 61
    203c:	fe b7       	in	r31, 0x3e	; 62
    203e:	12 83       	std	Z+2, r17	; 0x02
    2040:	01 83       	std	Z+1, r16	; 0x01
    2042:	84 e5       	ldi	r24, 0x54	; 84
    2044:	92 e0       	ldi	r25, 0x02	; 2
    2046:	13 96       	adiw	r26, 0x03	; 3
    2048:	9c 93       	st	X, r25
    204a:	8e 93       	st	-X, r24
    204c:	12 97       	sbiw	r26, 0x02	; 2
    204e:	e0 91 36 04 	lds	r30, 0x0436
    2052:	f0 e0       	ldi	r31, 0x00	; 0
    2054:	ee 0f       	add	r30, r30
    2056:	ff 1f       	adc	r31, r31
    2058:	e7 57       	subi	r30, 0x77	; 119
    205a:	fd 4f       	sbci	r31, 0xFD	; 253
    205c:	80 81       	ld	r24, Z
    205e:	91 81       	ldd	r25, Z+1	; 0x01
    2060:	15 96       	adiw	r26, 0x05	; 5
    2062:	9c 93       	st	X, r25
    2064:	8e 93       	st	-X, r24
    2066:	14 97       	sbiw	r26, 0x04	; 4
    2068:	80 91 37 04 	lds	r24, 0x0437
    206c:	16 96       	adiw	r26, 0x06	; 6
    206e:	8c 93       	st	X, r24
    2070:	16 97       	sbiw	r26, 0x06	; 6
    2072:	17 96       	adiw	r26, 0x07	; 7
    2074:	1c 92       	st	X, r1
    2076:	17 97       	sbiw	r26, 0x07	; 7
    2078:	80 91 38 04 	lds	r24, 0x0438
    207c:	18 96       	adiw	r26, 0x08	; 8
    207e:	8c 93       	st	X, r24
    2080:	18 97       	sbiw	r26, 0x08	; 8
    2082:	19 96       	adiw	r26, 0x09	; 9
    2084:	1c 92       	st	X, r1
    2086:	19 97       	sbiw	r26, 0x09	; 9
    2088:	80 91 39 04 	lds	r24, 0x0439
    208c:	1a 96       	adiw	r26, 0x0a	; 10
    208e:	8c 93       	st	X, r24
    2090:	1a 97       	sbiw	r26, 0x0a	; 10
    2092:	1b 96       	adiw	r26, 0x0b	; 11
    2094:	1c 92       	st	X, r1
    2096:	0e 94 19 11 	call	0x2232	; 0x2232 <sprintf>
  LCDstring(lcd_dis[0], strlen(lcd_dis[0]));
    209a:	de 01       	movw	r26, r28
    209c:	0d 90       	ld	r0, X+
    209e:	00 20       	and	r0, r0
    20a0:	e9 f7       	brne	.-6      	; 0x209c <display1+0xe2>
    20a2:	11 97       	sbiw	r26, 0x01	; 1
    20a4:	ac 1b       	sub	r26, r28
    20a6:	bd 0b       	sbc	r27, r29
    20a8:	8d b7       	in	r24, 0x3d	; 61
    20aa:	9e b7       	in	r25, 0x3e	; 62
    20ac:	0c 96       	adiw	r24, 0x0c	; 12
    20ae:	0f b6       	in	r0, 0x3f	; 63
    20b0:	f8 94       	cli
    20b2:	9e bf       	out	0x3e, r25	; 62
    20b4:	0f be       	out	0x3f, r0	; 63
    20b6:	8d bf       	out	0x3d, r24	; 61
    20b8:	ce 01       	movw	r24, r28
    20ba:	6a 2f       	mov	r22, r26
    20bc:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
  LCDsendChar(0xdf);LCDsendChar('C');
    20c0:	8f ed       	ldi	r24, 0xDF	; 223
    20c2:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
    20c6:	83 e4       	ldi	r24, 0x43	; 67
    20c8:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <LCDsendChar>
  LCDGotoXY(0,1);
    20cc:	80 e0       	ldi	r24, 0x00	; 0
    20ce:	61 e0       	ldi	r22, 0x01	; 1
    20d0:	0e 94 ef 01 	call	0x3de	; 0x3de <LCDGotoXY>
  LCDstring(lcd_dis[1], strlen(lcd_dis[1]));
    20d4:	f8 01       	movw	r30, r16
    20d6:	01 90       	ld	r0, Z+
    20d8:	00 20       	and	r0, r0
    20da:	e9 f7       	brne	.-6      	; 0x20d6 <display1+0x11c>
    20dc:	ed 50       	subi	r30, 0x0D	; 13
    20de:	f4 40       	sbci	r31, 0x04	; 4
    20e0:	c8 01       	movw	r24, r16
    20e2:	6e 2f       	mov	r22, r30
    20e4:	0e 94 da 01 	call	0x3b4	; 0x3b4 <LCDstring>
}
    20e8:	df 91       	pop	r29
    20ea:	cf 91       	pop	r28
    20ec:	1f 91       	pop	r17
    20ee:	0f 91       	pop	r16
    20f0:	08 95       	ret

000020f2 <main>:
  TIMSK0 = 1;
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
int main(void)
{
    20f2:	1f 93       	push	r17
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
void nastav_casovac0(char tcra, char tcrb, char tnt, char s)
{
  TCCR0A=tcra;
    20f4:	14 bc       	out	0x24, r1	; 36
  TCCR0B=tcrb;
    20f6:	84 e0       	ldi	r24, 0x04	; 4
    20f8:	85 bd       	out	0x25, r24	; 37
  TCNT0=tnt;
    20fa:	16 bc       	out	0x26, r1	; 38
  TIMSK0=s;
    20fc:	11 e0       	ldi	r17, 0x01	; 1
    20fe:	10 93 6e 00 	sts	0x006E, r17
}
//----------------------------------------------------------------------
void nastav_casovac2(char tcra, char tcrb, char tnt, char s)
{
  TCCR2A=tcra;
    2102:	10 92 b0 00 	sts	0x00B0, r1
  TCCR2B=tcrb;
    2106:	87 e0       	ldi	r24, 0x07	; 7
    2108:	80 93 b1 00 	sts	0x00B1, r24
  TCNT2=tnt;
    210c:	10 92 b2 00 	sts	0x00B2, r1
  TIMSK2=s;  
    2110:	10 93 70 00 	sts	0x0070, r17
{
  unsigned char p;

  nastav_casovac0(0, 4, 0, 1);
  nastav_casovac2(0, 7, 0, 1);
  udaje.teplota = 84;
    2114:	84 e5       	ldi	r24, 0x54	; 84
    2116:	80 93 32 04 	sts	0x0432, r24
}
//----------------------------------------------------------------------
/* 19200kbps 8N1 */
void USART_Init(void)
{
  UCSR0A = 0x00;
    211a:	10 92 c0 00 	sts	0x00C0, r1
  UCSR0B = 0x98;
    211e:	88 e9       	ldi	r24, 0x98	; 152
    2120:	80 93 c1 00 	sts	0x00C1, r24
  UCSR0C = 0x06;
    2124:	86 e0       	ldi	r24, 0x06	; 6
    2126:	80 93 c2 00 	sts	0x00C2, r24
  UBRR0H = 0x00;
    212a:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = 0x19;
    212e:	89 e1       	ldi	r24, 0x19	; 25
    2130:	80 93 c4 00 	sts	0x00C4, r24
  USART_Init();
  LCDinit();
    2134:	0e 94 9e 01 	call	0x33c	; 0x33c <LCDinit>
  LCDcursorOFF();
    2138:	0e 94 5f 02 	call	0x4be	; 0x4be <LCDcursorOFF>
  CHbit_nuluj();			// pre istotu (pri "nekorektnom" vypnuti, tj. pocas konfiguracie casu - vid pozn.)  
    213c:	0e 94 92 02 	call	0x524	; 0x524 <CHbit_nuluj>

  DDRD &= ~0x10;			//tlacitko pre podsvietenie
    2140:	54 98       	cbi	0x0a, 4	; 10
  DDRD |= 4;				//vystup pre podsvietenie displeja
    2142:	52 9a       	sbi	0x0a, 2	; 10
  DDRC = 0x8;				//DDRC (vstup) 0,1,2,4,5 - tlacitka, (vystup) 3 - speaker
    2144:	88 e0       	ldi	r24, 0x08	; 8
    2146:	87 b9       	out	0x07, r24	; 7
  PORTC &= ~0x8;			// PORTC 3 - log 0 na vystupe
    2148:	43 98       	cbi	0x08, 3	; 8
  alarm.al_den = 1;
    214a:	10 93 26 04 	sts	0x0426, r17
    214e:	20 e0       	ldi	r18, 0x00	; 0
    2150:	30 e0       	ldi	r19, 0x00	; 0

  for (p = 0; p < 8; p++) {
    EEPROM_CAKAJ;
    2152:	f9 99       	sbic	0x1f, 1	; 31
    2154:	fe cf       	rjmp	.-4      	; 0x2152 <main+0x60>
    p_mon[p] = eeprom_read_byte(p);
    2156:	e0 91 69 02 	lds	r30, 0x0269
    215a:	f0 91 6a 02 	lds	r31, 0x026A
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    215e:	f9 99       	sbic	0x1f, 1	; 31
    2160:	fe cf       	rjmp	.-4      	; 0x215e <main+0x6c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2162:	32 bd       	out	0x22, r19	; 34
    2164:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2166:	f8 9a       	sbi	0x1f, 0	; 31
    2168:	80 b5       	in	r24, 0x20	; 32
    216a:	e2 0f       	add	r30, r18
    216c:	f3 1f       	adc	r31, r19
    216e:	80 83       	st	Z, r24
    2170:	2f 5f       	subi	r18, 0xFF	; 255
    2172:	3f 4f       	sbci	r19, 0xFF	; 255
  DDRD |= 4;				//vystup pre podsvietenie displeja
  DDRC = 0x8;				//DDRC (vstup) 0,1,2,4,5 - tlacitka, (vystup) 3 - speaker
  PORTC &= ~0x8;			// PORTC 3 - log 0 na vystupe
  alarm.al_den = 1;

  for (p = 0; p < 8; p++) {
    2174:	28 30       	cpi	r18, 0x08	; 8
    2176:	31 05       	cpc	r19, r1
    2178:	61 f7       	brne	.-40     	; 0x2152 <main+0x60>
    EEPROM_CAKAJ;
    p_mon[p] = eeprom_read_byte(p);
  }
  
  asm("sei");
    217a:	78 94       	sei

  while (1) {
    display1();
    217c:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <display1>
	if (prac_stav == 0) {
    2180:	80 91 f4 03 	lds	r24, 0x03F4
    2184:	88 23       	and	r24, r24
    2186:	d1 f7       	brne	.-12     	; 0x217c <main+0x8a>
	  if (bit_is_set(PINC, 0))
    2188:	30 9b       	sbis	0x06, 0	; 6
    218a:	02 c0       	rjmp	.+4      	; 0x2190 <main+0x9e>
	    konfig_hodiny();
    218c:	0e 94 67 09 	call	0x12ce	; 0x12ce <konfig_hodiny>
	  if (bit_is_set(PINC, 1)) {
    2190:	31 9b       	sbis	0x06, 1	; 6
    2192:	f4 cf       	rjmp	.-24     	; 0x217c <main+0x8a>
	    if (udaje.mon_temp == 1)
    2194:	80 91 3b 04 	lds	r24, 0x043B
    2198:	81 30       	cpi	r24, 0x01	; 1
    219a:	81 f7       	brne	.-32     	; 0x217c <main+0x8a>
		  zobraz_mon_temp();
    219c:	0e 94 26 0f 	call	0x1e4c	; 0x1e4c <zobraz_mon_temp>
    21a0:	ed cf       	rjmp	.-38     	; 0x217c <main+0x8a>

000021a2 <strcpy>:
    21a2:	fb 01       	movw	r30, r22
    21a4:	dc 01       	movw	r26, r24
    21a6:	01 90       	ld	r0, Z+
    21a8:	0d 92       	st	X+, r0
    21aa:	00 20       	and	r0, r0
    21ac:	e1 f7       	brne	.-8      	; 0x21a6 <strcpy+0x4>
    21ae:	08 95       	ret

000021b0 <fputc>:
    21b0:	0f 93       	push	r16
    21b2:	1f 93       	push	r17
    21b4:	cf 93       	push	r28
    21b6:	df 93       	push	r29
    21b8:	8c 01       	movw	r16, r24
    21ba:	eb 01       	movw	r28, r22
    21bc:	8b 81       	ldd	r24, Y+3	; 0x03
    21be:	81 ff       	sbrs	r24, 1
    21c0:	1b c0       	rjmp	.+54     	; 0x21f8 <fputc+0x48>
    21c2:	82 ff       	sbrs	r24, 2
    21c4:	0d c0       	rjmp	.+26     	; 0x21e0 <fputc+0x30>
    21c6:	2e 81       	ldd	r18, Y+6	; 0x06
    21c8:	3f 81       	ldd	r19, Y+7	; 0x07
    21ca:	8c 81       	ldd	r24, Y+4	; 0x04
    21cc:	9d 81       	ldd	r25, Y+5	; 0x05
    21ce:	28 17       	cp	r18, r24
    21d0:	39 07       	cpc	r19, r25
    21d2:	64 f4       	brge	.+24     	; 0x21ec <fputc+0x3c>
    21d4:	e8 81       	ld	r30, Y
    21d6:	f9 81       	ldd	r31, Y+1	; 0x01
    21d8:	01 93       	st	Z+, r16
    21da:	f9 83       	std	Y+1, r31	; 0x01
    21dc:	e8 83       	st	Y, r30
    21de:	06 c0       	rjmp	.+12     	; 0x21ec <fputc+0x3c>
    21e0:	e8 85       	ldd	r30, Y+8	; 0x08
    21e2:	f9 85       	ldd	r31, Y+9	; 0x09
    21e4:	80 2f       	mov	r24, r16
    21e6:	09 95       	icall
    21e8:	89 2b       	or	r24, r25
    21ea:	31 f4       	brne	.+12     	; 0x21f8 <fputc+0x48>
    21ec:	8e 81       	ldd	r24, Y+6	; 0x06
    21ee:	9f 81       	ldd	r25, Y+7	; 0x07
    21f0:	01 96       	adiw	r24, 0x01	; 1
    21f2:	9f 83       	std	Y+7, r25	; 0x07
    21f4:	8e 83       	std	Y+6, r24	; 0x06
    21f6:	02 c0       	rjmp	.+4      	; 0x21fc <fputc+0x4c>
    21f8:	0f ef       	ldi	r16, 0xFF	; 255
    21fa:	1f ef       	ldi	r17, 0xFF	; 255
    21fc:	c8 01       	movw	r24, r16
    21fe:	df 91       	pop	r29
    2200:	cf 91       	pop	r28
    2202:	1f 91       	pop	r17
    2204:	0f 91       	pop	r16
    2206:	08 95       	ret

00002208 <printf>:
    2208:	a0 e0       	ldi	r26, 0x00	; 0
    220a:	b0 e0       	ldi	r27, 0x00	; 0
    220c:	ea e0       	ldi	r30, 0x0A	; 10
    220e:	f1 e1       	ldi	r31, 0x11	; 17
    2210:	0c 94 d1 13 	jmp	0x27a2	; 0x27a2 <__prologue_saves__+0x20>
    2214:	fe 01       	movw	r30, r28
    2216:	35 96       	adiw	r30, 0x05	; 5
    2218:	61 91       	ld	r22, Z+
    221a:	71 91       	ld	r23, Z+
    221c:	80 91 4e 04 	lds	r24, 0x044E
    2220:	90 91 4f 04 	lds	r25, 0x044F
    2224:	af 01       	movw	r20, r30
    2226:	0e 94 3d 11 	call	0x227a	; 0x227a <vfprintf>
    222a:	20 96       	adiw	r28, 0x00	; 0
    222c:	e2 e0       	ldi	r30, 0x02	; 2
    222e:	0c 94 ed 13 	jmp	0x27da	; 0x27da <__epilogue_restores__+0x20>

00002232 <sprintf>:
    2232:	ae e0       	ldi	r26, 0x0E	; 14
    2234:	b0 e0       	ldi	r27, 0x00	; 0
    2236:	ef e1       	ldi	r30, 0x1F	; 31
    2238:	f1 e1       	ldi	r31, 0x11	; 17
    223a:	0c 94 cf 13 	jmp	0x279e	; 0x279e <__prologue_saves__+0x1c>
    223e:	0d 89       	ldd	r16, Y+21	; 0x15
    2240:	1e 89       	ldd	r17, Y+22	; 0x16
    2242:	86 e0       	ldi	r24, 0x06	; 6
    2244:	8c 83       	std	Y+4, r24	; 0x04
    2246:	1a 83       	std	Y+2, r17	; 0x02
    2248:	09 83       	std	Y+1, r16	; 0x01
    224a:	8f ef       	ldi	r24, 0xFF	; 255
    224c:	9f e7       	ldi	r25, 0x7F	; 127
    224e:	9e 83       	std	Y+6, r25	; 0x06
    2250:	8d 83       	std	Y+5, r24	; 0x05
    2252:	9e 01       	movw	r18, r28
    2254:	27 5e       	subi	r18, 0xE7	; 231
    2256:	3f 4f       	sbci	r19, 0xFF	; 255
    2258:	ce 01       	movw	r24, r28
    225a:	01 96       	adiw	r24, 0x01	; 1
    225c:	6f 89       	ldd	r22, Y+23	; 0x17
    225e:	78 8d       	ldd	r23, Y+24	; 0x18
    2260:	a9 01       	movw	r20, r18
    2262:	0e 94 3d 11 	call	0x227a	; 0x227a <vfprintf>
    2266:	2f 81       	ldd	r18, Y+7	; 0x07
    2268:	38 85       	ldd	r19, Y+8	; 0x08
    226a:	02 0f       	add	r16, r18
    226c:	13 1f       	adc	r17, r19
    226e:	f8 01       	movw	r30, r16
    2270:	10 82       	st	Z, r1
    2272:	2e 96       	adiw	r28, 0x0e	; 14
    2274:	e4 e0       	ldi	r30, 0x04	; 4
    2276:	0c 94 eb 13 	jmp	0x27d6	; 0x27d6 <__epilogue_restores__+0x1c>

0000227a <vfprintf>:
    227a:	ab e0       	ldi	r26, 0x0B	; 11
    227c:	b0 e0       	ldi	r27, 0x00	; 0
    227e:	e3 e4       	ldi	r30, 0x43	; 67
    2280:	f1 e1       	ldi	r31, 0x11	; 17
    2282:	0c 94 c1 13 	jmp	0x2782	; 0x2782 <__prologue_saves__>
    2286:	3c 01       	movw	r6, r24
    2288:	2b 01       	movw	r4, r22
    228a:	5a 01       	movw	r10, r20
    228c:	fc 01       	movw	r30, r24
    228e:	17 82       	std	Z+7, r1	; 0x07
    2290:	16 82       	std	Z+6, r1	; 0x06
    2292:	83 81       	ldd	r24, Z+3	; 0x03
    2294:	81 fd       	sbrc	r24, 1
    2296:	03 c0       	rjmp	.+6      	; 0x229e <vfprintf+0x24>
    2298:	6f ef       	ldi	r22, 0xFF	; 255
    229a:	7f ef       	ldi	r23, 0xFF	; 255
    229c:	c6 c1       	rjmp	.+908    	; 0x262a <vfprintf+0x3b0>
    229e:	9a e0       	ldi	r25, 0x0A	; 10
    22a0:	89 2e       	mov	r8, r25
    22a2:	1e 01       	movw	r2, r28
    22a4:	08 94       	sec
    22a6:	21 1c       	adc	r2, r1
    22a8:	31 1c       	adc	r3, r1
    22aa:	f3 01       	movw	r30, r6
    22ac:	23 81       	ldd	r18, Z+3	; 0x03
    22ae:	f2 01       	movw	r30, r4
    22b0:	23 fd       	sbrc	r18, 3
    22b2:	85 91       	lpm	r24, Z+
    22b4:	23 ff       	sbrs	r18, 3
    22b6:	81 91       	ld	r24, Z+
    22b8:	2f 01       	movw	r4, r30
    22ba:	88 23       	and	r24, r24
    22bc:	09 f4       	brne	.+2      	; 0x22c0 <vfprintf+0x46>
    22be:	b2 c1       	rjmp	.+868    	; 0x2624 <vfprintf+0x3aa>
    22c0:	85 32       	cpi	r24, 0x25	; 37
    22c2:	39 f4       	brne	.+14     	; 0x22d2 <vfprintf+0x58>
    22c4:	23 fd       	sbrc	r18, 3
    22c6:	85 91       	lpm	r24, Z+
    22c8:	23 ff       	sbrs	r18, 3
    22ca:	81 91       	ld	r24, Z+
    22cc:	2f 01       	movw	r4, r30
    22ce:	85 32       	cpi	r24, 0x25	; 37
    22d0:	29 f4       	brne	.+10     	; 0x22dc <vfprintf+0x62>
    22d2:	90 e0       	ldi	r25, 0x00	; 0
    22d4:	b3 01       	movw	r22, r6
    22d6:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
    22da:	e7 cf       	rjmp	.-50     	; 0x22aa <vfprintf+0x30>
    22dc:	98 2f       	mov	r25, r24
    22de:	ff 24       	eor	r15, r15
    22e0:	ee 24       	eor	r14, r14
    22e2:	99 24       	eor	r9, r9
    22e4:	ff e1       	ldi	r31, 0x1F	; 31
    22e6:	ff 15       	cp	r31, r15
    22e8:	d0 f0       	brcs	.+52     	; 0x231e <vfprintf+0xa4>
    22ea:	9b 32       	cpi	r25, 0x2B	; 43
    22ec:	69 f0       	breq	.+26     	; 0x2308 <vfprintf+0x8e>
    22ee:	9c 32       	cpi	r25, 0x2C	; 44
    22f0:	28 f4       	brcc	.+10     	; 0x22fc <vfprintf+0x82>
    22f2:	90 32       	cpi	r25, 0x20	; 32
    22f4:	59 f0       	breq	.+22     	; 0x230c <vfprintf+0x92>
    22f6:	93 32       	cpi	r25, 0x23	; 35
    22f8:	91 f4       	brne	.+36     	; 0x231e <vfprintf+0xa4>
    22fa:	0e c0       	rjmp	.+28     	; 0x2318 <vfprintf+0x9e>
    22fc:	9d 32       	cpi	r25, 0x2D	; 45
    22fe:	49 f0       	breq	.+18     	; 0x2312 <vfprintf+0x98>
    2300:	90 33       	cpi	r25, 0x30	; 48
    2302:	69 f4       	brne	.+26     	; 0x231e <vfprintf+0xa4>
    2304:	41 e0       	ldi	r20, 0x01	; 1
    2306:	24 c0       	rjmp	.+72     	; 0x2350 <vfprintf+0xd6>
    2308:	52 e0       	ldi	r21, 0x02	; 2
    230a:	f5 2a       	or	r15, r21
    230c:	84 e0       	ldi	r24, 0x04	; 4
    230e:	f8 2a       	or	r15, r24
    2310:	28 c0       	rjmp	.+80     	; 0x2362 <vfprintf+0xe8>
    2312:	98 e0       	ldi	r25, 0x08	; 8
    2314:	f9 2a       	or	r15, r25
    2316:	25 c0       	rjmp	.+74     	; 0x2362 <vfprintf+0xe8>
    2318:	e0 e1       	ldi	r30, 0x10	; 16
    231a:	fe 2a       	or	r15, r30
    231c:	22 c0       	rjmp	.+68     	; 0x2362 <vfprintf+0xe8>
    231e:	f7 fc       	sbrc	r15, 7
    2320:	29 c0       	rjmp	.+82     	; 0x2374 <vfprintf+0xfa>
    2322:	89 2f       	mov	r24, r25
    2324:	80 53       	subi	r24, 0x30	; 48
    2326:	8a 30       	cpi	r24, 0x0A	; 10
    2328:	70 f4       	brcc	.+28     	; 0x2346 <vfprintf+0xcc>
    232a:	f6 fe       	sbrs	r15, 6
    232c:	05 c0       	rjmp	.+10     	; 0x2338 <vfprintf+0xbe>
    232e:	98 9c       	mul	r9, r8
    2330:	90 2c       	mov	r9, r0
    2332:	11 24       	eor	r1, r1
    2334:	98 0e       	add	r9, r24
    2336:	15 c0       	rjmp	.+42     	; 0x2362 <vfprintf+0xe8>
    2338:	e8 9c       	mul	r14, r8
    233a:	e0 2c       	mov	r14, r0
    233c:	11 24       	eor	r1, r1
    233e:	e8 0e       	add	r14, r24
    2340:	f0 e2       	ldi	r31, 0x20	; 32
    2342:	ff 2a       	or	r15, r31
    2344:	0e c0       	rjmp	.+28     	; 0x2362 <vfprintf+0xe8>
    2346:	9e 32       	cpi	r25, 0x2E	; 46
    2348:	29 f4       	brne	.+10     	; 0x2354 <vfprintf+0xda>
    234a:	f6 fc       	sbrc	r15, 6
    234c:	6b c1       	rjmp	.+726    	; 0x2624 <vfprintf+0x3aa>
    234e:	40 e4       	ldi	r20, 0x40	; 64
    2350:	f4 2a       	or	r15, r20
    2352:	07 c0       	rjmp	.+14     	; 0x2362 <vfprintf+0xe8>
    2354:	9c 36       	cpi	r25, 0x6C	; 108
    2356:	19 f4       	brne	.+6      	; 0x235e <vfprintf+0xe4>
    2358:	50 e8       	ldi	r21, 0x80	; 128
    235a:	f5 2a       	or	r15, r21
    235c:	02 c0       	rjmp	.+4      	; 0x2362 <vfprintf+0xe8>
    235e:	98 36       	cpi	r25, 0x68	; 104
    2360:	49 f4       	brne	.+18     	; 0x2374 <vfprintf+0xfa>
    2362:	f2 01       	movw	r30, r4
    2364:	23 fd       	sbrc	r18, 3
    2366:	95 91       	lpm	r25, Z+
    2368:	23 ff       	sbrs	r18, 3
    236a:	91 91       	ld	r25, Z+
    236c:	2f 01       	movw	r4, r30
    236e:	99 23       	and	r25, r25
    2370:	09 f0       	breq	.+2      	; 0x2374 <vfprintf+0xfa>
    2372:	b8 cf       	rjmp	.-144    	; 0x22e4 <vfprintf+0x6a>
    2374:	89 2f       	mov	r24, r25
    2376:	85 54       	subi	r24, 0x45	; 69
    2378:	83 30       	cpi	r24, 0x03	; 3
    237a:	18 f0       	brcs	.+6      	; 0x2382 <vfprintf+0x108>
    237c:	80 52       	subi	r24, 0x20	; 32
    237e:	83 30       	cpi	r24, 0x03	; 3
    2380:	38 f4       	brcc	.+14     	; 0x2390 <vfprintf+0x116>
    2382:	44 e0       	ldi	r20, 0x04	; 4
    2384:	50 e0       	ldi	r21, 0x00	; 0
    2386:	a4 0e       	add	r10, r20
    2388:	b5 1e       	adc	r11, r21
    238a:	5f e3       	ldi	r21, 0x3F	; 63
    238c:	59 83       	std	Y+1, r21	; 0x01
    238e:	0f c0       	rjmp	.+30     	; 0x23ae <vfprintf+0x134>
    2390:	93 36       	cpi	r25, 0x63	; 99
    2392:	31 f0       	breq	.+12     	; 0x23a0 <vfprintf+0x126>
    2394:	93 37       	cpi	r25, 0x73	; 115
    2396:	79 f0       	breq	.+30     	; 0x23b6 <vfprintf+0x13c>
    2398:	93 35       	cpi	r25, 0x53	; 83
    239a:	09 f0       	breq	.+2      	; 0x239e <vfprintf+0x124>
    239c:	56 c0       	rjmp	.+172    	; 0x244a <vfprintf+0x1d0>
    239e:	20 c0       	rjmp	.+64     	; 0x23e0 <vfprintf+0x166>
    23a0:	f5 01       	movw	r30, r10
    23a2:	80 81       	ld	r24, Z
    23a4:	89 83       	std	Y+1, r24	; 0x01
    23a6:	42 e0       	ldi	r20, 0x02	; 2
    23a8:	50 e0       	ldi	r21, 0x00	; 0
    23aa:	a4 0e       	add	r10, r20
    23ac:	b5 1e       	adc	r11, r21
    23ae:	61 01       	movw	r12, r2
    23b0:	01 e0       	ldi	r16, 0x01	; 1
    23b2:	10 e0       	ldi	r17, 0x00	; 0
    23b4:	12 c0       	rjmp	.+36     	; 0x23da <vfprintf+0x160>
    23b6:	f5 01       	movw	r30, r10
    23b8:	c0 80       	ld	r12, Z
    23ba:	d1 80       	ldd	r13, Z+1	; 0x01
    23bc:	f6 fc       	sbrc	r15, 6
    23be:	03 c0       	rjmp	.+6      	; 0x23c6 <vfprintf+0x14c>
    23c0:	6f ef       	ldi	r22, 0xFF	; 255
    23c2:	7f ef       	ldi	r23, 0xFF	; 255
    23c4:	02 c0       	rjmp	.+4      	; 0x23ca <vfprintf+0x150>
    23c6:	69 2d       	mov	r22, r9
    23c8:	70 e0       	ldi	r23, 0x00	; 0
    23ca:	42 e0       	ldi	r20, 0x02	; 2
    23cc:	50 e0       	ldi	r21, 0x00	; 0
    23ce:	a4 0e       	add	r10, r20
    23d0:	b5 1e       	adc	r11, r21
    23d2:	c6 01       	movw	r24, r12
    23d4:	0e 94 25 13 	call	0x264a	; 0x264a <strnlen>
    23d8:	8c 01       	movw	r16, r24
    23da:	5f e7       	ldi	r21, 0x7F	; 127
    23dc:	f5 22       	and	r15, r21
    23de:	14 c0       	rjmp	.+40     	; 0x2408 <vfprintf+0x18e>
    23e0:	f5 01       	movw	r30, r10
    23e2:	c0 80       	ld	r12, Z
    23e4:	d1 80       	ldd	r13, Z+1	; 0x01
    23e6:	f6 fc       	sbrc	r15, 6
    23e8:	03 c0       	rjmp	.+6      	; 0x23f0 <vfprintf+0x176>
    23ea:	6f ef       	ldi	r22, 0xFF	; 255
    23ec:	7f ef       	ldi	r23, 0xFF	; 255
    23ee:	02 c0       	rjmp	.+4      	; 0x23f4 <vfprintf+0x17a>
    23f0:	69 2d       	mov	r22, r9
    23f2:	70 e0       	ldi	r23, 0x00	; 0
    23f4:	42 e0       	ldi	r20, 0x02	; 2
    23f6:	50 e0       	ldi	r21, 0x00	; 0
    23f8:	a4 0e       	add	r10, r20
    23fa:	b5 1e       	adc	r11, r21
    23fc:	c6 01       	movw	r24, r12
    23fe:	0e 94 1a 13 	call	0x2634	; 0x2634 <strnlen_P>
    2402:	8c 01       	movw	r16, r24
    2404:	50 e8       	ldi	r21, 0x80	; 128
    2406:	f5 2a       	or	r15, r21
    2408:	f3 fe       	sbrs	r15, 3
    240a:	07 c0       	rjmp	.+14     	; 0x241a <vfprintf+0x1a0>
    240c:	1a c0       	rjmp	.+52     	; 0x2442 <vfprintf+0x1c8>
    240e:	80 e2       	ldi	r24, 0x20	; 32
    2410:	90 e0       	ldi	r25, 0x00	; 0
    2412:	b3 01       	movw	r22, r6
    2414:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
    2418:	ea 94       	dec	r14
    241a:	8e 2d       	mov	r24, r14
    241c:	90 e0       	ldi	r25, 0x00	; 0
    241e:	08 17       	cp	r16, r24
    2420:	19 07       	cpc	r17, r25
    2422:	a8 f3       	brcs	.-22     	; 0x240e <vfprintf+0x194>
    2424:	0e c0       	rjmp	.+28     	; 0x2442 <vfprintf+0x1c8>
    2426:	f6 01       	movw	r30, r12
    2428:	f7 fc       	sbrc	r15, 7
    242a:	85 91       	lpm	r24, Z+
    242c:	f7 fe       	sbrs	r15, 7
    242e:	81 91       	ld	r24, Z+
    2430:	6f 01       	movw	r12, r30
    2432:	90 e0       	ldi	r25, 0x00	; 0
    2434:	b3 01       	movw	r22, r6
    2436:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
    243a:	e1 10       	cpse	r14, r1
    243c:	ea 94       	dec	r14
    243e:	01 50       	subi	r16, 0x01	; 1
    2440:	10 40       	sbci	r17, 0x00	; 0
    2442:	01 15       	cp	r16, r1
    2444:	11 05       	cpc	r17, r1
    2446:	79 f7       	brne	.-34     	; 0x2426 <vfprintf+0x1ac>
    2448:	ea c0       	rjmp	.+468    	; 0x261e <vfprintf+0x3a4>
    244a:	94 36       	cpi	r25, 0x64	; 100
    244c:	11 f0       	breq	.+4      	; 0x2452 <vfprintf+0x1d8>
    244e:	99 36       	cpi	r25, 0x69	; 105
    2450:	69 f5       	brne	.+90     	; 0x24ac <vfprintf+0x232>
    2452:	f7 fe       	sbrs	r15, 7
    2454:	08 c0       	rjmp	.+16     	; 0x2466 <vfprintf+0x1ec>
    2456:	f5 01       	movw	r30, r10
    2458:	20 81       	ld	r18, Z
    245a:	31 81       	ldd	r19, Z+1	; 0x01
    245c:	42 81       	ldd	r20, Z+2	; 0x02
    245e:	53 81       	ldd	r21, Z+3	; 0x03
    2460:	84 e0       	ldi	r24, 0x04	; 4
    2462:	90 e0       	ldi	r25, 0x00	; 0
    2464:	0a c0       	rjmp	.+20     	; 0x247a <vfprintf+0x200>
    2466:	f5 01       	movw	r30, r10
    2468:	80 81       	ld	r24, Z
    246a:	91 81       	ldd	r25, Z+1	; 0x01
    246c:	9c 01       	movw	r18, r24
    246e:	44 27       	eor	r20, r20
    2470:	37 fd       	sbrc	r19, 7
    2472:	40 95       	com	r20
    2474:	54 2f       	mov	r21, r20
    2476:	82 e0       	ldi	r24, 0x02	; 2
    2478:	90 e0       	ldi	r25, 0x00	; 0
    247a:	a8 0e       	add	r10, r24
    247c:	b9 1e       	adc	r11, r25
    247e:	9f e6       	ldi	r25, 0x6F	; 111
    2480:	f9 22       	and	r15, r25
    2482:	57 ff       	sbrs	r21, 7
    2484:	09 c0       	rjmp	.+18     	; 0x2498 <vfprintf+0x21e>
    2486:	50 95       	com	r21
    2488:	40 95       	com	r20
    248a:	30 95       	com	r19
    248c:	21 95       	neg	r18
    248e:	3f 4f       	sbci	r19, 0xFF	; 255
    2490:	4f 4f       	sbci	r20, 0xFF	; 255
    2492:	5f 4f       	sbci	r21, 0xFF	; 255
    2494:	e0 e8       	ldi	r30, 0x80	; 128
    2496:	fe 2a       	or	r15, r30
    2498:	ca 01       	movw	r24, r20
    249a:	b9 01       	movw	r22, r18
    249c:	a1 01       	movw	r20, r2
    249e:	2a e0       	ldi	r18, 0x0A	; 10
    24a0:	30 e0       	ldi	r19, 0x00	; 0
    24a2:	0e 94 30 13 	call	0x2660	; 0x2660 <__ultoa_invert>
    24a6:	d8 2e       	mov	r13, r24
    24a8:	d2 18       	sub	r13, r2
    24aa:	40 c0       	rjmp	.+128    	; 0x252c <vfprintf+0x2b2>
    24ac:	95 37       	cpi	r25, 0x75	; 117
    24ae:	29 f4       	brne	.+10     	; 0x24ba <vfprintf+0x240>
    24b0:	1f 2d       	mov	r17, r15
    24b2:	1f 7e       	andi	r17, 0xEF	; 239
    24b4:	2a e0       	ldi	r18, 0x0A	; 10
    24b6:	30 e0       	ldi	r19, 0x00	; 0
    24b8:	1d c0       	rjmp	.+58     	; 0x24f4 <vfprintf+0x27a>
    24ba:	1f 2d       	mov	r17, r15
    24bc:	19 7f       	andi	r17, 0xF9	; 249
    24be:	9f 36       	cpi	r25, 0x6F	; 111
    24c0:	61 f0       	breq	.+24     	; 0x24da <vfprintf+0x260>
    24c2:	90 37       	cpi	r25, 0x70	; 112
    24c4:	20 f4       	brcc	.+8      	; 0x24ce <vfprintf+0x254>
    24c6:	98 35       	cpi	r25, 0x58	; 88
    24c8:	09 f0       	breq	.+2      	; 0x24cc <vfprintf+0x252>
    24ca:	ac c0       	rjmp	.+344    	; 0x2624 <vfprintf+0x3aa>
    24cc:	0f c0       	rjmp	.+30     	; 0x24ec <vfprintf+0x272>
    24ce:	90 37       	cpi	r25, 0x70	; 112
    24d0:	39 f0       	breq	.+14     	; 0x24e0 <vfprintf+0x266>
    24d2:	98 37       	cpi	r25, 0x78	; 120
    24d4:	09 f0       	breq	.+2      	; 0x24d8 <vfprintf+0x25e>
    24d6:	a6 c0       	rjmp	.+332    	; 0x2624 <vfprintf+0x3aa>
    24d8:	04 c0       	rjmp	.+8      	; 0x24e2 <vfprintf+0x268>
    24da:	28 e0       	ldi	r18, 0x08	; 8
    24dc:	30 e0       	ldi	r19, 0x00	; 0
    24de:	0a c0       	rjmp	.+20     	; 0x24f4 <vfprintf+0x27a>
    24e0:	10 61       	ori	r17, 0x10	; 16
    24e2:	14 fd       	sbrc	r17, 4
    24e4:	14 60       	ori	r17, 0x04	; 4
    24e6:	20 e1       	ldi	r18, 0x10	; 16
    24e8:	30 e0       	ldi	r19, 0x00	; 0
    24ea:	04 c0       	rjmp	.+8      	; 0x24f4 <vfprintf+0x27a>
    24ec:	14 fd       	sbrc	r17, 4
    24ee:	16 60       	ori	r17, 0x06	; 6
    24f0:	20 e1       	ldi	r18, 0x10	; 16
    24f2:	32 e0       	ldi	r19, 0x02	; 2
    24f4:	17 ff       	sbrs	r17, 7
    24f6:	08 c0       	rjmp	.+16     	; 0x2508 <vfprintf+0x28e>
    24f8:	f5 01       	movw	r30, r10
    24fa:	60 81       	ld	r22, Z
    24fc:	71 81       	ldd	r23, Z+1	; 0x01
    24fe:	82 81       	ldd	r24, Z+2	; 0x02
    2500:	93 81       	ldd	r25, Z+3	; 0x03
    2502:	44 e0       	ldi	r20, 0x04	; 4
    2504:	50 e0       	ldi	r21, 0x00	; 0
    2506:	08 c0       	rjmp	.+16     	; 0x2518 <vfprintf+0x29e>
    2508:	f5 01       	movw	r30, r10
    250a:	80 81       	ld	r24, Z
    250c:	91 81       	ldd	r25, Z+1	; 0x01
    250e:	bc 01       	movw	r22, r24
    2510:	80 e0       	ldi	r24, 0x00	; 0
    2512:	90 e0       	ldi	r25, 0x00	; 0
    2514:	42 e0       	ldi	r20, 0x02	; 2
    2516:	50 e0       	ldi	r21, 0x00	; 0
    2518:	a4 0e       	add	r10, r20
    251a:	b5 1e       	adc	r11, r21
    251c:	a1 01       	movw	r20, r2
    251e:	0e 94 30 13 	call	0x2660	; 0x2660 <__ultoa_invert>
    2522:	d8 2e       	mov	r13, r24
    2524:	d2 18       	sub	r13, r2
    2526:	8f e7       	ldi	r24, 0x7F	; 127
    2528:	f8 2e       	mov	r15, r24
    252a:	f1 22       	and	r15, r17
    252c:	f6 fe       	sbrs	r15, 6
    252e:	0b c0       	rjmp	.+22     	; 0x2546 <vfprintf+0x2cc>
    2530:	5e ef       	ldi	r21, 0xFE	; 254
    2532:	f5 22       	and	r15, r21
    2534:	d9 14       	cp	r13, r9
    2536:	38 f4       	brcc	.+14     	; 0x2546 <vfprintf+0x2cc>
    2538:	f4 fe       	sbrs	r15, 4
    253a:	07 c0       	rjmp	.+14     	; 0x254a <vfprintf+0x2d0>
    253c:	f2 fc       	sbrc	r15, 2
    253e:	05 c0       	rjmp	.+10     	; 0x254a <vfprintf+0x2d0>
    2540:	8f ee       	ldi	r24, 0xEF	; 239
    2542:	f8 22       	and	r15, r24
    2544:	02 c0       	rjmp	.+4      	; 0x254a <vfprintf+0x2d0>
    2546:	1d 2d       	mov	r17, r13
    2548:	01 c0       	rjmp	.+2      	; 0x254c <vfprintf+0x2d2>
    254a:	19 2d       	mov	r17, r9
    254c:	f4 fe       	sbrs	r15, 4
    254e:	0d c0       	rjmp	.+26     	; 0x256a <vfprintf+0x2f0>
    2550:	fe 01       	movw	r30, r28
    2552:	ed 0d       	add	r30, r13
    2554:	f1 1d       	adc	r31, r1
    2556:	80 81       	ld	r24, Z
    2558:	80 33       	cpi	r24, 0x30	; 48
    255a:	19 f4       	brne	.+6      	; 0x2562 <vfprintf+0x2e8>
    255c:	99 ee       	ldi	r25, 0xE9	; 233
    255e:	f9 22       	and	r15, r25
    2560:	08 c0       	rjmp	.+16     	; 0x2572 <vfprintf+0x2f8>
    2562:	1f 5f       	subi	r17, 0xFF	; 255
    2564:	f2 fe       	sbrs	r15, 2
    2566:	05 c0       	rjmp	.+10     	; 0x2572 <vfprintf+0x2f8>
    2568:	03 c0       	rjmp	.+6      	; 0x2570 <vfprintf+0x2f6>
    256a:	8f 2d       	mov	r24, r15
    256c:	86 78       	andi	r24, 0x86	; 134
    256e:	09 f0       	breq	.+2      	; 0x2572 <vfprintf+0x2f8>
    2570:	1f 5f       	subi	r17, 0xFF	; 255
    2572:	0f 2d       	mov	r16, r15
    2574:	f3 fc       	sbrc	r15, 3
    2576:	14 c0       	rjmp	.+40     	; 0x25a0 <vfprintf+0x326>
    2578:	f0 fe       	sbrs	r15, 0
    257a:	0f c0       	rjmp	.+30     	; 0x259a <vfprintf+0x320>
    257c:	1e 15       	cp	r17, r14
    257e:	10 f0       	brcs	.+4      	; 0x2584 <vfprintf+0x30a>
    2580:	9d 2c       	mov	r9, r13
    2582:	0b c0       	rjmp	.+22     	; 0x259a <vfprintf+0x320>
    2584:	9d 2c       	mov	r9, r13
    2586:	9e 0c       	add	r9, r14
    2588:	91 1a       	sub	r9, r17
    258a:	1e 2d       	mov	r17, r14
    258c:	06 c0       	rjmp	.+12     	; 0x259a <vfprintf+0x320>
    258e:	80 e2       	ldi	r24, 0x20	; 32
    2590:	90 e0       	ldi	r25, 0x00	; 0
    2592:	b3 01       	movw	r22, r6
    2594:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
    2598:	1f 5f       	subi	r17, 0xFF	; 255
    259a:	1e 15       	cp	r17, r14
    259c:	c0 f3       	brcs	.-16     	; 0x258e <vfprintf+0x314>
    259e:	04 c0       	rjmp	.+8      	; 0x25a8 <vfprintf+0x32e>
    25a0:	1e 15       	cp	r17, r14
    25a2:	10 f4       	brcc	.+4      	; 0x25a8 <vfprintf+0x32e>
    25a4:	e1 1a       	sub	r14, r17
    25a6:	01 c0       	rjmp	.+2      	; 0x25aa <vfprintf+0x330>
    25a8:	ee 24       	eor	r14, r14
    25aa:	04 ff       	sbrs	r16, 4
    25ac:	0f c0       	rjmp	.+30     	; 0x25cc <vfprintf+0x352>
    25ae:	80 e3       	ldi	r24, 0x30	; 48
    25b0:	90 e0       	ldi	r25, 0x00	; 0
    25b2:	b3 01       	movw	r22, r6
    25b4:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
    25b8:	02 ff       	sbrs	r16, 2
    25ba:	1d c0       	rjmp	.+58     	; 0x25f6 <vfprintf+0x37c>
    25bc:	01 fd       	sbrc	r16, 1
    25be:	03 c0       	rjmp	.+6      	; 0x25c6 <vfprintf+0x34c>
    25c0:	88 e7       	ldi	r24, 0x78	; 120
    25c2:	90 e0       	ldi	r25, 0x00	; 0
    25c4:	0e c0       	rjmp	.+28     	; 0x25e2 <vfprintf+0x368>
    25c6:	88 e5       	ldi	r24, 0x58	; 88
    25c8:	90 e0       	ldi	r25, 0x00	; 0
    25ca:	0b c0       	rjmp	.+22     	; 0x25e2 <vfprintf+0x368>
    25cc:	80 2f       	mov	r24, r16
    25ce:	86 78       	andi	r24, 0x86	; 134
    25d0:	91 f0       	breq	.+36     	; 0x25f6 <vfprintf+0x37c>
    25d2:	01 ff       	sbrs	r16, 1
    25d4:	02 c0       	rjmp	.+4      	; 0x25da <vfprintf+0x360>
    25d6:	8b e2       	ldi	r24, 0x2B	; 43
    25d8:	01 c0       	rjmp	.+2      	; 0x25dc <vfprintf+0x362>
    25da:	80 e2       	ldi	r24, 0x20	; 32
    25dc:	f7 fc       	sbrc	r15, 7
    25de:	8d e2       	ldi	r24, 0x2D	; 45
    25e0:	90 e0       	ldi	r25, 0x00	; 0
    25e2:	b3 01       	movw	r22, r6
    25e4:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
    25e8:	06 c0       	rjmp	.+12     	; 0x25f6 <vfprintf+0x37c>
    25ea:	80 e3       	ldi	r24, 0x30	; 48
    25ec:	90 e0       	ldi	r25, 0x00	; 0
    25ee:	b3 01       	movw	r22, r6
    25f0:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
    25f4:	9a 94       	dec	r9
    25f6:	d9 14       	cp	r13, r9
    25f8:	c0 f3       	brcs	.-16     	; 0x25ea <vfprintf+0x370>
    25fa:	da 94       	dec	r13
    25fc:	f1 01       	movw	r30, r2
    25fe:	ed 0d       	add	r30, r13
    2600:	f1 1d       	adc	r31, r1
    2602:	80 81       	ld	r24, Z
    2604:	90 e0       	ldi	r25, 0x00	; 0
    2606:	b3 01       	movw	r22, r6
    2608:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
    260c:	dd 20       	and	r13, r13
    260e:	a9 f7       	brne	.-22     	; 0x25fa <vfprintf+0x380>
    2610:	06 c0       	rjmp	.+12     	; 0x261e <vfprintf+0x3a4>
    2612:	80 e2       	ldi	r24, 0x20	; 32
    2614:	90 e0       	ldi	r25, 0x00	; 0
    2616:	b3 01       	movw	r22, r6
    2618:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <fputc>
    261c:	ea 94       	dec	r14
    261e:	ee 20       	and	r14, r14
    2620:	c1 f7       	brne	.-16     	; 0x2612 <vfprintf+0x398>
    2622:	43 ce       	rjmp	.-890    	; 0x22aa <vfprintf+0x30>
    2624:	f3 01       	movw	r30, r6
    2626:	66 81       	ldd	r22, Z+6	; 0x06
    2628:	77 81       	ldd	r23, Z+7	; 0x07
    262a:	cb 01       	movw	r24, r22
    262c:	2b 96       	adiw	r28, 0x0b	; 11
    262e:	e2 e1       	ldi	r30, 0x12	; 18
    2630:	0c 94 dd 13 	jmp	0x27ba	; 0x27ba <__epilogue_restores__>

00002634 <strnlen_P>:
    2634:	fc 01       	movw	r30, r24
    2636:	05 90       	lpm	r0, Z+
    2638:	61 50       	subi	r22, 0x01	; 1
    263a:	70 40       	sbci	r23, 0x00	; 0
    263c:	01 10       	cpse	r0, r1
    263e:	d8 f7       	brcc	.-10     	; 0x2636 <strnlen_P+0x2>
    2640:	80 95       	com	r24
    2642:	90 95       	com	r25
    2644:	8e 0f       	add	r24, r30
    2646:	9f 1f       	adc	r25, r31
    2648:	08 95       	ret

0000264a <strnlen>:
    264a:	fc 01       	movw	r30, r24
    264c:	61 50       	subi	r22, 0x01	; 1
    264e:	70 40       	sbci	r23, 0x00	; 0
    2650:	01 90       	ld	r0, Z+
    2652:	01 10       	cpse	r0, r1
    2654:	d8 f7       	brcc	.-10     	; 0x264c <strnlen+0x2>
    2656:	80 95       	com	r24
    2658:	90 95       	com	r25
    265a:	8e 0f       	add	r24, r30
    265c:	9f 1f       	adc	r25, r31
    265e:	08 95       	ret

00002660 <__ultoa_invert>:
    2660:	fa 01       	movw	r30, r20
    2662:	aa 27       	eor	r26, r26
    2664:	28 30       	cpi	r18, 0x08	; 8
    2666:	51 f1       	breq	.+84     	; 0x26bc <__ultoa_invert+0x5c>
    2668:	20 31       	cpi	r18, 0x10	; 16
    266a:	81 f1       	breq	.+96     	; 0x26cc <__ultoa_invert+0x6c>
    266c:	e8 94       	clt
    266e:	6f 93       	push	r22
    2670:	6e 7f       	andi	r22, 0xFE	; 254
    2672:	6e 5f       	subi	r22, 0xFE	; 254
    2674:	7f 4f       	sbci	r23, 0xFF	; 255
    2676:	8f 4f       	sbci	r24, 0xFF	; 255
    2678:	9f 4f       	sbci	r25, 0xFF	; 255
    267a:	af 4f       	sbci	r26, 0xFF	; 255
    267c:	b1 e0       	ldi	r27, 0x01	; 1
    267e:	3e d0       	rcall	.+124    	; 0x26fc <__ultoa_invert+0x9c>
    2680:	b4 e0       	ldi	r27, 0x04	; 4
    2682:	3c d0       	rcall	.+120    	; 0x26fc <__ultoa_invert+0x9c>
    2684:	67 0f       	add	r22, r23
    2686:	78 1f       	adc	r23, r24
    2688:	89 1f       	adc	r24, r25
    268a:	9a 1f       	adc	r25, r26
    268c:	a1 1d       	adc	r26, r1
    268e:	68 0f       	add	r22, r24
    2690:	79 1f       	adc	r23, r25
    2692:	8a 1f       	adc	r24, r26
    2694:	91 1d       	adc	r25, r1
    2696:	a1 1d       	adc	r26, r1
    2698:	6a 0f       	add	r22, r26
    269a:	71 1d       	adc	r23, r1
    269c:	81 1d       	adc	r24, r1
    269e:	91 1d       	adc	r25, r1
    26a0:	a1 1d       	adc	r26, r1
    26a2:	20 d0       	rcall	.+64     	; 0x26e4 <__ultoa_invert+0x84>
    26a4:	09 f4       	brne	.+2      	; 0x26a8 <__ultoa_invert+0x48>
    26a6:	68 94       	set
    26a8:	3f 91       	pop	r19
    26aa:	2a e0       	ldi	r18, 0x0A	; 10
    26ac:	26 9f       	mul	r18, r22
    26ae:	11 24       	eor	r1, r1
    26b0:	30 19       	sub	r19, r0
    26b2:	30 5d       	subi	r19, 0xD0	; 208
    26b4:	31 93       	st	Z+, r19
    26b6:	de f6       	brtc	.-74     	; 0x266e <__ultoa_invert+0xe>
    26b8:	cf 01       	movw	r24, r30
    26ba:	08 95       	ret
    26bc:	46 2f       	mov	r20, r22
    26be:	47 70       	andi	r20, 0x07	; 7
    26c0:	40 5d       	subi	r20, 0xD0	; 208
    26c2:	41 93       	st	Z+, r20
    26c4:	b3 e0       	ldi	r27, 0x03	; 3
    26c6:	0f d0       	rcall	.+30     	; 0x26e6 <__ultoa_invert+0x86>
    26c8:	c9 f7       	brne	.-14     	; 0x26bc <__ultoa_invert+0x5c>
    26ca:	f6 cf       	rjmp	.-20     	; 0x26b8 <__ultoa_invert+0x58>
    26cc:	46 2f       	mov	r20, r22
    26ce:	4f 70       	andi	r20, 0x0F	; 15
    26d0:	40 5d       	subi	r20, 0xD0	; 208
    26d2:	4a 33       	cpi	r20, 0x3A	; 58
    26d4:	18 f0       	brcs	.+6      	; 0x26dc <__ultoa_invert+0x7c>
    26d6:	49 5d       	subi	r20, 0xD9	; 217
    26d8:	31 fd       	sbrc	r19, 1
    26da:	40 52       	subi	r20, 0x20	; 32
    26dc:	41 93       	st	Z+, r20
    26de:	02 d0       	rcall	.+4      	; 0x26e4 <__ultoa_invert+0x84>
    26e0:	a9 f7       	brne	.-22     	; 0x26cc <__ultoa_invert+0x6c>
    26e2:	ea cf       	rjmp	.-44     	; 0x26b8 <__ultoa_invert+0x58>
    26e4:	b4 e0       	ldi	r27, 0x04	; 4
    26e6:	a6 95       	lsr	r26
    26e8:	97 95       	ror	r25
    26ea:	87 95       	ror	r24
    26ec:	77 95       	ror	r23
    26ee:	67 95       	ror	r22
    26f0:	ba 95       	dec	r27
    26f2:	c9 f7       	brne	.-14     	; 0x26e6 <__ultoa_invert+0x86>
    26f4:	00 97       	sbiw	r24, 0x00	; 0
    26f6:	61 05       	cpc	r22, r1
    26f8:	71 05       	cpc	r23, r1
    26fa:	08 95       	ret
    26fc:	9b 01       	movw	r18, r22
    26fe:	ac 01       	movw	r20, r24
    2700:	0a 2e       	mov	r0, r26
    2702:	06 94       	lsr	r0
    2704:	57 95       	ror	r21
    2706:	47 95       	ror	r20
    2708:	37 95       	ror	r19
    270a:	27 95       	ror	r18
    270c:	ba 95       	dec	r27
    270e:	c9 f7       	brne	.-14     	; 0x2702 <__ultoa_invert+0xa2>
    2710:	62 0f       	add	r22, r18
    2712:	73 1f       	adc	r23, r19
    2714:	84 1f       	adc	r24, r20
    2716:	95 1f       	adc	r25, r21
    2718:	a0 1d       	adc	r26, r0
    271a:	08 95       	ret

0000271c <__udivmodqi4>:
    271c:	99 1b       	sub	r25, r25
    271e:	79 e0       	ldi	r23, 0x09	; 9
    2720:	04 c0       	rjmp	.+8      	; 0x272a <__udivmodqi4_ep>

00002722 <__udivmodqi4_loop>:
    2722:	99 1f       	adc	r25, r25
    2724:	96 17       	cp	r25, r22
    2726:	08 f0       	brcs	.+2      	; 0x272a <__udivmodqi4_ep>
    2728:	96 1b       	sub	r25, r22

0000272a <__udivmodqi4_ep>:
    272a:	88 1f       	adc	r24, r24
    272c:	7a 95       	dec	r23
    272e:	c9 f7       	brne	.-14     	; 0x2722 <__udivmodqi4_loop>
    2730:	80 95       	com	r24
    2732:	08 95       	ret

00002734 <__divmodhi4>:
    2734:	97 fb       	bst	r25, 7
    2736:	09 2e       	mov	r0, r25
    2738:	07 26       	eor	r0, r23
    273a:	0a d0       	rcall	.+20     	; 0x2750 <__divmodhi4_neg1>
    273c:	77 fd       	sbrc	r23, 7
    273e:	04 d0       	rcall	.+8      	; 0x2748 <__divmodhi4_neg2>
    2740:	0c d0       	rcall	.+24     	; 0x275a <__udivmodhi4>
    2742:	06 d0       	rcall	.+12     	; 0x2750 <__divmodhi4_neg1>
    2744:	00 20       	and	r0, r0
    2746:	1a f4       	brpl	.+6      	; 0x274e <__divmodhi4_exit>

00002748 <__divmodhi4_neg2>:
    2748:	70 95       	com	r23
    274a:	61 95       	neg	r22
    274c:	7f 4f       	sbci	r23, 0xFF	; 255

0000274e <__divmodhi4_exit>:
    274e:	08 95       	ret

00002750 <__divmodhi4_neg1>:
    2750:	f6 f7       	brtc	.-4      	; 0x274e <__divmodhi4_exit>
    2752:	90 95       	com	r25
    2754:	81 95       	neg	r24
    2756:	9f 4f       	sbci	r25, 0xFF	; 255
    2758:	08 95       	ret

0000275a <__udivmodhi4>:
    275a:	aa 1b       	sub	r26, r26
    275c:	bb 1b       	sub	r27, r27
    275e:	51 e1       	ldi	r21, 0x11	; 17
    2760:	07 c0       	rjmp	.+14     	; 0x2770 <__udivmodhi4_ep>

00002762 <__udivmodhi4_loop>:
    2762:	aa 1f       	adc	r26, r26
    2764:	bb 1f       	adc	r27, r27
    2766:	a6 17       	cp	r26, r22
    2768:	b7 07       	cpc	r27, r23
    276a:	10 f0       	brcs	.+4      	; 0x2770 <__udivmodhi4_ep>
    276c:	a6 1b       	sub	r26, r22
    276e:	b7 0b       	sbc	r27, r23

00002770 <__udivmodhi4_ep>:
    2770:	88 1f       	adc	r24, r24
    2772:	99 1f       	adc	r25, r25
    2774:	5a 95       	dec	r21
    2776:	a9 f7       	brne	.-22     	; 0x2762 <__udivmodhi4_loop>
    2778:	80 95       	com	r24
    277a:	90 95       	com	r25
    277c:	bc 01       	movw	r22, r24
    277e:	cd 01       	movw	r24, r26
    2780:	08 95       	ret

00002782 <__prologue_saves__>:
    2782:	2f 92       	push	r2
    2784:	3f 92       	push	r3
    2786:	4f 92       	push	r4
    2788:	5f 92       	push	r5
    278a:	6f 92       	push	r6
    278c:	7f 92       	push	r7
    278e:	8f 92       	push	r8
    2790:	9f 92       	push	r9
    2792:	af 92       	push	r10
    2794:	bf 92       	push	r11
    2796:	cf 92       	push	r12
    2798:	df 92       	push	r13
    279a:	ef 92       	push	r14
    279c:	ff 92       	push	r15
    279e:	0f 93       	push	r16
    27a0:	1f 93       	push	r17
    27a2:	cf 93       	push	r28
    27a4:	df 93       	push	r29
    27a6:	cd b7       	in	r28, 0x3d	; 61
    27a8:	de b7       	in	r29, 0x3e	; 62
    27aa:	ca 1b       	sub	r28, r26
    27ac:	db 0b       	sbc	r29, r27
    27ae:	0f b6       	in	r0, 0x3f	; 63
    27b0:	f8 94       	cli
    27b2:	de bf       	out	0x3e, r29	; 62
    27b4:	0f be       	out	0x3f, r0	; 63
    27b6:	cd bf       	out	0x3d, r28	; 61
    27b8:	09 94       	ijmp

000027ba <__epilogue_restores__>:
    27ba:	2a 88       	ldd	r2, Y+18	; 0x12
    27bc:	39 88       	ldd	r3, Y+17	; 0x11
    27be:	48 88       	ldd	r4, Y+16	; 0x10
    27c0:	5f 84       	ldd	r5, Y+15	; 0x0f
    27c2:	6e 84       	ldd	r6, Y+14	; 0x0e
    27c4:	7d 84       	ldd	r7, Y+13	; 0x0d
    27c6:	8c 84       	ldd	r8, Y+12	; 0x0c
    27c8:	9b 84       	ldd	r9, Y+11	; 0x0b
    27ca:	aa 84       	ldd	r10, Y+10	; 0x0a
    27cc:	b9 84       	ldd	r11, Y+9	; 0x09
    27ce:	c8 84       	ldd	r12, Y+8	; 0x08
    27d0:	df 80       	ldd	r13, Y+7	; 0x07
    27d2:	ee 80       	ldd	r14, Y+6	; 0x06
    27d4:	fd 80       	ldd	r15, Y+5	; 0x05
    27d6:	0c 81       	ldd	r16, Y+4	; 0x04
    27d8:	1b 81       	ldd	r17, Y+3	; 0x03
    27da:	aa 81       	ldd	r26, Y+2	; 0x02
    27dc:	b9 81       	ldd	r27, Y+1	; 0x01
    27de:	ce 0f       	add	r28, r30
    27e0:	d1 1d       	adc	r29, r1
    27e2:	0f b6       	in	r0, 0x3f	; 63
    27e4:	f8 94       	cli
    27e6:	de bf       	out	0x3e, r29	; 62
    27e8:	0f be       	out	0x3f, r0	; 63
    27ea:	cd bf       	out	0x3d, r28	; 61
    27ec:	ed 01       	movw	r28, r26
    27ee:	08 95       	ret

000027f0 <_exit>:
    27f0:	f8 94       	cli

000027f2 <__stop_program>:
    27f2:	ff cf       	rjmp	.-2      	; 0x27f2 <__stop_program>
